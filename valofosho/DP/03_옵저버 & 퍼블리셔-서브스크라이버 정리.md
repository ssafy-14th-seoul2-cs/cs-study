# 📡 옵저버 패턴 & 퍼블리셔–서브스크라이버 패턴 정리

---

# 1️⃣ 옵저버 패턴 (Observer Pattern)

## 📌 개념

> **한 객체의 상태 변화가 있을 때**,
> **그 객체(Subject)를 관찰(Observe)하는 다른 객체(Observer)들에게 자동으로 알림**이 가는 패턴.

즉,
“주식 가격이 변하면 여러 화면이 동시에 갱신된다”
“게임에서 체력 바가 줄면 HUD가 자동 업데이트된다” 같은 상황.

---

## 🧩 구조

```
[Subject]
  ├─ observers 리스트 보유
  ├─ register(observer)
  ├─ unregister(observer)
  └─ notify()

[Observer]
  └─ update()
```

---

## 🐍 Python 예제

```python
from abc import ABC, abstractmethod

class Observer(ABC):
    @abstractmethod
    def update(self, data):
        pass


class Subject:
    def __init__(self):
        self.observers = []
        self.state = None

    def register(self, observer: Observer):
        self.observers.append(observer)

    def unregister(self, observer: Observer):
        self.observers.remove(observer)

    def notify(self):
        for obs in self.observers:
            obs.update(self.state)

    def set_state(self, value):
        self.state = value
        self.notify()


# Observer 구현체
class UserDisplay(Observer):
    def update(self, data):
        print(f"[UserDisplay] 새 데이터: {data}")

class Logger(Observer):
    def update(self, data):
        print(f"[Logger] 기록: {data}")


# 사용
subject = Subject()
subject.register(UserDisplay())
subject.register(Logger())

subject.set_state("price changed!")
# [UserDisplay] 새 데이터: price changed!
# [Logger] 기록: price changed!
```

---

## 👍 장점

* 객체 간 결합도 낮음 (Observer는 Subject 내부 상태를 직접 몰라도 됨)
* 확장성 좋음(Observer 추가 쉬움)
* 자동 업데이트

## 👎 단점

* Observer 수가 많으면 Notify 비용 증가
* 순환참조/메모리 관리 조심
* 동기 방식(ver)이면 notify 중 지연 생길 수 있음

---

# 2️⃣ 퍼블리셔–서브스크라이버(Pub/Sub) 패턴

## 📌 개념

> 이벤트를 발행(Publish)하는 주체와
> 이벤트를 구독(Subscribe)하는 주체를 **메시지 브로커(Message Broker)가 완전히 분리**하는 패턴.

즉,

* 퍼블리셔는 “누가 듣는지 모름”
* 서브스크라이버는 “누가 보내는지 모름”
* 모두 **브로커(중개 시스템)** 를 통해 통신
  → 완.전.히 느슨한 결합.

---

## 🧩 구조

```
Publisher ---> [Broker] ---> Subscriber
```

Publisher ↔ Subscriber 서로 직접 모름.
∴ 확장성↑, 독립성↑, 분산 시스템에서 매우 중요.

---

## 🐍 Python 예제 (간단 버전)

```python
class Broker:
    def __init__(self):
        self.subscribers = dict()  # topic -> subscriber list

    def subscribe(self, topic, subscriber):
        self.subscribers.setdefault(topic, []).append(subscriber)

    def publish(self, topic, message):
        for sub in self.subscribers.get(topic, []):
            sub.receive(message)


class Subscriber:
    def __init__(self, name):
        self.name = name

    def receive(self, msg):
        print(f"[{self.name}] received: {msg}")


# 사용
broker = Broker()

alice = Subscriber("Alice")
bob = Subscriber("Bob")

broker.subscribe("news", alice)
broker.subscribe("news", bob)

broker.publish("news", "Breaking: AI wins!")  
# [Alice] received: Breaking: AI wins!
# [Bob] received: Breaking: AI wins!
```

실제 서비스에서는
Kafka, RabbitMQ, Redis Pub/Sub, AWS SNS/SQS 같은 **메시지 브로커**가 이를 구현함.

---

## 👍 장점

* 퍼블리셔–서브스크라이버 완전 분리 → 강력한 느슨한 결합
* 서비스 독립적 확장 가능 (마이크로서비스 핵심)
* 비동기 처리 가능
* 메시지 저장/재시도 기능 가능 (Broker에 따라)

## 👎 단점

* 브로커 의존성
* 디버깅 난이도↑ (누가 누구에게 보내는지 명확히 안 보임)
* 메시지가 순서대로 처리되지 않을 수 있음
* 운영 난이도 (Kafka, RabbitMQ 운영 난이도 높음)

---

# 3️⃣ 옵저버 vs Pub/Sub — 차이 정리 (핵심 비교)

| 비교 기준     | 옵저버 패턴                        | Pub/Sub 패턴               |
| --------- | ----------------------------- | ------------------------ |
| **중개자**   | 없음 (Subject ↔ Observer 직접 연결) | 있음 (Broker 필수)           |
| **결합도**   | 낮지만 여전히 직접 참조                 | 매우 낮음(완전 분리)             |
| **통신 방식** | 보통 동기                         | 주로 비동기                   |
| **규모**    | 소규모, 단일 프로세스                  | 대규모, 분산 시스템, MSA         |
| **알림 방식** | 즉시 Notify                     | 메시지 Queue/Topic 기반       |
| **관계**    | 1 → 다                         | 1→N, N→N 가능              |
| **예시**    | GUI 이벤트, 상태 변화 알림             | Kafka 로그 처리, MSA 이벤트 스트림 |

👉 **옵저버 = 객체 간 직접 연결**
👉 **Pub/Sub = 브로커를 통한 완전 분리(대규모 분산용)**

---

# 4️⃣ 언제 어떤 패턴을 쓰나?

## ✔ 옵저버 패턴 적합

* 한 객체의 상태 변화가 다른 객체들에 즉시 반영
* GUI 이벤트 시스템
* 게임 엔진 HUD 업데이트
* 모델-뷰(Model-View) 구조

## ✔ Pub/Sub 패턴 적합

* MSA 이벤트 기반 아키텍처
* 대규모 비동기 처리
* 로그/모니터링 파이프라인
* 알림 시스템(Notification)
* 실시간 데이터 스트림 (Kafka, Kinesis)

---