# 🚦 TCP 흐름 제어 (Flow Control) & 혼잡 제어 (Congestion Control)

> TCP는 **신뢰성 있는 전송(Reliable Transmission)** 을 위해  
> 송신 속도를 조절하는 두 가지 핵심 메커니즘을 사용한다:
> 
> - **흐름 제어 (Flow Control)** → 수신자 관점  
> - **혼잡 제어 (Congestion Control)** → 네트워크 관점

---

## ⚙️ 1️⃣ 흐름 제어 (Flow Control)

> **수신자의 처리 속도에 맞춰 송신 속도를 조절**하는 기법  
> (즉, "너무 빨리 보내서 상대 버퍼가 넘치지 않게!")

---

### 📦 개념
- TCP는 수신 측 버퍼 크기를 기준으로 송신 측의 전송량을 제한  
- 수신자가 감당할 수 있는 만큼만 데이터를 보냄  
- 송신 측은 **ACK 패킷의 윈도우 크기(Window Size)** 필드를 참고

```

[송신자] → 데이터 전송 → [수신자 버퍼] → ACK + Window Size 반환

```

---

### 📊 작동 원리

| 단계 | 동작 | 설명 |
|:--|:--|:--|
| 1️⃣ | 수신자는 자신의 **버퍼 크기(RcvWindow)** 를 TCP 헤더에 포함해 송신자에게 알림 |
| 2️⃣ | 송신자는 RcvWindow 크기만큼만 데이터 전송 |
| 3️⃣ | 수신자가 데이터 처리 후 ACK로 **남은 버퍼 크기**를 갱신 |
| 4️⃣ | 송신자는 새로운 윈도우 크기를 기준으로 전송 지속 |

---

### 🧩 예시
```

수신자 버퍼: 8KB
→ 현재 4KB 사용 중 → RcvWindow = 4KB
→ 송신자는 4KB까지만 추가로 전송 가능

```

---

### 📘 대표 알고리즘 — **Sliding Window Protocol**

> 송신자와 수신자가 동시에 여러 세그먼트를 효율적으로 주고받기 위한 기법

- **Window**: 송신자가 ACK 없이 보낼 수 있는 데이터 범위  
- **ACK 수신 시 윈도우 이동 (Slide)**  
- **Stop-and-Wait보다 훨씬 효율적**

```

[송신자 버퍼] ←----Sliding Window----→ [전송 중 세그먼트]

```

---

### ⚠️ Zero Window & Window Update

- **Zero Window:**  
  수신 버퍼가 가득 차면 수신자가 윈도우 크기 = 0 으로 설정 → 송신 정지  
- **Window Update:**  
  버퍼가 비워지면 수신자가 윈도우 크기를 다시 키워 송신 재개  

> 💡 **TCP Keep-Alive** 메커니즘은 Zero Window 상태에서 연결이 끊겼는지 확인하기 위해 사용됨.

---

## 🌐 2️⃣ 혼잡 제어 (Congestion Control)

> **네트워크 자체의 혼잡을 완화하기 위한 송신 속도 제어 기법**  
> (즉, “너무 많은 호스트가 동시에 데이터를 보내서 네트워크가 막히지 않게!”)

---

### 📦 개념
- 네트워크 혼잡(패킷 손실, 지연, 큐 오버플로)을 감지하면 송신 속도를 줄임  
- TCP는 혼잡 정도를 **패킷 손실(ACK 지연, 타임아웃 등)** 로 간접적으로 판단  
- 송신자는 이를 기반으로 **Congestion Window(cwnd)** 를 동적으로 조절

---

### 📊 주요 변수

| 변수 | 의미 |
|:--|:--|
| **cwnd (Congestion Window)** | 네트워크 상태에 따라 조절되는 송신 윈도우 크기 |
| **ssthresh (Slow Start Threshold)** | 느린 시작과 혼잡 회피를 구분하는 임계값 |
| **RcvWindow** | 수신자 버퍼 기반 흐름 제어용 윈도우 (Flow Control과 구분) |

---

### 🧩 혼잡 제어 4단계 알고리즘

| 단계 | 알고리즘 | 동작 설명 |
|:--:|:--|:--|
| **① 느린 시작 (Slow Start)** | 처음엔 cwnd=1로 시작, ACK 받을 때마다 **지수적 증가** (cwnd *= 2) |
| **② 혼잡 회피 (Congestion Avoidance)** | cwnd ≥ ssthresh → **선형 증가** (cwnd += 1) |
| **③ 빠른 재전송 (Fast Retransmit)** | 중복 ACK 3회 수신 시 손실 감지 → 재전송 수행 (타임아웃 전 복구) |
| **④ 빠른 회복 (Fast Recovery)** | cwnd 반감 후 선형 증가 재개 (ssthresh = cwnd/2) |

---

### 📉 혼잡 제어 동작 예시

```

초기: cwnd=1, ssthresh=16
ACK 수신 → cwnd = 2, 4, 8, 16 (지수 증가)
혼잡 감지(손실 발생) → ssthresh=8, cwnd=8
이후 혼잡 회피 단계 → cwnd 선형 증가 (8 → 9 → 10 ...)

```

> ⚠️ 네트워크가 혼잡하면 cwnd를 줄이고, 안정적이면 천천히 증가시켜 최적 속도를 찾는다.

---

### 📊 시각적 흐름 요약

```

```
   패킷 손실
    ↓
```

cwnd:  1  2  4  8  16  → 지수 증가 (Slow Start)
↓
ssthresh 도달
↓
cwnd:  16 17 18 19...  → 선형 증가 (Congestion Avoidance)
↓
손실 발생 (중복 ACK)
↓
cwnd ↓ (절반 감소) + ssthresh 재설정 → Fast Recovery

```

---

## 🔍 Flow Control vs Congestion Control 비교

| 구분 | 흐름 제어 (Flow Control) | 혼잡 제어 (Congestion Control) |
|:--|:--|:--|
| **관점** | 송·수신 호스트 간 문제 | 네트워크 전체 상태 문제 |
| **목적** | 수신자의 버퍼 오버플로 방지 | 네트워크 혼잡(패킷 손실, 지연) 방지 |
| **기준 변수** | RcvWindow (수신자 버퍼) | cwnd (네트워크 혼잡도 기반) |
| **제어 방식** | 수신자가 송신자에게 윈도우 크기 통보 | 송신자가 네트워크 혼잡을 스스로 판단 |
| **단위 제어** | 연결(세션) 단위 | 전체 네트워크 단위 |
| **대표 알고리즘** | Sliding Window | Slow Start, Congestion Avoidance, Fast Retransmit, Fast Recovery |

---

## ✅ 핵심 요약

| 항목 | 요약 |
|:--|:--|
| **Flow Control** | “수신자 버퍼 기준으로 송신 속도 제어” |
| **Congestion Control** | “네트워크 혼잡도에 따라 송신 속도 제어” |
| **공통점** | 둘 다 **송신량을 조절해 안정적 통신 유지** |
| **차이점** | 제어 대상이 다름 (수신자 vs 네트워크) |
| **결합 동작** | 실제 TCP는 `min(RcvWindow, cwnd)` 값을 기준으로 송신량 결정 |

---

## 📊 통합 개념 그림

```

┌────────────────────────────────────────────┐
│                 TCP 전송 계층              │
├────────────────────────────────────────────┤
│     흐름 제어 (Flow Control)               │ ← 수신자 버퍼 기반 제어 (RcvWindow)
│     혼잡 제어 (Congestion Control)         │ ← 네트워크 상태 기반 제어 (cwnd)
│     전송 윈도우 크기 = min(RcvWindow, cwnd) │
└────────────────────────────────────────────┘

```

---

> ✅ **한줄 요약:**  
> - **흐름 제어**는 “수신자 버퍼가 넘치지 않게!”  
> - **혼잡 제어**는 “네트워크가 막히지 않게!”  
> 두 제어가 동시에 동작하여 TCP의 **신뢰성과 효율성**을 함께 보장한다.
```
