# 📡 분산 데이터베이스(Distributed Database)

> **여러 서버에 분산된 데이터를 하나의 DB처럼 보이게 만드는 기술**

분산 DB의 핵심 철학은 단 하나
👉 “사용자는 분산되어 있다는 사실을 몰라야 한다.”

여기서 투명성(Transparency)이 중요한 이유도 여기에 있다.

---

# 1️⃣ 분산 DB를 사용하는 이유 (Why)

| 목적                           | 설명                   |
| ---------------------------- | -------------------- |
| **확장성 (Scale-out)**          | 서버를 수평 확장해 트래픽 증가 대응 |
| **고가용성 (High Availability)** | 일부 노드 장애에도 서비스 정상 유지 |
| **지연시간 감소 (Low Latency)**    | 지역별 노드를 통한 빠른 응답     |
| **장애 복구 (Fault Tolerance)**  | 복제된 데이터로 복구 가능       |
| **성능 향상 (Performance)**      | 읽기/쓰기 부하 분산          |

---

# 2️⃣ 분산 DB의 8대 투명성 (Transparency)

> 분산 DB는 **분산된 사실을 숨기는 것 자체가 목표**다.

| 투명성                                      | 의미                        |
| ---------------------------------------- | ------------------------- |
| **1. 위치 투명성(Location)**                  | 데이터가 어느 서버에 있는지 알 필요 없음   |
| **2. 복제 투명성(Replication)**               | 복제본 여러 개 → 사용자에게는 1개처럼 보임 |
| **3. 조각화 투명성(Fragmentation / Sharding)** | 데이터가 분할되어도 하나의 테이블처럼 보임   |
| **4. 병행 투명성(Concurrency)**               | 여러 사용자가 동시에 접근해도 정합성 보장   |
| **5. 장애 투명성(Failure)**                   | 일부 노드 장애에도 정상 동작          |
| **6. 성능 투명성(Performance)**               | 분산 구조라도 성능 급락을 느끼지 않게 함   |
| **7. 확장 투명성(Scaling)**                   | 노드 추가/삭제 시 서비스 영향 없음      |
| **8. 이동 투명성(Migration)**                 | 데이터 이동해도 시스템 중단 없이 처리     |

➡ **“투명성이 높을수록 분산 DB 사용 경험이 좋아진다.”**

---

# 3️⃣ 분산 DB의 핵심 구성 요소 3가지

## ① Sharding (수평 분할)

> 데이터를 여러 shard로 나눠 저장해 성능·용량·부하 분산

### Shard 예시

```
Shard 1: user_id 0~999
Shard 2: user_id 1000~1999
Shard 3: user_id 2000~2999
```

### Sharding 방식

* Range Sharding
* Hash Sharding
* Geo Sharding

### 장점

* 병렬 처리
* 저장 용량 확장
* 특정 shard 장애 → 전체 영향 적음

### 단점

* Cross-shard join 복잡
* shard key 설계 난이도 높음

---

## ② Replication (복제)

### ✔ Master–Slave 구조

```
[Master] ← write
  │
  ├→ [Slave1] ← read
  └→ [Slave2] ← read
```

* 읽기 부하 분산
* failover 가능
* replication lag 존재

### ✔ Multi-Master 구조

* 여러 노드 모두 read/write 가능
* 충돌(conflict) 해결 로직 필요

---

## ③ Consistency Model (일관성 수준)

| 모델                       | 설명                | 예시                  |
| ------------------------ | ----------------- | ------------------- |
| **Strong Consistency**   | 모든 노드에서 최신 데이터 보장 | Spanner             |
| **Eventual Consistency** | 결국 동일한 값으로 수렴     | Cassandra, DynamoDB |
| **Weak Consistency**     | 최신 보장 없음          | 초고성능 로그/캐시          |

---

# 4️⃣ CAP 이론 (분산 DB의 기본 이론)

> 네트워크 분할(P)이 발생하면 **C(일관성)** 또는 **A(가용성)** 중 하나를 선택해야 한다.

| 조합     | 설명                      | 예시                  |
| ------ | ----------------------- | ------------------- |
| **CP** | 일관성 + 분할허용 / 가용성 일부 희생  | MongoDB, HBase      |
| **AP** | 가용성 + 분할허용 / 일관성 일부 희생  | Cassandra, DynamoDB |
| **CA** | 일관성 + 가용성 (분산 환경에서는 불가) | 단일 서버 RDB           |

---

# 5️⃣ 분산 트랜잭션 (Strong Consistency를 원할 때)

## ✔ 2PC (Two-Phase Commit)

```
1단계: Prepare — 각 노드 준비 확인
2단계: Commit — 모두 OK면 commit
```

* 강한 일관성
* Coordinator 장애 시 blocking 발생

## ✔ 3PC (Three-Phase Commit)

* 2PC의 blocking 문제 개선
* 네트워크 불안정 환경에서 유리

---

# 6️⃣ 설계 시 고려해야 하는 요소

| 항목          | 선택 포인트                               |
| ----------- | ------------------------------------ |
| Sharding 방식 | Range/Hash/Geo                       |
| 복제 구조       | Master-Slave / Multi-Master          |
| 일관성 수준      | Strong / Eventual / Quorum           |
| 장애 복구       | Failover, Heartbeat, Leader election |
| 위치 전략       | 지역별 분산 배치                            |
| 트랜잭션 전략     | 2PC, 3PC, SAGA                       |

---

# 7️⃣ 대표 분산 DB 비교표

| DB                 | CAP        | 특징                     |
| ------------------ | ---------- | ---------------------- |
| **Cassandra**      | AP         | 빠른 쓰기, 대규모 분산          |
| **DynamoDB**       | AP         | 완전 관리형, 고성능            |
| **MongoDB**        | CP         | 개발 편의성, ReplicaSet     |
| **Google Spanner** | CP(Strong) | 글로벌 strong consistency |
| **TiDB**           | CP         | MySQL 호환 HTAP          |

---