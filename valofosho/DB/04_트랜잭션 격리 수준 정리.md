# 🧱 트랜잭션 격리 수준 (Isolation Level)

트랜잭션의 **ACID 특성 중 “Isolation” (격리성)** 은
**동시에 여러 트랜잭션이 실행될 때, 각 트랜잭션이 서로 간섭하지 않도록 보장**하는 성질입니다.

하지만 완전한 격리를 구현하면 **모든 트랜잭션을 순차적으로 처리해야 하므로 성능 저하**가 발생합니다.
따라서 DBMS는 성능과 일관성의 균형을 위해 **4단계의 격리 수준(Isolation Level)** 을 제공합니다.

---

## 0️⃣ READ UNCOMMITTED (커밋되지 않은 읽기)

* 트랜잭션의 변경 내용이 **COMMIT 또는 ROLLBACK 되기 전에도** 다른 트랜잭션에서 읽을 수 있음
* **정합성이 매우 낮은** 수준으로, **거의 사용되지 않음**
* **DIRTY READ** 발생 가능

> DIRTY READ:
> 다른 트랜잭션이 아직 커밋하지 않은 데이터를 읽는 현상
> 예: 트랜잭션 A가 금액을 5000원으로 변경했지만 ROLLBACK 되면,
> 트랜잭션 B는 존재하지 않는 5000원을 본 것이 됨

📉 **특징**

* 빠르지만 잘못된 데이터를 읽을 수 있음
* 트랜잭션 간 완전한 독립성이 없음

---

## 1️⃣ READ COMMITTED (커밋된 읽기)

* **커밋된 데이터만 읽을 수 있음**
* 대부분의 RDBMS(Oracle, SQL Server)의 **기본 격리 수준**
* **DIRTY READ는 방지되지만, NON-REPEATABLE READ 발생 가능**

> NON-REPEATABLE READ:
> 한 트랜잭션 내에서 같은 SELECT 문을 두 번 실행했을 때 결과가 달라지는 현상
> (다른 트랜잭션이 중간에 데이터를 변경 후 커밋)

📦 **InnoDB 동작 원리**

* **Undo 로그(Undo Segment)** 를 이용해 커밋 이전의 데이터를 백업
* SELECT 시 실제 테이블이 아닌 Undo 영역의 “이전 버전”을 읽음 (MVCC 사용)

---

## 2️⃣ REPEATABLE READ (반복 가능한 읽기)

* 한 트랜잭션이 시작되면, **트랜잭션이 시작된 시점의 스냅샷(View)** 으로 데이터를 읽음
* 트랜잭션 중간에 다른 트랜잭션이 데이터를 수정·커밋해도
  이미 시작된 트랜잭션은 **자신의 스냅샷 기준으로만 읽음**
* MySQL(InnoDB)의 **기본 격리 수준**

> **방지되는 현상:** DIRTY READ, NON-REPEATABLE READ
> **발생 가능한 현상:** PHANTOM READ

> PHANTOM READ:
> 같은 조건으로 SELECT 했을 때,
> **다른 트랜잭션이 새로운 행을 INSERT/DELETE 후 COMMIT하면**
> 새로 나타나거나 사라지는 행(유령 행, phantom row)이 보이는 현상

📦 **InnoDB 동작 원리**

* 트랜잭션마다 고유한 **Transaction ID** 부여
* `trx_id` 보다 작은 ID에서 커밋된 데이터만 읽음
* MVCC(Multi-Version Concurrency Control) 기반으로 구현되어,
  대부분의 PHANTOM READ도 내부적으로 방지됨 (Next-Key Lock 사용)

---

## 3️⃣ SERIALIZABLE (직렬화 가능)

* 가장 **엄격하고 안전한 격리 수준**
* 모든 SELECT 문을 `SELECT ... FOR SHARE` 또는 `LOCK IN SHARE MODE` 처럼 처리
* 데이터 접근 시 **공유 잠금(Shared Lock)** 이 걸려 다른 트랜잭션이 접근 불가
* 완벽한 일관성을 보장하지만 **성능 저하**가 심각함

📉 **특징**

* 트랜잭션 간 완전한 순차 처리 (병렬성 거의 없음)
* Deadlock(교착상태) 발생 가능성이 높음

---

## 🧮 트랜잭션 격리 수준 비교표

| 수준               | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ | 성능       | 일관성      |
| ---------------- | ---------- | ------------------- | ------------ | -------- | -------- |
| READ UNCOMMITTED | ✅ 발생       | ✅ 발생                | ✅ 발생         | 🔥 매우 빠름 | ❌ 매우 낮음  |
| READ COMMITTED   | ❌ 방지       | ✅ 발생                | ✅ 발생         | ⚡ 빠름     | ⚠️ 보통    |
| REPEATABLE READ  | ❌ 방지       | ❌ 방지                | ⚠️ 일부 발생     | ⚖️ 중간    | ✅ 높음     |
| SERIALIZABLE     | ❌ 방지       | ❌ 방지                | ❌ 방지         | 🐢 느림    | 🧱 완전 보장 |

---

## 🧠 트랜잭션 격리 수준 선택 기준

| 사용 상황                            | 권장 수준              |
| -------------------------------- | ------------------ |
| 단순 조회, 실시간 분석 등 정합성보다 성능이 중요한 경우 | READ COMMITTED     |
| 금융, 결제 등 데이터 무결성이 중요한 경우         | REPEATABLE READ 이상 |
| 매우 높은 정확성이 필요한 배치 처리             | SERIALIZABLE       |
| 테스트나 캐시용 조회만 하는 환경               | READ UNCOMMITTED   |

---

## ⚙️ InnoDB의 MVCC (Multi-Version Concurrency Control)

> InnoDB는 트랜잭션 격리를 위해 **잠금(Lock)** 대신
> **데이터 버전 관리(MVCC)** 를 사용합니다.

* 각 행(Row)은 두 개의 숨은 컬럼을 가짐:

  * `trx_id` : 마지막으로 수정한 트랜잭션의 ID
  * `roll_pointer` : Undo 로그의 이전 버전 주소
* 트랜잭션이 실행될 때 자신의 스냅샷 기준으로
  **trx_id < 현재 트랜잭션 ID** 이고 **커밋된 데이터만 읽음**

이 덕분에 **읽기 작업은 Lock 없이 수행**되고,
**읽기와 쓰기의 병행성(Concurrency)** 이 대폭 향상됩니다.

---

## 📊 트랜잭션 격리 수준에 따른 Trade-off

| 방향                       | 일관성 | 동시성 | 설명                 |
| ------------------------ | --- | --- | ------------------ |
| 낮은 수준 (READ UNCOMMITTED) | 낮음  | 높음  | 빠르지만 Dirty Read 위험 |
| 높은 수준 (SERIALIZABLE)     | 높음  | 낮음  | 안전하지만 성능 저하        |

---

## ✅ 요약

| 항목                         | 설명                                             |
| -------------------------- | ---------------------------------------------- |
| **격리 수준(Isolation Level)** | 동시에 실행되는 트랜잭션 간의 간섭 허용 정도                      |
| **핵심 목적**                  | 데이터의 정합성(Consistency)과 병행성(Concurrency)의 균형    |
| **기본값**                    | MySQL: REPEATABLE READ, Oracle: READ COMMITTED |
| **실무 권장 수준**               | READ COMMITTED 또는 REPEATABLE READ              |

---
