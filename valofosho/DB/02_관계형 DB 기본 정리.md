# 🧩 관계형 데이터베이스 (RDB) 기본 정리

> 데이터를 **테이블 형태(행과 열)** 로 저장하고, **관계(Relation)** 를 통해 여러 테이블 간 연결을 표현하는 데이터베이스 모델

---

## 📘 1️⃣ 기본 개념

| 용어                            | 설명                                                 |
| ----------------------------- | -------------------------------------------------- |
| **RDB (Relational Database)** | 관계형 모델에 따라 데이터를 표(Table)로 구성한 DB                   |
| **Table (테이블)**               | 데이터를 행(Row)과 열(Column)로 구성한 구조. 하나의 개체(Entity)에 해당 |
| **Row (행 / 튜플 Tuple)**        | 실제 데이터 한 건 (예: 한 명의 사용자 정보)                        |
| **Column (열 / 속성 Attribute)** | 데이터의 속성 (예: 이름, 나이, 이메일 등)                         |
| **Schema (스키마)**              | 데이터베이스의 구조, 테이블 정의, 제약조건 등을 기술한 설계도                |
| **Record (레코드)**              | 테이블 내의 한 행(Row)과 동일한 개념                            |
| **Field (필드)**                | 행과 열이 교차하는 한 칸의 데이터                                |

---

## 🔑 2️⃣ 키(Key)의 종류

| 키                       | 설명                                      |
| ----------------------- | --------------------------------------- |
| **Primary Key (기본키)**   | 각 행(Row)을 고유하게 식별할 수 있는 키. 중복 ❌, NULL ❌ |
| **Foreign Key (외래키)**   | 다른 테이블의 기본키를 참조하는 키. 테이블 간 관계 형성        |
| **Candidate Key (후보키)** | 기본키가 될 수 있는 후보들의 집합                     |
| **Alternate Key (대체키)** | 후보키 중에서 기본키로 선택되지 않은 나머지 키              |
| **Composite Key (복합키)** | 두 개 이상의 컬럼을 결합하여 유일성을 보장하는 키            |
| **Super Key (슈퍼키)**     | 유일성을 만족하는 속성들의 집합 (최소 조건은 아님)           |

---

## 🔗 3️⃣ 테이블 간 관계 (Relationships)

| 관계 유형         | 설명                           | 예시                      |
| ------------- | ---------------------------- | ----------------------- |
| **1:1 (일대일)** | 한 테이블의 한 행이 다른 테이블의 한 행과만 연결 | 사용자 ↔ 사용자 상세정보          |
| **1:N (일대다)** | 한 행이 다른 테이블의 여러 행과 연결        | 부서 ↔ 직원                 |
| **N:M (다대다)** | 여러 행이 여러 행과 연결 (중간 테이블 필요)   | 학생 ↔ 수강 과목 (수강 테이블로 연결) |

---

## ⚙️ 4️⃣ 무결성(Integrity)

| 구분                                     | 설명                                    |
| -------------------------------------- | ------------------------------------- |
| **개체 무결성(Entity Integrity)**           | 기본키는 NULL이거나 중복될 수 없음                 |
| **참조 무결성(Referential Integrity)**      | 외래키는 참조되는 테이블의 기본키 값과 일치하거나 NULL이어야 함 |
| **도메인 무결성(Domain Integrity)**          | 컬럼의 데이터 타입과 제약조건을 만족해야 함              |
| **사용자 정의 무결성(User-defined Integrity)** | 사용자가 비즈니스 규칙에 따라 정의한 무결성              |

---

## 🧠 5️⃣ 정규화(Normalization)

> 데이터 **중복을 최소화하고** **데이터 무결성을 보장**하기 위한 설계 과정

| 단계                    | 이름                               | 목적 |
| --------------------- | -------------------------------- | -- |
| **1NF (제1정규형)**       | 컬럼이 원자값(Atomic Value)만 가지도록      |    |
| **2NF (제2정규형)**       | 부분 함수 종속 제거 (복합키 일부에만 종속된 컬럼 제거) |    |
| **3NF (제3정규형)**       | 이행적 함수 종속 제거 (비키 → 비키 종속 제거)     |    |
| **BCNF (Boyce-Codd)** | 후보키 간의 종속성 제거                    |    |

📍 *정규화의 반대 개념 → 역정규화(Denormalization): 성능 향상을 위해 일부 중복 허용*

---

## 📊 6️⃣ SQL 기본 구문

| 구문               | 설명        | 예시                                                    |
| ---------------- | --------- | ----------------------------------------------------- |
| **SELECT**       | 데이터 조회    | `SELECT * FROM users;`                                |
| **INSERT**       | 데이터 추가    | `INSERT INTO users (name, age) VALUES ('철수', 25);`    |
| **UPDATE**       | 데이터 수정    | `UPDATE users SET age=26 WHERE name='철수';`            |
| **DELETE**       | 데이터 삭제    | `DELETE FROM users WHERE name='철수';`                  |
| **CREATE TABLE** | 테이블 생성    | `CREATE TABLE users (id INT PRIMARY KEY, name TEXT);` |
| **ALTER TABLE**  | 테이블 구조 변경 | `ALTER TABLE users ADD COLUMN email TEXT;`            |
| **DROP TABLE**   | 테이블 삭제    | `DROP TABLE users;`                                   |

---

## 💾 7️⃣ 트랜잭션 (Transaction)

> 하나의 논리적 작업 단위를 구성하는 명령어 집합
> **모두 수행되거나, 모두 수행되지 않아야 함**

| 속성 (ACID)             | 설명                    |
| --------------------- | --------------------- |
| **Atomicity (원자성)**   | 모두 수행되거나, 전혀 수행되지 않음  |
| **Consistency (일관성)** | 트랜잭션 전후로 데이터 일관성 유지   |
| **Isolation (고립성)**   | 동시에 수행되는 트랜잭션 간 간섭 방지 |
| **Durability (지속성)**  | 커밋된 트랜잭션의 결과는 영구 반영   |

예시:

```sql
BEGIN;
UPDATE accounts SET balance = balance - 1000 WHERE id = 1;
UPDATE accounts SET balance = balance + 1000 WHERE id = 2;
COMMIT;
```

---

## 🚦 8️⃣ 인덱스 (Index)

> 테이블의 검색 속도를 높이기 위한 자료 구조 (보통 B-Tree 구조 사용)

| 장점           | 단점                       |
| ------------ | ------------------------ |
| 조회 속도 향상     | 데이터 변경 시 인덱스도 갱신되어 성능 저하 |
| 정렬, 조인 시 효율적 | 저장 공간 추가 필요              |

```sql
CREATE INDEX idx_name ON users(name);
DROP INDEX idx_name;
```

---

## 📈 9️⃣ 뷰 (View)

> 실제 데이터를 저장하지 않고, **SELECT 쿼리 결과를 가상 테이블 형태로 저장**

```sql
CREATE VIEW active_users AS
SELECT name, email FROM users WHERE is_active = TRUE;
```

---

## 🧮 10️⃣ JOIN의 종류

| JOIN 유형             | 설명                           | 예시                                                  |
| ------------------- | ---------------------------- | --------------------------------------------------- |
| **INNER JOIN**      | 양쪽 테이블 모두 일치하는 행만 반환         | `SELECT * FROM A INNER JOIN B ON A.id = B.id;`      |
| **LEFT JOIN**       | 왼쪽 테이블의 모든 행 + 일치하는 오른쪽 행    | `SELECT * FROM A LEFT JOIN B ON A.id = B.id;`       |
| **RIGHT JOIN**      | 오른쪽 테이블의 모든 행 + 일치하는 왼쪽 행    | `SELECT * FROM A RIGHT JOIN B ON A.id = B.id;`      |
| **FULL OUTER JOIN** | 양쪽 모두 포함 (NULL도 포함)          | `SELECT * FROM A FULL OUTER JOIN B ON A.id = B.id;` |
| **CROSS JOIN**      | 모든 행의 조합 (Cartesian Product) | `SELECT * FROM A CROSS JOIN B;`                     |

---

## 📚 참고 개념

* **ERD(Entity-Relationship Diagram)** : 테이블 간 관계를 시각적으로 표현한 다이어그램
* **Foreign Key Cascade** : 부모 삭제 시 자식 레코드 자동 삭제(`ON DELETE CASCADE`)
* **Stored Procedure / Trigger** : 특정 이벤트 발생 시 자동 실행되는 SQL 코드

---