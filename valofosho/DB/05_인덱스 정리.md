## 🧩 1️⃣ 인덱스(Index)란?

**인덱스(Index)** 는 데이터베이스 테이블의 컬럼 값을 빠르게 조회하기 위해
**정렬된 별도의 자료구조**를 유지하는 기술입니다.

📖 **비유하자면:**
책의 ‘목차’처럼, 인덱스는 **데이터의 위치 정보를 미리 정리**해두어
전체를 처음부터 끝까지 읽지 않고도 빠르게 찾을 수 있게 합니다.

---

## ⚙️ 2️⃣ 인덱스의 동작 원리

대부분의 RDBMS(MySQL, PostgreSQL 등)는
**B-Tree (Balanced Tree)** 구조를 기반으로 인덱스를 구현합니다.

### 🔍 탐색 과정 요약

1. 인덱스는 **키(Key)** 와 **데이터의 위치(pointer)** 를 저장합니다.
2. 검색할 때는 루트 노드부터 **이진 탐색(Binary Search)** 을 수행합니다.
3. 비교를 반복하며 **리프 노드(leaf)** 에 도달하면 실제 데이터의 주소를 참조합니다.

---

## 🌳 3️⃣ B-Tree 구조 개념도

```text
                    [50]
                   /    \
              [20,30]   [60,70,80]
              /   |  \    /   |   \
          [5,10] [25] [35,40] [55] [65,75] [85,90]
```

* **Root Node** : 탐색의 시작점
* **Internal Node** : 중간 경로, 비교를 통해 탐색 방향 결정
* **Leaf Node** : 실제 데이터(레코드의 위치 포인터) 저장

📌 **특징**

* 모든 리프 노드는 같은 깊이를 가짐 (균형 트리)
* 검색, 삽입, 삭제 모두 `O(log N)` 시간복잡도
* 순차 접근이 가능해 `ORDER BY`, `BETWEEN` 쿼리에서도 효율적

---

## 🧮 4️⃣ 인덱스의 종류

| 종류                      | 설명                                   | 예시                  |
| ----------------------- | ------------------------------------ | ------------------- |
| **Primary Index**       | `PRIMARY KEY` 에 자동 생성되는 인덱스          | `PRIMARY KEY(id)`   |
| **Unique Index**        | 중복을 허용하지 않는 인덱스                      | `UNIQUE(email)`     |
| **Non-Unique Index**    | 중복 허용, 일반 검색용                        | `INDEX(name)`       |
| **Composite Index**     | 두 개 이상의 컬럼을 묶음                       | `(name, age)`       |
| **Full-Text Index**     | 텍스트 검색용 인덱스 (MySQL, Elasticsearch 등) | `FULLTEXT(content)` |
| **Clustered Index**     | 실제 데이터가 인덱스 순서대로 정렬                  | InnoDB의 PK          |
| **Non-Clustered Index** | 인덱스와 실제 데이터가 분리 저장                   | MyISAM 등            |

---

## ⚡ 5️⃣ 인덱스의 장단점

**장점**
- 조회 속도 향상 (`O(log N)`)<br>
- ORDER BY, JOIN, GROUP BY 최적화<br>
- 범위 검색 (`BETWEEN`, `LIKE`) 효율적 


**단점**
- `INSERT/UPDATE/DELETE` 시 인덱스 갱신 오버헤드<br>
- 추가 저장공간 필요<br>
- 너무 많은 인덱스는 오히려 성능 저하

---

## 🧭 6️⃣ 인덱스 생성 및 관리

```sql
-- 인덱스 생성
CREATE INDEX idx_name ON users(name);

-- 인덱스 확인
SHOW INDEX FROM users;

-- 인덱스 삭제
DROP INDEX idx_name ON users;
```

---

## 🔎 7️⃣ 인덱스 사용 여부 확인 (MySQL 기준)

```sql
EXPLAIN SELECT * FROM users WHERE name = '동현';
```

| key      | key_len | ref   | rows | Extra                 |
| -------- | ------- | ----- | ---- | --------------------- |
| idx_name | 64      | const | 1    | Using index condition |

> `key` 컬럼에 인덱스명이 나오면 인덱스가 사용되고 있는 것 ✅

---

## 🧠 8️⃣ 인덱스 사용 시 주의사항

| 사용 권장                                               | 사용 비권장                         |
| --------------------------------------------------- | ------------------------------ |
| `WHERE`, `JOIN`, `ORDER BY`, `GROUP BY`에 자주 등장하는 컬럼 | 자주 수정되는 컬럼                     |
| 데이터가 많고 카디널리티(값의 다양성)가 높은 컬럼                        | 값의 종류가 적은 컬럼 (ex. 성별, boolean) |
| 검색 패턴이 일정한 컬럼                                       | LIKE ‘%abc’ 처럼 앞부분이 와일드카드인 검색  |

---

## 🚀 9️⃣ 요약

| 구분      | 설명                                |
| ------- | --------------------------------- |
| **목적**  | 데이터 검색 속도 향상                      |
| **구조**  | B-Tree (Balanced Tree) 기반         |
| **효과**  | `WHERE`, `ORDER BY`, `JOIN` 성능 개선 |
| **주의점** | 인덱스 남발 시 쓰기 성능 저하 및 관리 복잡성 증가     |

---

## 💬 10️⃣ 비유로 정리

| 상황                         | 일반 테이블      | 인덱스 테이블                  |
| -------------------------- | ----------- | ------------------------ |
| 책에서 “인덱스” 단어 찾기            | 처음부터 끝까지 읽기 | 사전의 “ㅇ” 부분 바로 찾기         |
| 데이터베이스에서 `WHERE name='동현'` | 모든 행을 검사    | B-Tree 탐색으로 바로 해당 row 접근 |

---
