# 어댑터, 데코레이터 & 프록시

### 어댑터 패턴 (Adapter Pattern)

---

**정의**

- 기존 클래스의 인터페이스가 현재 요구사항과 맞지 않을 때, **중간 변환기(Wrapper)** 역할을 하는 객체를 두어 호환되도록 만드는 구조 패턴
- 기존 코드를 수정하지 않고도 **새로운 시스템 규격에 맞게 변환**해 재사용할 수 있게 함

**핵심 내용**

1. **역할 및 목적**
    - 인터페이스가 다른 두 객체를 연결해주는 브릿지 역할
    - 외부 라이브러리, 레거시 코드, 기존 시스템을 **수정 없이 통합**할 때 매우 유용
    - "사용자는 기존 클래스를 그대로 쓰고 싶은데 인터페이스가 맞지 않는 상황" 해결
2. **구조**
    - **Target(요구하는 인터페이스)**
    - **Adaptee(원래 객체)**
    - **Adapter(중간 변환기 / Wrapper 객체)**
    - 클라이언트는 Adapter를 Target처럼 사용하지만 내부에서는 Adaptee를 호출
3. **구현 방식**
    - **객체 어댑터 (Composition 기반)**
        - Adaptee 객체를 필드로 보유 → 유연한 확장
    - **클래스 어댑터 (Inheritance 기반)**
        - Adaptee를 상속받아 메서드 변환
        - 다중 상속이 필요한 경우 Java에서는 사용 제한

**특징 및 장단점**

- 장점
    - 기존 코드 변경 없이 재사용 가능
    - 새로운 요구사항이 오더라도 Adapter만 수정하면 되어 유지보수 용이
    - 시스템 간 호환성 향상
- 단점
    - 구조가 깊어지고 코드 흐름이 복잡해질 수 있음
    - Adapter가 너무 많아지면 관리 어려움

### 데코레이터 패턴 (Decorator Pattern)

---

**정의**

- 기존 객체를 감싸며 **기능을 동적으로 확장**할 수 있도록 하는 구조 패턴
- 상속 없이 기능을 확장해야 할 때 가장 유용하며, 다양한 기능 조합이 필요한 상황에서 자주 사용됨

**핵심 내용**

1. **핵심 아이디어**
    - 기능 확장을 위해 상속을 남발하면 클래스가 기하급수적으로 늘어나는 “클래스 폭발 문제” 발생
    - 데코레이터는 객체를 감싸는 형태로 기능을 추가하여 **런타임에 기능을 조합**할 수 있게 함
    - 기능을 추가하는 객체(Decorator)가 기존 객체(Component)와 동일한 인터페이스를 구현
2. **구조**
    - **Component**: 핵심 인터페이스
    - **ConcreteComponent**: 기본 기능 제공
    - **Decorator**: Component 타입을 보유하면서 기능을 포장
    - **ConcreteDecorator**: 구체적인 부가 기능 구현
3. **사용 방식**
    - 객체를 여러 데코레이터로 감싸면 기능이 계층적으로 추가됨
    - 예) 데이터 입출력 시 버퍼링, 압축, 암호화 등을 필요에 따라 조합

**특징 및 장단점**

- 장점
    - 상속 기반보다 훨씬 유연한 확장 가능
    - 기능 조합 자유도 높음
    - 코드 중복 감소
- 단점
    - 데코레이터 중첩 시 디버깅 어려움
    - 호출 체인이 길어져 추적 난이도 증가
    - 구조가 복잡해질 수 있음

### 프록시 패턴 (Proxy Pattern)

---

**정의**

- 실제 객체에 대한 **접근을 제어**하기 위해 대리 객체(Proxy)를 두는 구조 패턴
- 클라이언트는 실제 객체(RealSubject)가 아니라 Proxy를 통해 간접적으로 접근함

**핵심 내용**

1. **핵심 개념**
    - Proxy는 RealSubject와 동일한 인터페이스를 구현
    - 호출 전/후 처리(로깅, 캐싱, 트랜잭션 처리, 접근 제어 등)를 Proxy에서 수행
    - RealSubject는 핵심 로직만 담당하고 부가 기능은 Proxy가 맡음 → 관심사 분리
2. **프록시의 주요 목적**
    - **지연 초기화(Lazy Loading)**: 무거운 객체 생성 비용을 줄임
    - **접근 제어(Security)**
    - **캐싱(Caching)**
    - **로깅/모니터링**
    - **원격 호출(Remote Proxy)** → RMI와 같은 환경에서 사용
3. **프록시 종류**
    - Virtual Proxy
    - Protection Proxy
    - Cache Proxy
    - Logging Proxy
    - Remote Proxy

**특징 및 장단점**

- 장점
    - 성능 최적화 가능
    - 접근 제어·부가 기능 분리가 쉬움
    - 실제 객체의 책임을 최소화할 수 있음
- 단점
    - 설계가 복잡해질 수 있음
    - 여러 Proxy가 중첩되면 흐름 추적 어려움
    - 디버깅 비용 증가

# 관련 면접 질문

- 어댑터 패턴은 언제 필요한가?
    - 기존 코드가 요구하는 인터페이스와 맞지 않을 때, 중간에서 인터페이스를 변환하여 기능을 재사용해야 할 때 사용
- 데코레이터와 상속의 차이점은?
    - 상속은 정적 확장이고 변경 유연성이 낮지만, 데코레이터는 객체를 감싸는 방식으로 기능을 동적으로 확장 가능
- 프록시 패턴의 주요 목적은?
    - 접근 제어, 지연 로딩, 캐싱, 로깅 등 실제 객체 호출 전·후 부가 기능을 수행하여 구조를 분리하기 위해
- 데코레이터와 프록시의 가장 큰 차이는?
    - 데코레이터는 “기능 확장”, 프록시는 “접근 제어/부가 처리”