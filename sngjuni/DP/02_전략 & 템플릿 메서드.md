# 전략 & 템플릿 메서드

## 전략 패턴 (Strategy Pattern)

---

**정의**

- **전략 패턴**은 **알고리즘**을 **클래스로 캡슐화**하고, **동적으로 알고리즘을 교체**할 수 있게 해주는 디자인 패턴
- 클라이언트 코드에서 알고리즘을 **직접 구현**하지 않고, **전략 객체**를 통해 **알고리즘을 바꿀 수 있도록** 함.

---

**핵심 내용**

1. **목적**
    - 알고리즘이 **변경될 가능성**이 있을 때, **알고리즘의 변경을 클라이언트 코드와 분리**시켜 유연하게 처리
    - 예를 들어, **정렬 알고리즘**, **검색 알고리즘**, **결제 방식** 등을 필요에 따라 동적으로 변경 가능
2. **구현 방법**
    - **Context 클래스**: 전략을 선택하고 이를 사용하는 역할
    - **Strategy 인터페이스**: 알고리즘을 정의하는 인터페이스
    - **ConcreteStrategy 클래스**: 알고리즘을 구현하는 클래스
3. **전략 패턴 구성 요소**
    - **Strategy**: 알고리즘을 정의하는 인터페이스
    - **ConcreteStrategy**: 실제 알고리즘을 구현하는 클래스
    - **Context**: 전략 객체를 설정하고 실행하는 클래스

---

**장단점**

- **장점**
    - **알고리즘 교체가 용이**하여 코드의 **유연성** 향상
    - **확장성**이 뛰어나며, 새로운 알고리즘을 추가하는 데 **클라이언트 코드 수정이 필요 없음**
    - 알고리즘을 **캡슐화**하여 코드 중복을 줄이고, **관리 용이**
- **단점**
    - **클래스 개수 증가**: 전략을 위한 인터페이스와 구현체가 필요하여 코드가 다소 복잡해짐
    - **Context와 전략 클래스 간 의존성**이 생길 수 있음

---

**예시 - Spring Boot**

```java
// 전략 인터페이스 정의
public interface PaymentStrategy {
    void pay(int amount);
}

// 구체적인 전략 클래스들
public class CreditCardPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("Paid " + amount + " using Credit Card");
    }
}

public class PayPalPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("Paid " + amount + " using PayPal");
    }
}

// Context 클래스
@Service
public class PaymentService {
    private PaymentStrategy paymentStrategy;

    // 전략을 주입받는 메서드
    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    // 결제 처리
    public void processPayment(int amount) {
        paymentStrategy.pay(amount);
    }
}

```

**설명**

- `PaymentService`는 결제 방식을 **동적으로 변경 가능**
- 클라이언트는 `setPaymentStrategy()` 메서드를 통해 **다양한 결제 전략**(예: **CreditCardPayment**, **PayPalPayment**)을 선택 가능

---

## 템플릿 메서드 패턴 (Template Method Pattern)

---

**정의**

- **템플릿 메서드 패턴**은 **알고리즘의 골격**을 정의하고, **단계별 세부 구현은 서브클래스에 맡기**는 패턴
- **상위 클래스**에서 알고리즘의 **전체 흐름**을 정의하고, **하위 클래스**에서 그 흐름에 맞게 **세부 구현**을 담당

---

**핵심 내용**

1. **목적**
    - 알고리즘의 **일부 단계를 고정**시키고, **유동적인 부분만 서브클래스에서 정의**하여, 코드의 **재사용성**을 높이고, **변경의 유연성**을 제공
    - 주로 **템플릿 메서드**를 사용하는 기본 구조는 **고정된 부분과 변동 가능한 부분**을 구분하는 방식
2. **구현 방법**
    - **템플릿 메서드**: 상위 클래스에서 알고리즘의 **전체 흐름**을 정의하는 메서드
    - **abstract methods**: 서브클래스가 구현해야 하는 메서드들 (세부 구현)
    - **hook methods**: 기본 동작을 제공하지만, 서브클래스에서 오버라이드하여 변경할 수 있는 메서드
3. **템플릿 메서드 패턴 구성 요소**
    - **AbstractClass**: 알고리즘의 **템플릿 메서드**를 정의하고, 일부 단계를 추상 메서드로 선언
    - **ConcreteClass**: 템플릿 메서드를 상속받고, 추상 메서드를 구현하여 알고리즘을 **구체적으로 정의**

---

**장단점**

- **장점**
    - **알고리즘의 구조**는 상위 클래스에서 재사용하고, **세부 구현**만 서브클래스에서 수정 가능
    - **코드 중복**을 방지하고, **일관성**을 유지하면서 유연하게 알고리즘을 변경할 수 있음
- **단점**
    - **상위 클래스의 변경**이 하위 클래스에 영향을 미칠 수 있음
    - **하위 클래스가 템플릿 메서드에 의존**하게 되어, 너무 많은 세부 구현을 하위 클래스에 위임하면 코드가 복잡해질 수 있음

---

**예시 - Spring Boot**

```java
// 추상 클래스: 템플릿 메서드 정의
public abstract class Meal {

    // 템플릿 메서드
    public final void prepareMeal() {
        prepareIngredients();
        cook();
        serve();
    }

    protected abstract void prepareIngredients();  // 재료 준비
    protected abstract void cook();  // 요리 방법
    protected void serve() {  // 서빙은 기본 동작 제공
        System.out.println("Serve the meal.");
    }
}

// 구체적인 클래스: 각자 다른 요리 방법을 구현
public class PastaMeal extends Meal {
    @Override
    protected void prepareIngredients() {
        System.out.println("Prepare pasta, sauce, and vegetables.");
    }

    @Override
    protected void cook() {
        System.out.println("Cook pasta and mix with sauce.");
    }
}

public class SaladMeal extends Meal {
    @Override
    protected void prepareIngredients() {
        System.out.println("Prepare lettuce, tomatoes, and dressing.");
    }

    @Override
    protected void cook() {
        System.out.println("Toss the ingredients together.");
    }
}

```

**설명**

- `Meal`은 알고리즘의 **템플릿**을 정의 (`prepareMeal()` 메서드).
- `PastaMeal`과 `SaladMeal`은 **템플릿 메서드를 상속**받고, 자신만의 **요리 방법**(준비 및 요리)을 **구현**
- `serve()` 메서드는 **기본 구현**을 제공, 서브클래스에서 **변경할 필요 없이** 사용 가능

---

## 관련 면접 질문

- 전략 패턴이란 무엇인가요?
    - 알고리즘을 객체로 캡슐화하고, 동적으로 알고리즘을 변경할 수 있도록 하는 패턴입니다.
- 전략 패턴의 장점은 무엇인가요?
    - 알고리즘을 변경할 때 클라이언트 코드 수정 없이 유연하게 교체할 수 있어 코드의 유연성과 확장성을 제공합니다.
- 템플릿 메서드 패턴이란 무엇인가요?
    - 알고리즘의 골격은 상위 클래스에서 정의하고, 세부 구현은 하위 클래스에서 정의하는 패턴입니다.
- 템플릿 메서드 패턴의 장점은 무엇인가요?
    - 알고리즘의 구조는 상위 클래스에서 재사용하고, 세부 구현만 서브클래스에서 수정할 수 있어 코드의 재사용성을 높입니다.