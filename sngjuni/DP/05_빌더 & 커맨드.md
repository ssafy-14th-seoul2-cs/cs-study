# 빌더 & 커맨드

### 빌더 패턴 (Builder Pattern)

---

**정의**

- 복잡한 객체 생성 과정을 단계별로 분리하여, **가독성 높고 안전한 방식으로 객체를 생성**하는 패턴
- 생성자에 인자가 많아지는 **점층적 생성자(Telescoping Constructor) 문제**를 해결하기 위해 사용됨

**핵심 내용**

1. **사용 목적**
    - 생성자 파라미터가 많고, 선택적 필드가 많을수록 생성 코드가 복잡해짐
    - 빌더를 사용하면 `new` 생성자 대신 **명세서처럼 읽히는 형태**로 객체를 만들 수 있음
    - 필드 누락·타입 오류 등 **생성 시점의 안정성을 보장**
2. **구조**
    - **Builder 클래스**가 객체 생성 책임을 가짐
    - 필드 설정 → `build()` 호출을 통해 최종 객체 반환
    - 클래스 내부 정적 Builder, 외부 Builder, Lombok Builder 등 다양한 형태 가능
3. **특징**
    - 불변 객체(Immutable Object)에 자주 사용
    - 선택적 파라미터가 많은 객체 모델링에 최적
    - 메서드 체이닝 방식으로 가독성 향상
4. **Spring 기반 예시**
    
    (1) **Lombok Builder (실무에서 많이 씀)**
    
    ```java
    @Getter
    @Builder
    public class UserDto {
        private Long id;
        private String email;
        private String name;
    }
    ```
    
    ```java
    UserDto user = UserDto.builder()
        .id(1L)
        .email("test@test.com")
        .name("홍길동")
        .build();
    ```
    
    (2) **Spring Entity + Builder 사용**
    
    ```java
    @Entity
    @Getter
    @NoArgsConstructor(access = AccessLevel.PROTECTED)
    public class Member {
    
        @Id @GeneratedValue
        private Long id;
        private String username;
        private int age;
    
        @Builder
        public Member(String username, int age) {
            this.username = username;
            this.age = age;
        }
    }
    ```
    
    ```java
    Member m = Member.builder()
        .username("jun")
        .age(25)
        .build();
    ```
    

**특징 및 장단점**

- 장점
    - 파라미터 많은 객체 생성 시 가독성↑
    - 필드 누락/순서 오류 방지
    - 불변 객체 생성에 적합
- 단점
    - Builder 클래스 추가로 코드 양 증가
    - 단순한 객체에는 오버엔지니어링 가능

### 커맨드 패턴 (Command Pattern)

---

**정의**

- 수행할 **요청(명령)을 객체로 캡슐화**하여, 실행·취소·저장을 유연하게 처리할 수 있게 하는 패턴
- “명령을 객체로 저장하는 방식”이라고 이해하면 빠름

**핵심 내용**

1. **핵심 개념**
    - 호출자(Invoker)와 실제 수행자(Receiver)를 분리
    - 명령(Command)을 객체로 만들어 전달
    - 명령을 요청·취소·재실행 등 다양한 방식으로 다룰 수 있음
2. **구조**
    - **Command 인터페이스**: `execute()` 제공
    - **ConcreteCommand**: 실제 수행할 명령 구현
    - **Receiver**: 실제 작업을 처리하는 객체
    - **Invoker**: 명령을 받아 실행
3. **사용 사례**
    - Undo/Redo 기능
    - 작업 큐, 로그 기반 재실행
    - 버튼을 클릭했을 때 실행할 행동을 캡슐화하는 GUI 시스템
    - 스케줄러·매크로 기능 구현

**특징 및 장단점**

- 장점
    - 요청을 객체로 저장해 Undo/Redo 가능한 구조 구성
    - 실행자(Receiver)와 호출자(Invoker) 완전 분리
    - 명령을 큐/로그로 다룰 수 있어 확장성↑
- 단점
    - 클래스 수 증가
    - 구조가 과하게 복잡해질 수 있음

# 관련 면접 질문

- 빌더 패턴을 왜 사용하나요?
    - 복잡한 객체 생성 로직을 명확하게 만들고, 파라미터 누락/순서 오류를 방지하며 가독성과 안전성을 높이기 위해 사용
- 빌더 패턴이 생성자보다 좋은 점은?
    - 선택적 매개변수 많은 경우 가독성이 압도적으로 좋고, 실수 가능성이 적음.
- 커맨드 패턴이란?
    - 실행할 요청을 객체로 캡슐화하여 호출자와 실행자를 분리하는 패턴
- 커맨드 패턴은 언제 유용한가?
    - Undo/Redo, 작업 큐, 로그 기반 재실행, 매크로 기능처럼 “명령을 저장·재사용·변경”해야 할 때 적합