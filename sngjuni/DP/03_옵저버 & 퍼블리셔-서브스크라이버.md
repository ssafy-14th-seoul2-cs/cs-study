# 옵저버 & 퍼블리셔-서브스크라이버

## 옵저버 패턴 (Observer Pattern)

---

**정의**

- 하나의 객체(Subject)가 상태 변화가 생기면, 이를 “구독하고 있는” 여러 객체(Observer)에게 **자동으로 알림을 보내는 패턴**
- 객체 간의 **일대다(1:N) 관계**를 정의하고, 객체 간 결합도를 낮추기 위한 패턴

---

**핵심 내용**

1. **구성 요소**
    - **Subject (주제)**: 상태 변화가 발생하는 객체
    - **Observer (옵저버)**: Subject를 구독하며 변화 알림을 받는 객체
    - **등록/해지 메커니즘**: 옵저버를 추가하거나 제거할 수 있는 구조
2. **동작 과정**
    - Observer는 Subject를 ‘구독’한다.
    - Subject 상태가 변하면 `notifyObservers()`를 호출한다.
    - 등록된 Observer 모두에게 알림이 전달된다.
    - Observer는 업데이트된 상태에 따라 동작한다.
3. **사용 사례**
    - GUI 이벤트 리스너
    - 실시간 알림, 채팅 시스템
    - 데이터 변화 감지 후 연쇄 업데이트(예: 주가 변동 알림)

---

**특징**

- 객체 간 결합도를 낮추고, 변화가 생겼을 때 자동으로 연결된 객체들이 업데이트
- 하나의 변경이 여러 객체에게 전파되는 이벤트 기반 구조에 적합

---

**장단점**

- **장점**
    - 객체 간 **낮은 결합도** 유지
    - 확장성 뛰어남 (Observer를 자유롭게 추가/삭제 가능)
    - 이벤트 기반 시스템 구현에 적합
- **단점**
    - Observer가 많으면 **알림 비용 증가**
    - 순환참조나 예상치 못한 업데이트가 일어날 수 있음
    - 디버깅이 비교적 어려움

---

### Java Spring 예시 — ApplicationEventPublisher 활용

Spring에서는 옵저버 패턴을 **이벤트 기반(Application Event)** 구조로 제공한다.

**이벤트 클래스**

```java
public class UserCreatedEvent extends ApplicationEvent {
    private final String userEmail;

    public UserCreatedEvent(Object source, String userEmail) {
        super(source);
        this.userEmail = userEmail;
    }

    public String getUserEmail() {
        return userEmail;
    }
}

```

**이벤트 발행(Publisher)**

```java
@Service
public class UserService {
    private final ApplicationEventPublisher publisher;

    public UserService(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    public void createUser(String email) {
        // 유저 생성 로직...
        publisher.publishEvent(new UserCreatedEvent(this, email));
    }
}

```

**이벤트 구독(Listener)**

```java
@Component
public class WelcomeEmailListener {
    @EventListener
    public void handleUserCreated(UserCreatedEvent event) {
        System.out.println("Send welcome email to " + event.getUserEmail());
    }
}

```

---

## 퍼블리셔–서브스크라이버 패턴 (Publisher–Subscriber Pattern)

---

**정의**

- 메시지를 보내는 객체(Publisher)와 이를 받는 객체(Subscriber)가 서로 직접 참조하지 않고, **중간 브로커(Message Broker)** 를 통해 통신하는 구조
- 옵저버 패턴의 확장 버전으로, **완전한 비동기 / 비결합 구조**를 제공함

---

**핵심 내용**

1. **구성 요소**
    - **Publisher**: 이벤트, 메시지를 발행
    - **Subscriber**: 특정 주제(topic)를 구독하여 메시지 수신
    - **Broker (Message Queue)**: 중개자 역할, Pub/Sub 구조의 핵심
2. **동작 과정**
    - Subscriber는 Topic을 구독
    - Publisher는 특정 Topic에 메시지 발행
    - Broker가 메시지를 관리하고, 해당 Topic을 구독한 Subscriber에게 전달
    - Publisher와 Subscriber는 서로 존재를 알 필요 없음 → **완전한 분리**
3. **사용 사례**
    - Kafka, RabbitMQ, Redis Pub/Sub
    - 알림 시스템, 실시간 스트리밍, 로그 파이프라인
    - 대규모 마이크로서비스 이벤트 전달

---

**특징**

- Publisher–Subscriber 간 결합도 **0에 가깝게 낮음**
- 대규모 분산 시스템에서 메시지 전달과 확장에 유리
- 비동기 처리 기반으로 높은 성능 제공

---

**장단점**

- **장점**
    - 시스템 간 결합도 최소화
    - 대규모 분산 환경에서 확장성 뛰어남
    - 비동기 처리 기반으로 성능 우수
- **단점**
    - 메시지 유실 가능성 (브로커 설정 필요)
    - 시스템 복잡도 증가
    - 디버깅 및 메시지 추적 어려움

---

### Spring Boot 예시 — Redis Pub/Sub

**Publisher**

```java
@Service
public class MessagePublisher {

    private final StringRedisTemplate redisTemplate;

    public MessagePublisher(StringRedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public void publish(String topic, String message) {
        redisTemplate.convertAndSend(topic, message);
    }
}

```

**Subscriber**

```java
@Component
public class MessageSubscriber implements MessageListener {

    @Override
    public void onMessage(Message message, byte[] pattern) {
        System.out.println("Received: " + new String(message.getBody()));
    }
}

```

---

## 관련 면접 질문

- 옵저버 패턴이란 무엇이며 언제 사용하나요?
    - 객체 상태 변화가 다른 객체들에게 자동으로 전파되도록 하는 패턴으로, 이벤트 기반 구조에 적합합니다.
- 옵저버 패턴과 퍼블리셔–서브스크라이버 패턴의 차이는 무엇인가요?
    - 옵저버 패턴은 Subject가 Observer를 직접 참조하지만, Pub/Sub 패턴은 중간 브로커를 통해 완전히 분리된 구조입니다.
- Pub/Sub 패턴의 장점은 무엇인가요?
    - 시스템 결합도를 낮추고, 비동기 메시지 처리와 대규모 확장에 유리합니다.
- Spring Boot에서 옵저버 패턴은 어떻게 구현하나요?
    - `ApplicationEventPublisher`와 `@EventListener`를 사용하여 이벤트 기반 구조를 구현할 수 있습니다.