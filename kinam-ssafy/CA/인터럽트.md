# μΈν„°λ½νΈ(Interrupt) μ™„μ „ μ •λ³µ κ°€μ΄λ“ β΅

## π“– λ©μ°¨
1. [μΈν„°λ½νΈ κΈ°λ³Έ κ°λ…](#μΈν„°λ½νΈ-κΈ°λ³Έ-κ°λ…)
2. [μΈν„°λ½νΈ μΆ…λ¥μ™€ λ¶„λ¥](#μΈν„°λ½νΈ-μΆ…λ¥μ™€-λ¶„λ¥)
3. [μΈν„°λ½νΈ μ²λ¦¬ λ©”μ»¤λ‹μ¦](#μΈν„°λ½νΈ-μ²λ¦¬-λ©”μ»¤λ‹μ¦)
4. [μΈν„°λ½νΈ λ²΅ν„°μ™€ ν…μ΄λΈ”](#μΈν„°λ½νΈ-λ²΅ν„°μ™€-ν…μ΄λΈ”)
5. [μΈν„°λ½νΈ μ°μ„ μμ„ μ‹μ¤ν…](#μΈν„°λ½νΈ-μ°μ„ μμ„-μ‹μ¤ν…)
6. [μΈν„°λ½νΈ μ„λΉ„μ¤ λ£¨ν‹΄(ISR)](#μΈν„°λ½νΈ-μ„λΉ„μ¤-λ£¨ν‹΄isr)
7. [μΈν„°λ½νΈ vs μμ™Έ vs νΈλ©](#μΈν„°λ½νΈ-vs-μμ™Έ-vs-νΈλ©)
8. [ν•λ“μ›¨μ–΄λ³„ μΈν„°λ½νΈ κµ¬ν„](#ν•λ“μ›¨μ–΄λ³„-μΈν„°λ½νΈ-κµ¬ν„)
9. [μΈν„°λ½νΈμ™€ μ‹μ¤ν… μ„±λ¥](#μΈν„°λ½νΈμ™€-μ‹μ¤ν…-μ„±λ¥)
10. [ν„λ€ μ‹μ¤ν…μ μΈν„°λ½νΈ](#ν„λ€-μ‹μ¤ν…μ-μΈν„°λ½νΈ)
11. [μ‹¤μ  μμ‹μ™€ ν”„λ΅κ·Έλλ°](#μ‹¤μ -μμ‹μ™€-ν”„λ΅κ·Έλλ°)
12. [μ¤ν„°λ”” νκ³Ό μ΄μ •λ¦¬](#μ¤ν„°λ””-νκ³Ό-μ΄μ •λ¦¬)

---

## β΅ μΈν„°λ½νΈ κΈ°λ³Έ κ°λ…

### μΈν„°λ½νΈλ€ λ¬΄μ—‡μΈκ°€?

**μΈν„°λ½νΈ(Interrupt)**λ” CPUκ°€ ν„μ¬ μ‹¤ν–‰ μ¤‘μΈ ν”„λ΅κ·Έλ¨μ„ μΌμ‹ μ¤‘λ‹¨ν•κ³ , λ‹¤λ¥Έ κΈ΄κΈ‰ν•κ±°λ‚ μ¤‘μ”ν• μ‘μ—…μ„ μ²λ¦¬ν•κΈ° μ„ν•΄ μ μ–΄κ¶μ„ λ„κΈ°λ” λ©”μ»¤λ‹μ¦μ…λ‹λ‹¤.

```
ν„μ‹¤ λΉ„μ :
λ‹Ήμ‹ μ΄ μ±…μ„ μ½κ³  μλ”λ° (= CPUκ°€ ν”„λ΅κ·Έλ¨ μ‹¤ν–‰)
μ „ν™”λ²¨μ΄ μΈλ¦Ό (= μΈν„°λ½νΈ λ°μƒ)
μ±…κ°ν”Ό λΌμ›λ‘κ³  (= μ»¨ν…μ¤νΈ μ €μ¥)
μ „ν™” λ°›κΈ° (= μΈν„°λ½νΈ μ²λ¦¬)
ν†µν™” λλ‚λ©΄ (= ISR μ™„λ£)
μ±…κ°ν”Ό μ°Ύμ•„μ„ (= μ»¨ν…μ¤νΈ λ³µμ›)
λ‹¤μ‹ μ±… μ½κΈ° (= μ›λ ν”„λ΅κ·Έλ¨ μ¬κ°)
```

### μΈν„°λ½νΈμ ν•µμ‹¬ νΉμ§•

#### 1. **λΉ„λ™κΈ°μ„± (Asynchronous)**
```
- CPUκ°€ μμΈ΅ν•  μ μ—†λ” μ‹μ μ— λ°μƒ
- ν„μ¬ μ‹¤ν–‰ μ¤‘μΈ λ…λ Ήμ–΄μ™€ λ¬΄κ΄€ν•κ² λ°μƒ
- μ™Έλ¶€ μ΄λ²¤νΈμ— μν•΄ νΈλ¦¬κ±°λ¨
```

#### 2. **μ°μ„ μμ„ κΈ°λ° μ²λ¦¬**
```
- κΈ΄κΈ‰λ„μ— λ”°λ¥Έ μ²λ¦¬ μμ„ κ²°μ •
- λ†’μ€ μ°μ„ μμ„ μΈν„°λ½νΈκ°€ λ‚®μ€ μ°μ„ μμ„λ¥Ό μ„ μ  κ°€λ¥
- μ‹μ¤ν… μ•μ •μ„±κ³Ό μ‘λ‹µμ„± λ³΄μ¥
```

#### 3. **μλ™ μ»¨ν…μ¤νΈ λ³΄μ΅΄**
```
- ν•λ“μ›¨μ–΄κ°€ μλ™μΌλ΅ CPU μƒνƒ μ €μ¥
- μΈν„°λ½νΈ μ²λ¦¬ ν›„ μ›λ μƒνƒλ΅ μ™„λ²½ λ³µμ›
- ν¬λ…μ„± λ³΄μ¥ (μ›λ ν”„λ΅κ·Έλ¨μ΄ μΈν„°λ½νΈλ¥Ό λ¨λ¦„)
```

### μΈν„°λ½νΈμ ν•„μ”μ„±κ³Ό μ¥μ 

#### μ™ μΈν„°λ½νΈκ°€ ν•„μ”ν•κ°€?

**1. ν¨μ¨μ„± (Efficiency)**
```
ν΄λ§ λ°©μ‹μ λ¬Έμ :
while (true) {
    if (ν‚¤λ³΄λ“_μ…λ ¥_μμ()) {
        μ²λ¦¬();
    }
    if (λ„¤νΈμ›ν¬_ν¨ν‚·_λ„μ°©()) {
        μ²λ¦¬();
    }
    if (νƒ€μ΄λ¨Έ_λ§λ£()) {
        μ²λ¦¬();
    }
    // CPUκ°€ κ³„μ† ν™•μΈλ§ ν•λ©° λ‚­λΉ„λ¨
}

μΈν„°λ½νΈ λ°©μ‹μ ν•΄κ²°:
- μ΄λ²¤νΈ λ°μƒ μ‹μ—λ§ CPU κ°μ…
- λ‚λ¨Έμ§€ μ‹κ°„μ€ λ‹¤λ¥Έ μ‘μ—… μν–‰ κ°€λ¥
- CPU ν™μ©λ¥  λ€ν­ ν–¥μƒ
```

**2. μ‘λ‹µμ„± (Responsiveness)**
```
μ‹¤μ‹κ°„ μ”κµ¬μ‚¬ν•­:
- ν‚¤λ³΄λ“ μ…λ ¥: 10-100ms λ‚΄ λ°μ‘
- λ§μ°μ¤ μ΄λ™: 1-10ms λ‚΄ λ°μ‘
- λ„¤νΈμ›ν¬ ν¨ν‚·: ΞΌs λ‹¨μ„ λ°μ‘
- ν•λ“μ›¨μ–΄ μ¤λ¥: μ¦‰μ‹ λ°μ‘

μΈν„°λ½νΈ μ—†λ‹¤λ©΄:
- ν΄λ§ μ£ΌκΈ°μ— λ”°λ¥Έ μ§€μ—° λ°μƒ
- μ‹¤μ‹κ°„μ„± λ³΄μ¥ λ¶κ°€λ¥
```

**3. λ©€ν‹°νƒμ¤ν‚Ή μ§€μ›**
```
νƒ€μ΄λ¨Έ μΈν„°λ½νΈμ μ—­ν• :
- μΌμ • μ‹κ°„λ§λ‹¤ λ°μƒ (λ³΄ν†µ 1-10ms)
- ν„μ¬ ν”„λ΅μ„Έμ¤ μ‹¤ν–‰ μ¤‘λ‹¨
- μ¤μΌ€μ¤„λ¬κ°€ λ‹¤μ ν”„λ΅μ„Έμ¤ μ„ νƒ
- μ»¨ν…μ¤νΈ μ¤μ„μΉ­ μν–‰
β†’ μ—¬λ¬ ν”„λ΅κ·Έλ¨μ΄ λ™μ‹ μ‹¤ν–‰λλ” κ²ƒμ²λΌ λ³΄μ„
```

**4. ν•λ“μ›¨μ–΄ μ¶”μƒν™”**
```
- λ³µμ΅ν• ν•λ“μ›¨μ–΄ λ™μ‘μ„ μ†ν”„νΈμ›¨μ–΄κ°€ μ§μ ‘ κ΄€λ¦¬ν•μ§€ μ•μ
- λ””λ°”μ΄μ¤ λ“λΌμ΄λ²„κ°€ μΈν„°λ½νΈ κΈ°λ°μΌλ΅ ν•λ“μ›¨μ–΄ μ μ–΄
- μ‘μ© ν”„λ΅κ·Έλ¨μ€ ν•λ“μ›¨μ–΄ μ„Έλ¶€μ‚¬ν•­ λ°λΌλ„ λ¨
```

---

## π­ μΈν„°λ½νΈ μΆ…λ¥μ™€ λ¶„λ¥

### 1. λ°μƒ μ›μΈμ— λ”°λ¥Έ λ¶„λ¥

#### 1.1 ν•λ“μ›¨μ–΄ μΈν„°λ½νΈ (Hardware Interrupt)

μ™Έλ¶€ ν•λ“μ›¨μ–΄ μ¥μΉμ—μ„ λ°μƒν•λ” μΈν„°λ½νΈ

**μ™Έλ¶€ μΈν„°λ½νΈ (External Interrupt)**
```
μ…λ ¥ μ¥μΉ:
- ν‚¤λ³΄λ“: ν‚¤ λ„λ¦„/λ–ΌκΈ°
- λ§μ°μ¤: μ΄λ™, ν΄λ¦­, μ¤ν¬λ΅¤
- ν„°μΉμ¤ν¬λ¦°: ν„°μΉ, λ©€ν‹°ν„°μΉ
- μ΅°μ΄μ¤ν‹±: λ²„νΌ, λ°©ν–¥ν‚¤

μ„Όμ„λ¥:
- μ¨λ„ μ„Όμ„: μ„κ³„κ°’ μ΄κ³Ό
- κ°€μ†λ„ μ„Όμ„: μ¶©κ²© κ°μ§€
- κ·Όμ ‘ μ„Όμ„: λ¬Όμ²΄ κ°μ§€
```

**I/O μΈν„°λ½νΈ (I/O Interrupt)**
```
μ €μ¥ μ¥μΉ:
- ν•λ“λ””μ¤ν¬: μ½κΈ°/μ“°κΈ° μ™„λ£
- SSD: λ°μ΄ν„° μ „μ†΅ μ™„λ£
- κ΄‘ν•™ λ“λΌμ΄λΈ: λ””μ¤ν¬ μ‚½μ…/μ κ±°

λ„¤νΈμ›ν¬:
- μ΄λ”λ„·: ν¨ν‚· μμ‹ 
- Wi-Fi: μ—°κ²° μƒνƒ λ³€ν™”
- λΈ”λ£¨ν¬μ¤: νμ–΄λ§ μ”μ²­

ν”„λ¦°ν„°/μ¤μΊλ„:
- μ©μ§€ λ¶€μ΅±, μ‰ν¬ λ¶€μ΅±
- μΈμ‡„ μ‘μ—… μ™„λ£
- μ¤μΊ” μ™„λ£
```

**νƒ€μ΄λ¨Έ μΈν„°λ½νΈ (Timer Interrupt)**
```
μ‹μ¤ν… νƒ€μ΄λ¨Έ:
- PIT (Programmable Interval Timer): 18.2Hz
- APIC Timer: κ°€λ³€ μ£Όνμ
- HPET (High Precision Event Timer): κ³ μ •λ°€λ„

μ©λ„:
- ν”„λ΅μ„Έμ¤ μ¤μΌ€μ¤„λ§ (Time slice)
- μ‹μ¤ν… μ‹κ°„ μ—…λ°μ΄νΈ
- νƒ€μ„μ•„μ›ƒ μ²λ¦¬
- μ„±λ¥ λ¨λ‹ν„°λ§
```

#### 1.2 μ†ν”„νΈμ›¨μ–΄ μΈν„°λ½νΈ (Software Interrupt)

μ†ν”„νΈμ›¨μ–΄μ— μν•΄ μλ„μ μΌλ΅ λ°μƒν•λ” μΈν„°λ½νΈ

**μ‹μ¤ν… μ½ (System Call)**
```
νμΌ μ‹μ¤ν…:
- open(), read(), write(), close()
- mkdir(), rmdir(), chmod()

ν”„λ΅μ„Έμ¤ κ΄€λ¦¬:
- fork(), exec(), exit(), wait()
- kill(), getpid(), sleep()

λ„¤νΈμ›ν¬:
- socket(), bind(), listen(), accept()
- send(), recv(), connect()

λ©”λ¨λ¦¬ κ΄€λ¦¬:
- malloc(), free(), mmap(), munmap()
```

**μμ™Έ (Exception)**
```
μ‚°μ  μμ™Έ:
- Division by Zero (0μΌλ΅ λ‚λ„κΈ°)
- Overflow (μ‚°μ  μ¤λ²„ν”λ΅μ°)
- Underflow (μ–Έλ”ν”λ΅μ°)

λ©”λ¨λ¦¬ μμ™Έ:
- Segmentation Fault (μλ»λ λ©”λ¨λ¦¬ μ ‘κ·Ό)
- Page Fault (νμ΄μ§€ λ¶€μ¬)
- Stack Overflow (μ¤νƒ μ¤λ²„ν”λ΅μ°)

λ…λ Ήμ–΄ μμ™Έ:
- Illegal Instruction (μλ»λ λ…λ Ήμ–΄)
- Privilege Violation (κ¶ν• μ„λ°)
- Alignment Error (μ •λ ¬ μ¤λ¥)
```

### 2. λ§μ¤ν‚Ή κ°€λ¥μ„±μ— λ”°λ¥Έ λ¶„λ¥

#### 2.1 λ§μ¤μ»¤λΈ” μΈν„°λ½νΈ (Maskable Interrupt)

μ†ν”„νΈμ›¨μ–΄μ μΌλ΅ λΉ„ν™μ„±ν™”ν•  μ μλ” μΈν„°λ½νΈ

```
νΉμ§•:
- μΈν„°λ½νΈ ν”λκ·Έ(IF)λ΅ μ μ–΄ κ°€λ¥
- CLI λ…λ Ήμ–΄λ΅ λΉ„ν™μ„±ν™”
- STI λ…λ Ήμ–΄λ΅ ν™μ„±ν™”
- κΈ΄κΈ‰ν•μ§€ μ•μ€ μΌλ°μ μΈ μΈν„°λ½νΈ

μμ‹:
- ν‚¤λ³΄λ“, λ§μ°μ¤ μ…λ ¥
- λ„¤νΈμ›ν¬ ν¨ν‚· λ„μ°©
- νƒ€μ΄λ¨Έ μΈν„°λ½νΈ
- λ””μ¤ν¬ I/O μ™„λ£
```

#### 2.2 λ…Όλ§μ¤μ»¤λΈ” μΈν„°λ½νΈ (Non-Maskable Interrupt, NMI)

μ λ€ λΉ„ν™μ„±ν™”ν•  μ μ—†λ” μµκ³  μ°μ„ μμ„ μΈν„°λ½νΈ

```
νΉμ§•:
- μ†ν”„νΈμ›¨μ–΄λ΅ λΉ„ν™μ„±ν™” λ¶κ°€λ¥
- μ‹μ¤ν… μ•μ •μ„±κ³Ό μ§κ²°
- μ¦‰μ‹ μ²λ¦¬ν•΄μ•Ό ν•λ” μΉλ…μ  μƒν™©

μμ‹:
- λ©”λ¨λ¦¬ ν¨λ¦¬ν‹° μ¤λ¥
- λ²„μ¤ μ¤λ¥
- μ „μ› κ³µκΈ‰ μ΄μƒ
- ν•λ“μ›¨μ–΄ κ³ μ¥
- μ‹μ¤ν… λ¦¬μ…‹ λ²„νΌ
- Watchdog νƒ€μ΄λ¨Έ λ§λ£
```

### 3. μ°μ„ μμ„μ— λ”°λ¥Έ λ¶„λ¥

```
μ°μ„ μμ„ (λ†’μ β†’ λ‚®μ):

1. ν•λ“μ›¨μ–΄ λ¦¬μ…‹ (μµκ³  μ°μ„ μμ„)
   - μ „μ› λ¦¬μ…‹, μ‹μ¤ν… λ¦¬μ…‹

2. λ…Όλ§μ¤μ»¤λΈ” μΈν„°λ½νΈ (NMI)
   - ν¨λ¦¬ν‹° μ¤λ¥, λ²„μ¤ μ¤λ¥

3. λ§μ¤μ»¤λΈ” ν•λ“μ›¨μ–΄ μΈν„°λ½νΈ
   Level 0: νƒ€μ΄λ¨Έ (IRQ 0)
   Level 1: ν‚¤λ³΄λ“ (IRQ 1)
   Level 2: Cascade (IRQ 2)
   Level 3: COM2 (IRQ 3)
   Level 4: COM1 (IRQ 4)
   Level 5: LPT2 (IRQ 5)
   Level 6: ν”λ΅ν”Ό λ””μ¤ν¬ (IRQ 6)
   Level 7: LPT1 (IRQ 7)
   Level 8: μ‹¤μ‹κ°„ μ‹κ³„ (IRQ 8)
   ...
   Level 15: λ³΄μ΅° IDE (IRQ 15)

4. μ†ν”„νΈμ›¨μ–΄ μΈν„°λ½νΈ (μµμ € μ°μ„ μμ„)
   - μ‹μ¤ν… μ½, μμ™Έ
```

---

## π”„ μΈν„°λ½νΈ μ²λ¦¬ λ©”μ»¤λ‹μ¦

### μΈν„°λ½νΈ λ°μƒλ¶€ν„° μ²λ¦¬κΉμ§€μ μ „μ²΄ κ³Όμ •

```
[1] μΈν„°λ½νΈ λ°μƒ
     β†“
[2] μΈν„°λ½νΈ μ‹ νΈ κ²€μ‚¬
     β†“
[3] ν„μ¬ λ…λ Ήμ–΄ μ™„λ£
     β†“
[4] μΈν„°λ½νΈ μΉμΈ (INTA)
     β†“
[5] μ»¨ν…μ¤νΈ μ €μ¥
     β†“
[6] μΈν„°λ½νΈ λ²΅ν„° ν™•μΈ
     β†“
[7] ISR μ£Όμ† νλ“
     β†“
[8] ISR μ‹¤ν–‰
     β†“
[9] μ»¨ν…μ¤νΈ λ³µμ›
     β†“
[10] μ›λ ν”„λ΅κ·Έλ¨ μ¬κ°
```

### λ‹¨κ³„λ³„ μƒμ„Έ λ¶„μ„

#### 1λ‹¨κ³„: μΈν„°λ½νΈ λ°μƒ (Interrupt Request)

**ν•λ“μ›¨μ–΄μ  μ‹ νΈ μƒμ„±**
```
μΈν„°λ½νΈ μ‹ νΈμ„ :
- IRQ (Interrupt Request) λΌμΈ
- μ „κΈ°μ  μ‹ νΈ: LOW β†’ HIGH λλ” HIGH β†’ LOW
- μ§€μ† μ‹κ°„: μ λ‚λ…Έμ΄ ~ μ λ§μ΄ν¬λ΅μ΄

μ‹ νΈ λ°©μ‹:
- μ—£μ§€ νΈλ¦¬κ±° (Edge-triggered): μ‹ νΈ λ³€ν™” μκ°„ κ°μ§€
- λ λ²¨ νΈλ¦¬κ±° (Level-triggered): μ‹ νΈ λ λ²¨ μ μ§€ μ‹ κ°μ§€
```

#### 2λ‹¨κ³„: μΈν„°λ½νΈ μ‹ νΈ κ²€μ‚¬ (Interrupt Polling)

**CPUμ μΈν„°λ½νΈ κ²€μ‚¬ μ‹μ **
```
κ²€μ‚¬ μ‹μ :
1. κ° λ…λ Ήμ–΄ μ‹¤ν–‰ μ™„λ£ ν›„
2. μΈν„°λ½νΈκ°€ ν™μ„±ν™”λ μƒνƒμ—μ„λ§
3. ν„μ¬ μ‹¤ν–‰ μ¤‘μΈ μΈν„°λ½νΈλ³΄λ‹¤ λ†’μ€ μ°μ„ μμ„μΈ κ²½μ°λ§

κ²€μ‚¬ μ΅°κ±΄:
- μΈν„°λ½νΈ ν”λκ·Έ (IF) = 1
- ν„μ¬ μ°μ„ μμ„ < μ”μ²­λ μΈν„°λ½νΈ μ°μ„ μμ„
- ν•΄λ‹Ή μΈν„°λ½νΈκ°€ λ§μ¤ν‚Ήλμ§€ μ•μ
```

#### 3λ‹¨κ³„: ν„μ¬ λ…λ Ήμ–΄ μ™„λ£ (Instruction Completion)

**μ›μμ„± λ³΄μ¥**
```
μ™„λ£ν•΄μ•Ό ν•λ” μ΄μ :
- λ…λ Ήμ–΄μ μ›μμ„± λ³΄μ¥
- μ¤‘κ°„ μƒνƒλ΅ μΈν• λ°μ΄ν„° λ¬΄κ²°μ„± λ¬Έμ  λ°©μ§€
- λ³µμ› μ‹ μΌκ΄€λ μƒνƒ μ μ§€

μμ™Έ μƒν™©:
- λ§¤μ° κΈ΄ λ…λ Ήμ–΄ (λ¬Έμμ—΄ μ²λ¦¬ λ“±)
- μΈν„°λ½νΈ κ°€λ¥ν• λ…λ Ήμ–΄ (REP μ ‘λ‘μ‚¬)
- νΉλ³„ν• μ²λ¦¬ λ°©μ‹ ν•„μ”
```

#### 4λ‹¨κ³„: μΈν„°λ½νΈ μΉμΈ (Interrupt Acknowledge)

**CPUμ™€ μΈν„°λ½νΈ μ»¨νΈλ΅¤λ¬ κ°„ ν†µμ‹ **
```
INTA (Interrupt Acknowledge) μ‹ νΈ:
1. CPUκ°€ INTA# μ‹ νΈ ν™μ„±ν™”
2. μΈν„°λ½νΈ μ»¨νΈλ΅¤λ¬κ°€ λ²΅ν„° λ²νΈ μ „μ†΅
3. λ°μ΄ν„° λ²„μ¤λ¥Ό ν†µν•΄ 8λΉ„νΈ λ²΅ν„° λ²νΈ μ „λ‹¬
4. CPUκ°€ λ²΅ν„° λ²νΈ μμ‹  ν™•μΈ
```

#### 5λ‹¨κ³„: μ»¨ν…μ¤νΈ μ €μ¥ (Context Saving)

**μλ™ μ €μ¥ (ν•λ“μ›¨μ–΄)**
```
x86 μ•„ν‚¤ν…μ² μλ™ μ €μ¥ ν•­λ©:
1. EFLAGS λ μ§€μ¤ν„° β†’ μ¤νƒ
2. CS (Code Segment) β†’ μ¤νƒ  
3. EIP (Instruction Pointer) β†’ μ¤νƒ

64λΉ„νΈ λ¨λ“ (x86-64):
1. RFLAGS β†’ μ¤νƒ
2. CS β†’ μ¤νƒ
3. RIP β†’ μ¤νƒ

μ¤νƒ μƒνƒ λ³€ν™”:
ESP-12: [EFLAGS]
ESP-8:  [CS]
ESP-4:  [EIP]
ESP:    β† ν„μ¬ μ¤νƒ ν¬μΈν„°
```

**μλ™ μ €μ¥ (μ†ν”„νΈμ›¨μ–΄/ISR)**
```
ISRμ—μ„ μ¶”κ°€ μ €μ¥ν•΄μ•Ό ν•  ν•­λ©:
- λ²”μ© λ μ§€μ¤ν„° (EAX, EBX, ECX, EDX, ...)
- μΈλ±μ¤ λ μ§€μ¤ν„° (ESI, EDI)
- λ² μ΄μ¤ ν¬μΈν„° (EBP)
- μ„Έκ·Έλ¨ΌνΈ λ μ§€μ¤ν„° (DS, ES, FS, GS)
- κΈ°νƒ€ μƒνƒ λ μ§€μ¤ν„°

μ €μ¥ μμ„ (PUSHA λ…λ Ήμ–΄):
PUSH EAX
PUSH ECX  
PUSH EDX
PUSH EBX
PUSH ESP (μ›λ κ°’)
PUSH EBP
PUSH ESI
PUSH EDI
```

#### 6-7λ‹¨κ³„: μΈν„°λ½νΈ λ²΅ν„° μ²λ¦¬

**λ²΅ν„° ν…μ΄λΈ” μ°Έμ΅°**
```
κ³Όμ •:
1. μΈν„°λ½νΈ λ²΅ν„° λ²νΈ νλ“ (0-255)
2. λ²΅ν„° ν…μ΄λΈ” κΈ°μ¤€ μ£Όμ† (IDTR) ν™•μΈ
3. λ²΅ν„° λ²νΈ Γ— 8 λ°”μ΄νΈ = μ¤ν”„μ…‹ κ³„μ‚°
4. IDTR + μ¤ν”„μ…‹ = λ””μ¤ν¬λ¦½ν„° μ£Όμ†
5. λ””μ¤ν¬λ¦½ν„°μ—μ„ ISR μ£Όμ† μ¶”μ¶
```

#### 8λ‹¨κ³„: ISR μ‹¤ν–‰

**μΈν„°λ½νΈ μ„λΉ„μ¤ λ£¨ν‹΄ μ²λ¦¬**
```
ISRμ κΈ°λ³Έ κµ¬μ΅°:
1. μ§„μ… μ‹ μ¶”κ°€ λ μ§€μ¤ν„° μ €μ¥
2. μΈν„°λ½νΈ μ»¨νΈλ΅¤λ¬μ— EOI μ‹ νΈ μ „μ†΅
3. μ‹¤μ  μΈν„°λ½νΈ μ²λ¦¬ μ½”λ“ μ‹¤ν–‰
4. ν•„μ”μ‹ μ¤μΌ€μ¤„λ§ κ²°μ •
5. μ €μ¥λ λ μ§€μ¤ν„° λ³µμ›
6. IRET λ…λ Ήμ–΄λ΅ λ³µκ·€
```

#### 9-10λ‹¨κ³„: λ³µμ› λ° μ¬κ°

**μ»¨ν…μ¤νΈ λ³µμ› (Context Restoration)**
```
λ³µμ› μμ„ (μ €μ¥μ μ—­μ):
1. ISRμ—μ„ μλ™ μ €μ¥ν• λ μ§€μ¤ν„°λ“¤ λ³µμ›
2. IRET λ…λ Ήμ–΄ μ‹¤ν–‰:
   - EIP β† μ¤νƒμ—μ„ ν
   - CS β† μ¤νƒμ—μ„ ν
   - EFLAGS β† μ¤νƒμ—μ„ ν
3. μ›λ ν”„λ΅κ·Έλ¨μ λ‹¤μ λ…λ Ήμ–΄λ¶€ν„° μ‹¤ν–‰ μ¬κ°
```

### μΈν„°λ½νΈ μ²λ¦¬ μ‹κ°„ λ¶„μ„

```
μ΄ μΈν„°λ½νΈ μ²λ¦¬ μ‹κ°„ = μ§€μ—°μ‹κ°„ + μ²λ¦¬μ‹κ°„ + λ³µμ›μ‹κ°„

μ§€μ—°μ‹κ°„ (Latency):
- μΈν„°λ½νΈ λ°μƒ β†’ μΈμ‹: 1-2 ν΄λ΅
- ν„μ¬ λ…λ Ήμ–΄ μ™„λ£: 1-20 ν΄λ΅
- μ»¨ν…μ¤νΈ μ €μ¥: 10-50 ν΄λ΅
μ΄ μ§€μ—°μ‹κ°„: 12-72 ν΄λ΅ (μ λ§μ΄ν¬λ΅μ΄)

μ²λ¦¬μ‹κ°„:
- μ‹¤μ  ISR μ‹¤ν–‰ μ‹κ°„
- μμ‹­ ~ μμ² ν΄λ΅ (μ©λ„μ— λ”°λΌ)

λ³µμ›μ‹κ°„:
- μ»¨ν…μ¤νΈ λ³µμ›: 10-50 ν΄λ΅
- IRET μ‹¤ν–‰: 2-5 ν΄λ΅
μ΄ λ³µμ›μ‹κ°„: 12-55 ν΄λ΅
```

---

## π—‚οΈ μΈν„°λ½νΈ λ²΅ν„°μ™€ ν…μ΄λΈ”

### μΈν„°λ½νΈ λ²΅ν„°μ κ°λ…

**μΈν„°λ½νΈ λ²΅ν„° (Interrupt Vector)**
```
μ •μ: νΉμ • μΈν„°λ½νΈμ— λ€μ‘ν•λ” ISRμ μ£Όμ† μ •λ³΄
ν¬κΈ°: μ•„ν‚¤ν…μ²μ— λ”°λΌ λ‹¤λ¦„ (x86: 8λ°”μ΄νΈ, ARM: 4λ°”μ΄νΈ)
λ²νΈ: 0-255 (x86 κΈ°μ¤€, μ΄ 256κ°)
```

**λ²΅ν„° λ²νΈμ μλ―Έ**
```
λ²΅ν„° λ²νΈ    μλ―Έ                μμ‹
0           Division by Zero    λ‚λ„κΈ° 0 μ¤λ¥
1           Debug              λ””λ²„κ·Έ νΈλ©  
2           NMI                λ…Όλ§μ¤μ»¤λΈ” μΈν„°λ½νΈ
3           Breakpoint         λΈλ μ΄ν¬ν¬μΈνΈ
4           Overflow           μ‚°μ  μ¤λ²„ν”λ΅μ°
5           Bound Range        λ²”μ„ μ΄κ³Ό
6           Invalid Opcode     μλ»λ λ…λ Ήμ–΄
7           Device Not Available FPU μ—†μ
8           Double Fault       μ΄μ¤‘ μ¤λ¥
9           Coprocessor        λ³΄μ΅°ν”„λ΅μ„Έμ„ μ¤λ¥
10          Invalid TSS        μλ»λ TSS
11          Segment Not Present μ„Έκ·Έλ¨ΌνΈ λ¶€μ¬
12          Stack Fault        μ¤νƒ μ¤λ¥
13          General Protection μΌλ° λ³΄νΈ μ¤λ¥
14          Page Fault         νμ΄μ§€ μ¤λ¥
15          Reserved           μμ•½λ¨
16          FPU Error         λ¶€λ™μ†μμ  μ¤λ¥
17          Alignment Check    μ •λ ¬ κ²€μ‚¬
18          Machine Check      λ¨Έμ‹  μ²΄ν¬
19          SIMD Exception     SIMD μμ™Έ
20-31       Reserved           μμ•½λ¨
32-255      User Defined       μ‚¬μ©μ μ •μ/ν•λ“μ›¨μ–΄
```

### μΈν„°λ½νΈ λ””μ¤ν¬λ¦½ν„° ν…μ΄λΈ” (IDT)

#### x86 μ•„ν‚¤ν…μ²μ IDT κµ¬μ΅°

**IDT λ μ§€μ¤ν„° (IDTR)**
```
κµ¬μ΅° (10λ°”μ΄νΈ):
- Limit (16λΉ„νΈ): IDT ν¬κΈ° - 1
- Base (32λΉ„νΈ/64λΉ„νΈ): IDT μ‹μ‘ μ£Όμ†

μ„¤μ • λ…λ Ήμ–΄:
LIDT [IDT_descriptor]  ; IDT λ΅λ“
SIDT [memory]          ; ν„μ¬ IDT μ •λ³΄ μ €μ¥
```

**κ²μ΄νΈ λ””μ¤ν¬λ¦½ν„° κµ¬μ΅°**
```
8λ°”μ΄νΈ κ²μ΄νΈ λ””μ¤ν¬λ¦½ν„°:

31                16 15  14 13  12    8 7   5 4   0
+------------------+---+---+---+------+-----+-----+
|   Offset 31-16   | P |DPL| 0 | Type | 000 | 000 | +4
+------------------+---+---+---+------+-----+-----+
|     Selector     |         Offset 15-0          | +0  
+------------------+-------------------------------+

ν•„λ“ μ„¤λ…:
- Offset: ISR μ£Όμ† (16λΉ„νΈμ”© λ¶„ν•  μ €μ¥)
- Selector: μ½”λ“ μ„Έκ·Έλ¨ΌνΈ μ„ νƒμ
- Type: κ²μ΄νΈ νƒ€μ… (μΈν„°λ½νΈ/νΈλ©/νƒμ¤ν¬)
- DPL: λ””μ¤ν¬λ¦½ν„° νΉκ¶ λ λ²¨
- P: Present λΉ„νΈ (μ ν¨/λ¬΄ν¨)
```

**κ²μ΄νΈ νƒ€μ…**
```
νƒ€μ… μ½”λ“    κ²μ΄νΈ μΆ…λ¥            νΉμ§•
0x5         32λΉ„νΈ νƒμ¤ν¬ κ²μ΄νΈ    νƒμ¤ν¬ μ¤μ„μΉ­
0x6         16λΉ„νΈ μΈν„°λ½νΈ κ²μ΄νΈ  IF ν΄λ¦¬μ–΄
0x7         16λΉ„νΈ νΈλ© κ²μ΄νΈ      IF μ μ§€
0xE         32λΉ„νΈ μΈν„°λ½νΈ κ²μ΄νΈ  IF ν΄λ¦¬μ–΄  
0xF         32λΉ„νΈ νΈλ© κ²μ΄νΈ      IF μ μ§€
```

#### IDT μ΄κΈ°ν™” κ³Όμ •

**λ¶€νΈ λ‹¨κ³„μ—μ„ IDT μ„¤μ •**
```assembly
; IDT λ””μ¤ν¬λ¦½ν„° κµ¬μ΅°μ²΄
idt_descriptor:
    dw idt_end - idt_start - 1  ; IDT ν¬κΈ°
    dd idt_start                ; IDT μ‹μ‘ μ£Όμ†

; IDT ν…μ΄λΈ” μμ—­
idt_start:
    times 256 dq 0              ; 256κ° μ—”νΈλ¦¬, 8λ°”μ΄νΈμ”©

; IDT λ΅λ“
setup_idt:
    lidt [idt_descriptor]       ; IDT λ μ§€μ¤ν„° μ„¤μ •
    ret
```

**κ°λ³„ μΈν„°λ½νΈ λ²΅ν„° μ„¤μ •**
```c
// C μ½”λ“λ΅ IDT μ—”νΈλ¦¬ μ„¤μ •
void set_idt_entry(int vector, uint32_t handler, uint16_t selector, uint8_t flags) {
    idt[vector].offset_low = handler & 0xFFFF;
    idt[vector].offset_high = (handler >> 16) & 0xFFFF;
    idt[vector].selector = selector;
    idt[vector].flags = flags;
    idt[vector].reserved = 0;
}

// μ‚¬μ© μμ‹
set_idt_entry(0, (uint32_t)divide_by_zero_handler, 0x08, 0x8E);
set_idt_entry(1, (uint32_t)debug_handler, 0x08, 0x8E);
set_idt_entry(32, (uint32_t)timer_handler, 0x08, 0x8E);
```

### λ‹¤λ¥Έ μ•„ν‚¤ν…μ²μ λ²΅ν„° ν…μ΄λΈ”

#### ARM μ•„ν‚¤ν…μ² λ²΅ν„° ν…μ΄λΈ”

**ARM μμ™Έ λ²΅ν„° ν…μ΄λΈ”**
```
μ£Όμ†        μμ™Έ νƒ€μ…                μ„¤λ…
0x00000000  Reset                   λ¦¬μ…‹
0x00000004  Undefined Instruction   μ •μλμ§€ μ•μ€ λ…λ Ήμ–΄
0x00000008  Software Interrupt      μ†ν”„νΈμ›¨μ–΄ μΈν„°λ½νΈ
0x0000000C  Prefetch Abort          λ…λ Ήμ–΄ ν”„λ¦¬νμΉ μ¤λ¥
0x00000010  Data Abort              λ°μ΄ν„° μ ‘κ·Ό μ¤λ¥
0x00000014  Reserved                μμ•½λ¨
0x00000018  IRQ                     μΌλ° μΈν„°λ½νΈ
0x0000001C  FIQ                     λΉ λ¥Έ μΈν„°λ½νΈ
```

**ARM λ²΅ν„° ν…μ΄λΈ” νΉμ§•**
```
- κ³ μ • μ„μΉ: λ³΄ν†µ 0x00000000 λλ” 0xFFFF0000
- κ°„λ‹¨ν• κµ¬μ΅°: κ° λ²΅ν„° 4λ°”μ΄νΈ
- μ§μ ‘ μ ν”„: λ²΅ν„° μ„μΉμ— λ¶„κΈ° λ…λ Ήμ–΄ μ €μ¥
- λΉ λ¥Έ μ²λ¦¬: ν…μ΄λΈ” μ°Έμ΅° μ—†μ΄ μ§μ ‘ μ‹¤ν–‰
```

#### RISC-V μΈν„°λ½νΈ λ²΅ν„°

**RISC-V νΈλ© λ²΅ν„°**
```
CSR λ μ§€μ¤ν„°:
- mtvec: λ¨Έμ‹  λ¨λ“ νΈλ© λ²΅ν„° κΈ°μ¤€ μ£Όμ†
- stvec: μνΌλ°”μ΄μ € λ¨λ“ νΈλ© λ²΅ν„° κΈ°μ¤€ μ£Όμ†
- utvec: μ μ € λ¨λ“ νΈλ© λ²΅ν„° κΈ°μ¤€ μ£Όμ†

λ¨λ“:
- Direct: λ¨λ“  νΈλ©μ΄ κΈ°μ¤€ μ£Όμ†λ΅ μ ν”„
- Vectored: μΈν„°λ½νΈλ” κΈ°μ¤€ μ£Όμ† + 4Γ—causeλ΅ μ ν”„
```

---

## π† μΈν„°λ½νΈ μ°μ„ μμ„ μ‹μ¤ν…

### μ°μ„ μμ„μ ν•„μ”μ„±

**λ™μ‹ μΈν„°λ½νΈ λ°μƒ μƒν™©**
```
μ‹λ‚λ¦¬μ¤:
- ν‚¤λ³΄λ“ μ…λ ¥ μΈν„°λ½νΈ μ²λ¦¬ μ¤‘
- λ„¤νΈμ›ν¬ ν¨ν‚· λ„μ°© μΈν„°λ½νΈ λ°μƒ
- λ™μ‹μ— νƒ€μ΄λ¨Έ μΈν„°λ½νΈλ„ λ°μƒ

λ¬Έμ :
- μ–΄λ–¤ μΈν„°λ½νΈλ¥Ό λ¨Όμ € μ²λ¦¬ν•  κ²ƒμΈκ°€?
- ν„μ¬ μ²λ¦¬ μ¤‘μΈ μΈν„°λ½νΈλ¥Ό μ¤‘λ‹¨ν•΄μ•Ό ν•λ”κ°€?
- μ‹μ¤ν… μ•μ •μ„±κ³Ό μ„±λ¥μ„ μ–΄λ–»κ² λ³΄μ¥ν•  κ²ƒμΈκ°€?
```

### μ°μ„ μμ„ κΈ°λ° μΈν„°λ½νΈ μ²λ¦¬

#### μΈν„°λ½νΈ μ°μ„ μμ„ λ λ²¨ (IPL)

**Intel 8259A PIC μ°μ„ μμ„**
```
IRQ λ²νΈ    μ°μ„ μμ„    μΌλ°μ  μ©λ„              μ¥μΉ μμ‹
IRQ 0       μµκ³         μ‹μ¤ν… νƒ€μ΄λ¨Έ           PIT (8254)
IRQ 1       2          ν‚¤λ³΄λ“                  ν‚¤λ³΄λ“ μ»¨νΈλ΅¤λ¬
IRQ 2       3          Cascade (μ—°κ²°μ©)        λ³΄μ΅° PIC
IRQ 3       4          μ‹λ¦¬μ–Ό ν¬νΈ 2           COM2
IRQ 4       5          μ‹λ¦¬μ–Ό ν¬νΈ 1           COM1  
IRQ 5       6          λ³‘λ ¬ ν¬νΈ 2             LPT2
IRQ 6       7          ν”λ΅ν”Ό λ””μ¤ν¬           FDD
IRQ 7       8          λ³‘λ ¬ ν¬νΈ 1             LPT1
IRQ 8       9          μ‹¤μ‹κ°„ μ‹κ³„             RTC
IRQ 9       10         μ‚¬μ© κ°€λ¥               λ„¤νΈμ›ν¬, μ‚¬μ΄λ“
IRQ 10      11         μ‚¬μ© κ°€λ¥               USB, SCSI
IRQ 11      12         μ‚¬μ© κ°€λ¥               USB, SCSI
IRQ 12      13         PS/2 λ§μ°μ¤             λ§μ°μ¤
IRQ 13      14         μμΉ μ—°μ‚° ν”„λ΅μ„Έμ„      FPU
IRQ 14      15         μ£Ό IDE μ±„λ„             ν•λ“λ””μ¤ν¬
IRQ 15      μµμ €        λ³΄μ΅° IDE μ±„λ„           CD-ROM
```

#### μΈν„°λ½νΈ μ„ μ  (Interrupt Preemption)

**μ„ μ  κ·μΉ™**
```
1. λ†’μ€ μ°μ„ μμ„κ°€ λ‚®μ€ μ°μ„ μμ„λ¥Ό μ„ μ  κ°€λ¥
2. κ°™μ€ μ°μ„ μμ„λΌλ¦¬λ” μ„ μ  λ¶κ°€ (λ€κΈ°)
3. λ…Όλ§μ¤μ»¤λΈ” μΈν„°λ½νΈλ” λ¨λ“  κ²ƒμ„ μ„ μ 

μμ‹ μ‹λ‚λ¦¬μ¤:
T0: IRQ 7 (LPT1) μ²λ¦¬ μ¤‘
T1: IRQ 1 (ν‚¤λ³΄λ“) λ°μƒ β†’ μ¦‰μ‹ μ„ μ 
T2: IRQ 1 μ²λ¦¬ μ™„λ£ β†’ IRQ 7 μ¬κ°
T3: IRQ 0 (νƒ€μ΄λ¨Έ) λ°μƒ β†’ IRQ 7μ„ λ‹¤μ‹ μ„ μ 
T4: IRQ 0 μ²λ¦¬ μ™„λ£ β†’ IRQ 7 μ¬κ°
```

**μ¤‘μ²© μΈν„°λ½νΈ μ¤νƒ μƒνƒ**
```
μΈν„°λ½νΈ μ¤‘μ²© μ‹ μ¤νƒ λ³€ν™”:

μ›λ ν”„λ΅κ·Έλ¨ μ‹¤ν–‰ μ¤‘:
[μ¤νƒ μµμƒλ‹¨]

IRQ 7 λ°μƒ μ‹:
[μ›λ ν”„λ΅κ·Έλ¨ μ»¨ν…μ¤νΈ]  β† IRQ 7μ΄ μ €μ¥
[μ¤νƒ μµμƒλ‹¨]

IRQ 1 λ°μƒ μ‹ (IRQ 7 μ„ μ ):
[μ›λ ν”„λ΅κ·Έλ¨ μ»¨ν…μ¤νΈ]  β† IRQ 7μ΄ μ €μ¥
[IRQ 7 μ»¨ν…μ¤νΈ]          β† IRQ 1μ΄ μ €μ¥  
[μ¤νƒ μµμƒλ‹¨]
```

### ν„λ€μ  μ°μ„ μμ„ κ΄€λ¦¬

#### APIC (Advanced Programmable Interrupt Controller)

**λ΅μ»¬ APIC μ°μ„ μμ„**
```
μ°μ„ μμ„ λ λ²¨: 0-15 (16λ‹¨κ³„)
- 15: μµκ³  μ°μ„ μμ„ (NMI, SMI)
- 14-10: μ‹μ¤ν… κ΄€λ¦¬ μΈν„°λ½νΈ
- 9-6: μ‹¤μ‹κ°„ μΈν„°λ½νΈ
- 5-2: μΌλ° ν•λ“μ›¨μ–΄ μΈν„°λ½νΈ  
- 1-0: λ‚®μ€ μ°μ„ μμ„ (λ°°κ²½ μ‘μ—…)

TPR (Task Priority Register):
- ν„μ¬ νƒμ¤ν¬μ μ°μ„ μμ„ μ„¤μ •
- TPRλ³΄λ‹¤ λ†’μ€ μ°μ„ μμ„λ§ μΈν„°λ½νΈ κ°€λ¥
- λ™μ  μ°μ„ μμ„ μ΅°μ • κ°€λ¥
```

**MSI (Message Signaled Interrupts)**
```
νΉμ§•:
- λ©”λ¨λ¦¬ μ“°κΈ° κΈ°λ° μΈν„°λ½νΈ
- IRQ λΌμΈ λ¶ν•„μ”
- λ” λ§μ€ μΈν„°λ½νΈ μ§€μ› (μμ² κ°)
- μ°μ„ μμ„λ¥Ό λ©”μ‹μ§€μ— ν¬ν•¨

MSI-X ν™•μ¥:
- λ” λ§μ€ λ²΅ν„° μ§€μ›
- λ…λ¦½μ μΈ λ§μ¤ν‚Ή
- λ””λ°”μ΄μ¤λ³„ μ„Έλ°€ν• μ μ–΄
```

#### μΈν„°λ½νΈ μΉν™”μ„± (Interrupt Affinity)

**λ©€ν‹°μ½”μ–΄μ—μ„μ μΈν„°λ½νΈ λ¶„μ‚°**
```
SMP μΈν„°λ½νΈ λΌμ°ν…:
- νΉμ • μΈν„°λ½νΈλ¥Ό νΉμ • μ½”μ–΄μ— ν• λ‹Ή
- λ΅λ“ λ°Έλ°μ‹±μΌλ΅ μ„±λ¥ ν–¥μƒ
- μΊμ‹ μ§€μ—­μ„± κ°μ„ 

μ„¤μ • μμ‹ (Linux):
echo 2 > /proc/irq/24/smp_affinity  # IRQ 24λ¥Ό CPU 1μ— ν• λ‹Ή
echo 4 > /proc/irq/25/smp_affinity  # IRQ 25λ¥Ό CPU 2μ— ν• λ‹Ή
```

---

## π› οΈ μΈν„°λ½νΈ μ„λΉ„μ¤ λ£¨ν‹΄(ISR)

### ISRμ κΈ°λ³Έ κµ¬μ΅°μ™€ μ”κµ¬μ‚¬ν•­

#### ISRμ νΉμ§•

**ν•µμ‹¬ μ”κµ¬μ‚¬ν•­**
```
1. λΉ λ¥Έ μ‹¤ν–‰ (Fast Execution)
   - κ°€λ¥ν• ν• μ§§μ€ μ‹¤ν–‰ μ‹κ°„
   - λ³µμ΅ν• μ‘μ—…μ€ ν•λ°λ¶€λ΅ μ΄μ—°

2. μ¬μ§„μ… μ•μ „μ„± (Reentrancy)
   - λ‹¤λ¥Έ μΈν„°λ½νΈμ— μν•΄ μ¤‘λ‹¨λ  μ μμ
   - κ³µμ  λ°μ΄ν„° λ³΄νΈ ν•„μ”

3. μµμ†ν•μ μ¤νƒ μ‚¬μ©
   - μΈν„°λ½νΈ μ¤νƒ μ¤λ²„ν”λ΅μ° λ°©μ§€
   - μ§€μ—­ λ³€μ μ‚¬μ© μµμ†ν™”

4. μ›μμ„± λ³΄μ¥
   - ν¬λ¦¬ν‹°μ»¬ μ„Ήμ…μ—μ„ μΈν„°λ½νΈ λΉ„ν™μ„±ν™”
   - λ°μ΄ν„° μΌκ΄€μ„± μ μ§€
```

### ISR μ‘μ„± κΈ°λ²•

#### μ–΄μ…λΈ”λ¦¬ ISR κµ¬μ΅°

**κΈ°λ³Έ ISR ν…ν”λ¦Ώ**
```assembly
; νƒ€μ΄λ¨Έ μΈν„°λ½νΈ μ„λΉ„μ¤ λ£¨ν‹΄
timer_isr:
    ; 1. λ μ§€μ¤ν„° μ €μ¥ (ν‘Έμ‹ μμ„ μ¤‘μ”)
    pushf               ; ν”λκ·Έ λ μ§€μ¤ν„° μ €μ¥
    pusha               ; λ¨λ“  λ²”μ© λ μ§€μ¤ν„° μ €μ¥
    push ds             ; μ„Έκ·Έλ¨ΌνΈ λ μ§€μ¤ν„° μ €μ¥
    push es
    push fs
    push gs
    
    ; 2. μ„Έκ·Έλ¨ΌνΈ λ μ§€μ¤ν„° μ„¤μ • (μ»¤λ„ λ¨λ“)
    mov ax, 0x10        ; μ»¤λ„ λ°μ΄ν„° μ„Έκ·Έλ¨ΌνΈ
    mov ds, ax
    mov es, ax
    
    ; 3. μ‹¤μ  μΈν„°λ½νΈ μ²λ¦¬
    call timer_handler  ; C ν•¨μ νΈμ¶
    
    ; 4. EOI (End of Interrupt) μ‹ νΈ μ „μ†΅
    mov al, 0x20        ; EOI λ…λ Ή
    out 0x20, al        ; λ§μ¤ν„° PICμ— μ „μ†΅
    
    ; 5. λ μ§€μ¤ν„° λ³µμ› (ν μμ„λ” ν‘Έμ‹μ μ—­μ)
    pop gs
    pop fs  
    pop es
    pop ds
    popa               ; λ¨λ“  λ²”μ© λ μ§€μ¤ν„° λ³µμ›
    popf               ; ν”λκ·Έ λ μ§€μ¤ν„° λ³µμ›
    
    ; 6. μΈν„°λ½νΈ λ³µκ·€
    iret               ; μ›λ ν”„λ΅κ·Έλ¨μΌλ΅ λ³µκ·€
```

**μµμ ν™”λ ISR**
```assembly
; λΉ λ¥Έ ν‚¤λ³΄λ“ μΈν„°λ½νΈ ν•Έλ“¤λ¬ (μµμ†ν•μ λ μ§€μ¤ν„°λ§ μ‚¬μ©)
keyboard_isr:
    push eax           ; μ‚¬μ©ν•  λ μ§€μ¤ν„°λ§ μ €μ¥
    push edx
    
    in al, 0x60        ; ν‚¤λ³΄λ“μ—μ„ μ¤μΊ” μ½”λ“ μ½κΈ°
    mov [key_buffer], al ; λ²„νΌμ— μ €μ¥
    inc byte [key_count] ; μΉ΄μ΄ν„° μ¦κ°€
    
    mov al, 0x20       ; EOI μ „μ†΅
    out 0x20, al
    
    pop edx            ; λ μ§€μ¤ν„° λ³µμ›
    pop eax
    iret               ; λ³µκ·€
```

#### C μ–Έμ–΄ ISR

**μ»΄νμΌλ¬ μ§€μ› ISR**
```c
// GCC __attribute__ μ‚¬μ©
void __attribute__((interrupt)) timer_handler(void) {
    // μ»΄νμΌλ¬κ°€ μλ™μΌλ΅ λ μ§€μ¤ν„° μ €μ¥/λ³µμ›
    
    // μ‹¤μ  νƒ€μ΄λ¨Έ μ²λ¦¬
    system_tick_count++;
    
    if (current_process->time_slice <= 0) {
        schedule_next_process();
    }
    
    // EOIλ” μλ™μΌλ΅ μ „μ†΅
    outb(0x20, 0x20);
}

// Microsoft Visual C++ __interrupt ν‚¤μ›λ“
void __interrupt timer_isr(void) {
    timer_tick_count++;
    outportb(0x20, 0x20);  // EOI μ „μ†΅
}
```

**μΈλΌμΈ μ–΄μ…λΈ”λ¦¬ ν™μ©**
```c
void keyboard_handler(void) {
    unsigned char scan_code;
    
    // ν‚¤λ³΄λ“μ—μ„ μ¤μΊ” μ½”λ“ μ½κΈ°
    __asm__ volatile ("inb $0x60, %0" : "=a" (scan_code));
    
    // μ¤μΊ” μ½”λ“ μ²λ¦¬
    process_key_input(scan_code);
    
    // EOI μ „μ†΅
    __asm__ volatile ("movb $0x20, %al; outb %al, $0x20");
}
```

### ISR μ„¤κ³„ ν¨ν„΄

#### μƒλ°λ¶€/ν•λ°λ¶€ (Top Half/Bottom Half)

**μƒλ°λ¶€ (Top Half) - κΈ΄κΈ‰ν• μ‘μ—…**
```c
// λ„¤νΈμ›ν¬ μΈν„°λ½νΈ μƒλ°λ¶€
void __attribute__((interrupt)) network_top_half(void) {
    // 1. κΈ΄κΈ‰ν• ν•λ“μ›¨μ–΄ μ²λ¦¬
    uint32_t status = read_network_status();
    
    // 2. ν¨ν‚· λ°μ΄ν„°λ¥Ό μ„μ‹ λ²„νΌλ΅ λΉ λ¥΄κ² λ³µμ‚¬
    if (status & RX_PACKET_READY) {
        copy_packet_to_buffer();
        schedule_bottom_half();  // ν•λ°λ¶€ μ¤μΌ€μ¤„λ§
    }
    
    // 3. ν•λ“μ›¨μ–΄ μΈν„°λ½νΈ ν΄λ¦¬μ–΄
    clear_network_interrupt();
    send_eoi();
}
```

**ν•λ°λ¶€ (Bottom Half) - μ‹κ°„μ΄ κ±Έλ¦¬λ” μ‘μ—…**
```c
// λ„¤νΈμ›ν¬ μΈν„°λ½νΈ ν•λ°λ¶€ (μ§€μ—°λ μ‘μ—…)
void network_bottom_half(void) {
    // μΈν„°λ½νΈ μ»¨ν…μ¤νΈκ°€ μ•„λ‹ - μ‹κ°„ μ μ•½μ΄ μ μ
    
    while (has_pending_packets()) {
        packet_t *packet = get_packet_from_buffer();
        
        // λ³µμ΅ν• ν¨ν‚· μ²λ¦¬
        if (validate_packet_checksum(packet)) {
            route_packet_to_protocol_stack(packet);
            update_network_statistics(packet);
            log_packet_info(packet);
        }
        
        free_packet_buffer(packet);
    }
}
```

#### μΈν„°λ½νΈ ν†µν•© (Interrupt Coalescing)

**λ‹¤μ¤‘ μ΄λ²¤νΈ μ²λ¦¬**
```c
#define MAX_EVENTS_PER_ISR 32

void __attribute__((interrupt)) disk_controller_isr(void) {
    int event_count = 0;
    uint32_t events[MAX_EVENTS_PER_ISR];
    
    // ν• λ²μ μΈν„°λ½νΈλ΅ μ—¬λ¬ μ΄λ²¤νΈ μ²λ¦¬
    while (event_count < MAX_EVENTS_PER_ISR && 
           (events[event_count] = read_disk_event()) != 0) {
        event_count++;
    }
    
    // μΌκ΄„ μ²λ¦¬λ΅ μ¤λ²„ν—¤λ“ κ°μ†
    process_disk_events(events, event_count);
    send_eoi();
}
```

### ISR λ””λ²„κΉ…κ³Ό λ¬Έμ  ν•΄κ²°

#### μΌλ°μ μΈ ISR λ²„κ·Έλ“¤

**1. λ μ§€μ¤ν„° μ €μ¥/λ³µμ› λ¶μΌμΉ**
```assembly
; μλ»λ μμ‹
bad_isr:
    push eax
    push ebx
    push ecx
    
    ; ... μ²λ¦¬ μ½”λ“ ...
    
    pop eax     ; μλ»λ¨! ecxλ¥Ό λ¨Όμ € νν•΄μ•Ό ν•¨
    pop ebx
    pop ecx
    iret
```

**2. EOI μ‹ νΈ λ„λ½**
```c
// μλ»λ μμ‹
void timer_isr(void) {
    handle_timer();
    // EOI μ „μ†΅ λ„λ½! β†’ μΈν„°λ½νΈκ°€ λ‹¤μ‹ λ°μƒν•μ§€ μ•μ
}

// μ¬λ°”λ¥Έ μμ‹  
void timer_isr(void) {
    handle_timer();
    outb(0x20, 0x20);  // EOI μ „μ†΅ ν•„μ
}
```

**3. μ¬μ§„μ… λ¬Έμ **
```c
// μ„ν—ν• μ½”λ“
int shared_counter = 0;

void timer_isr(void) {
    shared_counter++;  // λ‹¤λ¥Έ μΈν„°λ½νΈκ°€ μ¤‘κ°„μ— λΌμ–΄λ“¤ μ μμ
    send_eoi();
}

// μ•μ „ν• μ½”λ“
void timer_isr(void) {
    disable_interrupts();
    shared_counter++;
    enable_interrupts();
    send_eoi();
}
```

#### ISR μ„±λ¥ μΈ΅μ •

**μ‹¤ν–‰ μ‹κ°„ μΈ΅μ •**
```c
// νƒ€μ΄λ¨Έλ¥Ό μ΄μ©ν• ISR μ„±λ¥ μΈ΅μ •
void performance_measured_isr(void) {
    uint64_t start_time, end_time;
    
    start_time = read_timestamp_counter();
    
    // μ‹¤μ  ISR μ½”λ“
    actual_interrupt_handler();
    
    end_time = read_timestamp_counter();
    
    // ν†µκ³„ μ—…λ°μ΄νΈ (λ””λ²„κ·Έ λΉλ“μ—μ„λ§)
    #ifdef DEBUG
    update_isr_timing_stats(end_time - start_time);
    #endif
    
    send_eoi();
}
```

---

## β–οΈ μΈν„°λ½νΈ vs μμ™Έ vs νΈλ©

### κ° κ°λ…μ μ •μμ™€ νΉμ§•

#### μΈν„°λ½νΈ (Interrupt)

**μ™Έλ¶€ λΉ„λ™κΈ° μ΄λ²¤νΈ**
```
νΉμ§•:
- λΉ„λ™κΈ°μ  (Asynchronous): ν„μ¬ μ‹¤ν–‰ μ¤‘μΈ λ…λ Ήμ–΄μ™€ λ¬΄κ΄€
- μ™Έλ¶€ λ°μƒ: CPU μ™Έλ¶€ ν•λ“μ›¨μ–΄μ—μ„ λ°μƒ
- λ°λ³µ κ°€λ¥: κ°™μ€ μΈν„°λ½νΈκ°€ μ—¬λ¬ λ² λ°μƒ κ°€λ¥
- ν¬λ…μ„±: μ›λ ν”„λ΅κ·Έλ¨μ΄ μΈν„°λ½νΈλ¥Ό λ¨λ¦„

λ°μƒ μ›μΈ:
- ν•λ“μ›¨μ–΄ μ¥μΉ (ν‚¤λ³΄λ“, λ§μ°μ¤, λ„¤νΈμ›ν¬)
- νƒ€μ΄λ¨Έ
- μ „μ› κ΄€λ¦¬
- I/O μ™„λ£ μ‹ νΈ
```

#### μμ™Έ (Exception)

**λ‚΄λ¶€ λ™κΈ° μ΄λ²¤νΈ**
```
νΉμ§•:
- λ™κΈ°μ  (Synchronous): ν„μ¬ μ‹¤ν–‰ μ¤‘μΈ λ…λ Ήμ–΄μ™€ μ§μ ‘ κ΄€λ ¨
- λ‚΄λ¶€ λ°μƒ: CPU λ‚΄λ¶€μ—μ„ λ°μƒ
- κ²°μ •μ : κ°™μ€ μ΅°κ±΄μ—μ„ ν•­μƒ κ°™μ€ μμ™Έ λ°μƒ
- λ³µκµ¬ κ°€λ¥/λ¶κ°€λ¥μΌλ΅ λ¶„λ¥

λ°μƒ μ›μΈ:
- μλ»λ λ…λ Ήμ–΄ (Invalid Opcode)
- λ©”λ¨λ¦¬ μ ‘κ·Ό μ¤λ¥ (Segmentation Fault)
- μ‚°μ  μ¤λ¥ (Division by Zero)
- κ¶ν• μ„λ° (Privilege Violation)
```

#### νΈλ© (Trap)

**μλ„μ  μ†ν”„νΈμ›¨μ–΄ μΈν„°λ½νΈ**
```
νΉμ§•:
- μλ„μ : ν”„λ΅κ·Έλλ¨Έκ°€ μλ„μ μΌλ΅ λ°μƒμ‹ν‚΄
- μ‹μ¤ν… μ„λΉ„μ¤: μ΄μμ²΄μ  κΈ°λ¥ νΈμ¶
- μμΈ΅ κ°€λ¥: νΉμ • λ…λ Ήμ–΄ μ‹¤ν–‰ μ‹ λ°μƒ
- λ™κΈ°μ : νΈλ© λ…λ Ήμ–΄μ™€ λ™κΈ°ν™”λ¨

λ°μƒ μ›μΈ:
- μ‹μ¤ν… μ½ (System Call)
- μ†ν”„νΈμ›¨μ–΄ μΈν„°λ½νΈ λ…λ Ήμ–΄ (INT, SYSCALL)
- λ””λ²„κΉ… μ§€μ› (Breakpoint)
```

### μƒμ„Έ λΉ„κµ λ¶„μ„

#### μ²λ¦¬ λ°©μ‹μ μ°¨μ΄

**μΈν„°λ½νΈ μ²λ¦¬**
```
νλ¦„:
1. μ™Έλ¶€ μ‹ νΈ λ°μƒ
2. ν„μ¬ λ…λ Ήμ–΄ μ™„λ£ λ€κΈ°
3. μΈν„°λ½νΈ ν”λκ·Έ ν™•μΈ
4. μ°μ„ μμ„ κ²€μ‚¬
5. μ»¨ν…μ¤νΈ μ €μ¥ ν›„ μ²λ¦¬
6. μ›λ μ„μΉλ΅ μ •ν™•ν λ³µκ·€

λ³µκ·€ μ§€μ :
- μΈν„°λ½νΈ λ°μƒ μ‹μ μ λ‹¤μ λ…λ Ήμ–΄
- μ›λ ν”„λ΅κ·Έλ¨ νλ¦„ μ μ§€
```

**μμ™Έ μ²λ¦¬**
```
νλ¦„:
1. λ¬Έμ κ°€ μλ” λ…λ Ήμ–΄ μ‹¤ν–‰ μ‹λ„
2. μ¦‰μ‹ μμ™Έ λ°μƒ
3. μ»¨ν…μ¤νΈ μ €μ¥
4. μμ™Έ ν•Έλ“¤λ¬ νΈμ¶
5. λ³µκµ¬ μ‹λ„ λλ” ν”„λ΅κ·Έλ¨ μΆ…λ£

λ³µκ·€ μ§€μ :
- Fault: λ¬Έμ κ°€ λ λ…λ Ήμ–΄ μ¬μ‹¤ν–‰
- Trap: λ‹¤μ λ…λ Ήμ–΄λ¶€ν„° μ‹¤ν–‰
- Abort: λ³µκ·€ λ¶κ°€λ¥ (ν”„λ΅κ·Έλ¨ μΆ…λ£)
```

**νΈλ© μ²λ¦¬**
```
νλ¦„:
1. νΈλ© λ…λ Ήμ–΄ μ‹¤ν–‰ (INT, SYSCALL)
2. μ¦‰μ‹ νΈλ© λ°μƒ
3. κ¶ν• λ λ²¨ λ³€κ²½ (User β†’ Kernel)
4. μ‹μ¤ν… μ„λΉ„μ¤ μ‹¤ν–‰
5. κ²°κ³Ό λ°ν™ ν›„ λ³µκ·€

λ³µκ·€ μ§€μ :
- νΈλ© λ…λ Ήμ–΄μ λ‹¤μ λ…λ Ήμ–΄
- μ‹μ¤ν… μ½ κ²°κ³Ό μ „λ‹¬
```

#### λ²΅ν„° λ²νΈμ™€ μ²λ¦¬κΈ°

**x86 μ•„ν‚¤ν…μ² λ¶„λ¥**
```
λ²΅ν„° λ²”μ„    νƒ€μ…        μ„¤λ…                    μμ‹
0-31        μμ™Έ        CPU λ‚΄λ¶€ μμ™Έ           Division Error, Page Fault
32-47       IRQ         λ§μ¤ν„° PIC μΈν„°λ½νΈ     Timer, Keyboard
48-63       IRQ         μ¬λ μ΄λΈ PIC μΈν„°λ½νΈ   Mouse, IDE
64-255      μ‚¬μ©μ      μ†ν”„νΈμ›¨μ–΄ μΈν„°λ½νΈ     System Call, Custom ISR
```

### κµ¬μ²΄μ μΈ μμ‹ λ¶„μ„

#### μμ™Έ μ²λ¦¬ μƒμ„Έ μμ‹

**νμ΄μ§€ ν΄νΈ (Page Fault) μμ™Έ**
```c
// νμ΄μ§€ ν΄νΈ ν•Έλ“¤λ¬
void page_fault_handler(void) {
    // CR2 λ μ§€μ¤ν„°μ—μ„ λ¬Έμ κ°€ λ μ£Όμ† μ½κΈ°
    uint32_t fault_address = read_cr2();
    
    // μ¤λ¥ μ½”λ“ λ¶„μ„
    uint32_t error_code = get_error_code();
    bool present = !(error_code & 0x1);     // νμ΄μ§€ λ¶€μ¬
    bool write = error_code & 0x2;          // μ“°κΈ° μ‹λ„
    bool user = error_code & 0x4;           // μ μ € λ¨λ“
    
    if (present) {
        // νμ΄μ§€κ°€ μ—†μ - λ””λ§¨λ“ νμ΄μ§•
        if (allocate_page(fault_address)) {
            return;  // λ³µκµ¬ μ„±κ³µ - λ…λ Ήμ–΄ μ¬μ‹¤ν–‰
        }
    }
    
    if (write && is_copy_on_write_page(fault_address)) {
        // Copy-on-Write μ²λ¦¬
        copy_page(fault_address);
        return;  // λ³µκµ¬ μ„±κ³µ
    }
    
    // λ³µκµ¬ λ¶κ°€λ¥ - ν”„λ΅μ„Έμ¤ μΆ…λ£
    terminate_process_with_segfault();
}
```

**μ‹μ¤ν… μ½ νΈλ© μμ‹**
```assembly
; Linux x86-64 μ‹μ¤ν… μ½
; write(fd, buf, count) νΈμ¶

user_program:
    mov rax, 1          ; sys_write μ‹μ¤ν… μ½ λ²νΈ
    mov rdi, 1          ; fd = stdout
    mov rsi, message    ; buf = λ©”μ‹μ§€ μ£Όμ†  
    mov rdx, msg_len    ; count = λ©”μ‹μ§€ κΈΈμ΄
    syscall             ; νΈλ© λ°μƒ - μ»¤λ„ λ¨λ“λ΅ μ „ν™
    ; μ—¬κΈ°μ„ λ³µκ·€ - μ‹μ¤ν… μ½ κ²°κ³Όκ°€ raxμ—
```

#### λ³µν•©μ  μƒν™© μ²λ¦¬

**μΈν„°λ½νΈ μ¤‘ μμ™Έ λ°μƒ**
```
μ‹λ‚λ¦¬μ¤:
1. νƒ€μ΄λ¨Έ μΈν„°λ½νΈ μ²λ¦¬ μ¤‘
2. ISRμ—μ„ μλ»λ ν¬μΈν„° μ—­μ°Έμ΅°
3. νμ΄μ§€ ν΄νΈ μμ™Έ λ°μƒ

μ²λ¦¬ κ³Όμ •:
1. νƒ€μ΄λ¨Έ ISR μ»¨ν…μ¤νΈ μ €μ¥
2. νμ΄μ§€ ν΄νΈ ν•Έλ“¤λ¬ μ‹¤ν–‰
3. νμ΄μ§€ ν΄νΈ λ³µκµ¬ λλ” μ»¤λ„ ν¨λ‹‰
4. νƒ€μ΄λ¨Έ ISRλ΅ λ³µκ·€ (λ³µκµ¬λ κ²½μ°)
```

**μμ™Έ μ¤‘ μΈν„°λ½νΈ λ°μƒ**
```
μ‹λ‚λ¦¬μ¤:
1. νμ΄μ§€ ν΄νΈ μ²λ¦¬ μ¤‘ (λ””μ¤ν¬μ—μ„ νμ΄μ§€ λ΅λ“)
2. ν‚¤λ³΄λ“ μΈν„°λ½νΈ λ°μƒ

μ²λ¦¬ λ°©μ‹:
- λ§μ¤μ»¤λΈ” μΈν„°λ½νΈ: μμ™Έ μ²λ¦¬ μ™„λ£ ν›„ μ²λ¦¬
- λ…Όλ§μ¤μ»¤λΈ” μΈν„°λ½νΈ: μ¦‰μ‹ μ„ μ ν•μ—¬ μ²λ¦¬
```

### μ„±λ¥κ³Ό μ¤λ²„ν—¤λ“ λΉ„κµ

```
μ²λ¦¬ μ‹κ°„ (μƒλ€μ ):
νΈλ© (μ‹μ¤ν… μ½): 50-200 μ‚¬μ΄ν΄
μμ™Έ (νμ΄μ§€ ν΄νΈ): 1,000-10,000 μ‚¬μ΄ν΄  
μΈν„°λ½νΈ (ν•λ“μ›¨μ–΄): 100-1,000 μ‚¬μ΄ν΄

μ¤λ²„ν—¤λ“ μ”μΈ:
1. μ»¨ν…μ¤νΈ μ¤μ„μΉ­ λΉ„μ©
2. μΊμ‹ λ―Έμ¤ μ¦κ°€
3. νμ΄ν”„λΌμΈ ν”λ¬μ‹
4. TLB λ―Έμ¤ (μ£Όμ† λ³€ν™)
```

---

## π”§ ν•λ“μ›¨μ–΄λ³„ μΈν„°λ½νΈ κµ¬ν„

### x86/x64 μ•„ν‚¤ν…μ²

#### Intel 8259A PIC (Programmable Interrupt Controller)

**PIC κµ¬μ΅°μ™€ λ™μ‘**
```
λ§μ¤ν„° PIC (IRQ 0-7):
ν¬νΈ μ£Όμ†: 0x20 (λ…λ Ή), 0x21 (λ°μ΄ν„°)
- IRQ 0: μ‹μ¤ν… νƒ€μ΄λ¨Έ
- IRQ 1: ν‚¤λ³΄λ“
- IRQ 2: μ¬λ μ΄λΈ PIC μ—°κ²°
- IRQ 3-7: κΈ°νƒ€ μ¥μΉ

μ¬λ μ΄λΈ PIC (IRQ 8-15):  
ν¬νΈ μ£Όμ†: 0xA0 (λ…λ Ή), 0xA1 (λ°μ΄ν„°)
- IRQ 8: μ‹¤μ‹κ°„ μ‹κ³„
- IRQ 9-15: ν™•μ¥ μ¥μΉ
```

**PIC ν”„λ΅κ·Έλλ°**
```c
// PIC μ΄κΈ°ν™” (ICW1-ICW4)
void init_pic(void) {
    // ICW1: μ΄κΈ°ν™” μ‹μ‘
    outb(0x20, 0x11);  // λ§μ¤ν„° PIC
    outb(0xA0, 0x11);  // μ¬λ μ΄λΈ PIC
    
    // ICW2: λ²΅ν„° μ¤ν”„μ…‹ μ„¤μ •
    outb(0x21, 0x20);  // λ§μ¤ν„°: IRQ 0-7 β†’ λ²΅ν„° 32-39
    outb(0xA1, 0x28);  // μ¬λ μ΄λΈ: IRQ 8-15 β†’ λ²΅ν„° 40-47
    
    // ICW3: PIC μ—°κ²° μ„¤μ •
    outb(0x21, 0x04);  // λ§μ¤ν„°: IRQ 2μ— μ¬λ μ΄λΈ μ—°κ²°
    outb(0xA1, 0x02);  // μ¬λ μ΄λΈ: λ§μ¤ν„°μ IRQ 2μ— μ—°κ²°
    
    // ICW4: λ™μ‘ λ¨λ“ μ„¤μ •
    outb(0x21, 0x01);  // 8086 λ¨λ“
    outb(0xA1, 0x01);
    
    // λ¨λ“  μΈν„°λ½νΈ λ§μ¤ν‚Ή ν•΄μ 
    outb(0x21, 0x00);
    outb(0xA1, 0x00);
}

// νΉμ • IRQ λ§μ¤ν‚Ή/μ–Έλ§μ¤ν‚Ή
void mask_irq(int irq) {
    uint16_t port = (irq < 8) ? 0x21 : 0xA1;
    uint8_t value = inb(port) | (1 << (irq % 8));
    outb(port, value);
}

void unmask_irq(int irq) {
    uint16_t port = (irq < 8) ? 0x21 : 0xA1;
    uint8_t value = inb(port) & ~(1 << (irq % 8));
    outb(port, value);
}
```

#### APIC (Advanced Programmable Interrupt Controller)

**λ΅μ»¬ APIC κµ¬μ΅°**
```
APIC κΈ°μ¤€ μ£Όμ†: 0xFEE00000 (κΈ°λ³Έκ°’)

μ£Όμ” λ μ§€μ¤ν„°:
0x020: λ΅μ»¬ APIC ID
0x080: νƒμ¤ν¬ μ°μ„ μμ„ (TPR)
0x0B0: EOI λ μ§€μ¤ν„°
0x0F0: Spurious μΈν„°λ½νΈ λ²΅ν„°
0x300: ICR (Interrupt Command Register) Low
0x310: ICR High
0x320: LVT Timer
0x330: LVT Thermal Sensor
0x340: LVT Performance Counter
0x350: LVT LINT0
0x360: LVT LINT1
0x370: LVT Error
```

**APIC ν”„λ΅κ·Έλλ°**
```c
#define APIC_BASE 0xFEE00000

// APIC λ μ§€μ¤ν„° μ½κΈ°/μ“°κΈ°
uint32_t apic_read(uint32_t reg) {
    return *(volatile uint32_t*)(APIC_BASE + reg);
}

void apic_write(uint32_t reg, uint32_t value) {
    *(volatile uint32_t*)(APIC_BASE + reg) = value;
}

// APIC μ΄κΈ°ν™”
void init_local_apic(void) {
    // Spurious μΈν„°λ½νΈ λ²΅ν„° μ„¤μ • λ° APIC ν™μ„±ν™”
    apic_write(0x0F0, 0x100 | 0xFF);  // λ²΅ν„° 255, APIC ν™μ„±ν™”
    
    // λ¨λ“  LVT μ—”νΈλ¦¬ λ§μ¤ν‚Ή
    apic_write(0x320, 0x10000);  // Timer
    apic_write(0x330, 0x10000);  // Thermal
    apic_write(0x340, 0x10000);  // Performance
    apic_write(0x350, 0x10000);  // LINT0
    apic_write(0x360, 0x10000);  // LINT1
    apic_write(0x370, 0x10000);  // Error
    
    // TPRμ„ 0μΌλ΅ μ„¤μ • (λ¨λ“  μΈν„°λ½νΈ ν—μ©)
    apic_write(0x080, 0);
}

// EOI μ „μ†΅
void apic_send_eoi(void) {
    apic_write(0x0B0, 0);
}
```

**IPI (Inter-Processor Interrupt) μ „μ†΅**
```c
// λ‹¤λ¥Έ CPUμ— μΈν„°λ½νΈ μ „μ†΅
void send_ipi(uint8_t dest_cpu, uint8_t vector) {
    // ICR High: λ©μ μ§€ CPU ID
    apic_write(0x310, (uint32_t)dest_cpu << 24);
    
    // ICR Low: λ²΅ν„° λ²νΈμ™€ μ „μ†΅ λ¨λ“
    apic_write(0x300, vector | 0x4000);  // Fixed delivery mode
    
    // μ „μ†΅ μ™„λ£ λ€κΈ°
    while (apic_read(0x300) & 0x1000);  // Delivery Status ν™•μΈ
}
```

### ARM μ•„ν‚¤ν…μ²

#### ARM GIC (Generic Interrupt Controller)

**GIC κµ¬μ΅°**
```
GIC-400 (ARMv7):
- Distributor: μΈν„°λ½νΈ λ¶„λ°° λ° μ°μ„ μμ„ κ΄€λ¦¬
- CPU Interface: κ° CPU μ½”μ–΄λ³„ μΈν„°λ½νΈ μΈν„°νμ΄μ¤
- Virtual Interface: κ°€μƒν™” μ§€μ›

μΈν„°λ½νΈ νƒ€μ…:
- SGI (Software Generated Interrupt): 0-15
- PPI (Private Peripheral Interrupt): 16-31  
- SPI (Shared Peripheral Interrupt): 32-1019
```

**GIC ν”„λ΅κ·Έλλ°**
```c
// GIC λ μ§€μ¤ν„° κΈ°μ¤€ μ£Όμ†
#define GICD_BASE 0x01C81000  // Distributor
#define GICC_BASE 0x01C82000  // CPU Interface

// μΈν„°λ½νΈ ν™μ„±ν™”
void gic_enable_interrupt(int irq) {
    int reg = irq / 32;
    int bit = irq % 32;
    
    // Distributorμ—μ„ μΈν„°λ½νΈ ν™μ„±ν™”
    volatile uint32_t *enable_reg = 
        (volatile uint32_t*)(GICD_BASE + 0x100 + reg * 4);
    *enable_reg |= (1 << bit);
}

// μΈν„°λ½νΈ μ°μ„ μμ„ μ„¤μ •
void gic_set_priority(int irq, uint8_t priority) {
    volatile uint8_t *priority_reg = 
        (volatile uint8_t*)(GICD_BASE + 0x400 + irq);
    *priority_reg = priority;
}

// μΈν„°λ½νΈ μμ‹  (CPU Interface)
uint32_t gic_read_interrupt(void) {
    volatile uint32_t *iar = (volatile uint32_t*)(GICC_BASE + 0x0C);
    return *iar & 0x3FF;  // μΈν„°λ½νΈ ID μ¶”μ¶
}

// EOI μ „μ†΅
void gic_send_eoi(uint32_t irq) {
    volatile uint32_t *eoir = (volatile uint32_t*)(GICC_BASE + 0x10);
    *eoir = irq;
}
```

#### ARM μΈν„°λ½νΈ λ²΅ν„° ν…μ΄λΈ”

**λ²΅ν„° ν…μ΄λΈ” μ„¤μ •**
```assembly
.section .vectors
.global _vector_table

_vector_table:
    b reset_handler         @ 0x00: Reset
    b undefined_handler     @ 0x04: Undefined Instruction
    b swi_handler          @ 0x08: Software Interrupt
    b prefetch_handler     @ 0x0C: Prefetch Abort
    b data_handler         @ 0x10: Data Abort
    b reserved_handler     @ 0x14: Reserved
    b irq_handler          @ 0x18: IRQ
    b fiq_handler          @ 0x1C: FIQ

@ IRQ ν•Έλ“¤λ¬ κµ¬ν„
irq_handler:
    stmfd sp!, {r0-r12, lr}    @ λ μ§€μ¤ν„° μ €μ¥
    
    bl gic_read_interrupt      @ μΈν„°λ½νΈ ID μ½κΈ°
    mov r4, r0                 @ ID λ³΄μ΅΄
    
    bl handle_irq              @ C ν•Έλ“¤λ¬ νΈμ¶
    
    mov r0, r4                 @ ID λ³µμ›
    bl gic_send_eoi            @ EOI μ „μ†΅
    
    ldmfd sp!, {r0-r12, lr}    @ λ μ§€μ¤ν„° λ³µμ›
    subs pc, lr, #4            @ λ³µκ·€
```

### RISC-V μ•„ν‚¤ν…μ²

#### RISC-V μΈν„°λ½νΈ/μμ™Έ μ²λ¦¬

**CSR (Control and Status Registers)**
```
mstatus: λ¨Έμ‹  λ¨λ“ μƒνƒ
mie: λ¨Έμ‹  μΈν„°λ½νΈ ν™μ„±ν™”
mip: λ¨Έμ‹  μΈν„°λ½νΈ λ€κΈ°
mtvec: λ¨Έμ‹  νΈλ© λ²΅ν„° λ² μ΄μ¤
mepc: λ¨Έμ‹  μμ™Έ ν”„λ΅κ·Έλ¨ μΉ΄μ΄ν„°
mcause: λ¨Έμ‹  μ›μΈ λ μ§€μ¤ν„°
mtval: λ¨Έμ‹  νΈλ© κ°’
```

**RISC-V μΈν„°λ½νΈ μ²λ¦¬**
```c
// νΈλ© ν•Έλ“¤λ¬
void machine_trap_handler(void) {
    uint64_t mcause_val = read_csr(mcause);
    uint64_t mepc_val = read_csr(mepc);
    uint64_t mtval_val = read_csr(mtval);
    
    if (mcause_val & (1UL << 63)) {
        // μΈν„°λ½νΈ
        switch (mcause_val & 0x7FFFFFFFFFFFFFFF) {
            case 7:  // λ¨Έμ‹  νƒ€μ΄λ¨Έ μΈν„°λ½νΈ
                handle_timer_interrupt();
                break;
            case 11: // λ¨Έμ‹  μ™Έλ¶€ μΈν„°λ½νΈ
                handle_external_interrupt();
                break;
        }
    } else {
        // μμ™Έ
        switch (mcause_val) {
            case 8:  // ν™κ²½ νΈμ¶ (ECALL)
                handle_system_call();
                write_csr(mepc, mepc_val + 4);  // λ‹¤μ λ…λ Ήμ–΄λ΅
                break;
            case 12: // λ…λ Ήμ–΄ νμ΄μ§€ ν΄νΈ
                handle_instruction_page_fault(mtval_val);
                break;
            case 13: // λ΅λ“ νμ΄μ§€ ν΄νΈ
                handle_load_page_fault(mtval_val);
                break;
        }
    }
}
```

### μ„±λ¥ μµμ ν™” λΉ„κµ

#### μ•„ν‚¤ν…μ²λ³„ μΈν„°λ½νΈ μ§€μ—°μ‹κ°„

```
μ²λ¦¬ μ§€μ—°μ‹κ°„ (λ§μ΄ν¬λ΅μ΄):
x86 PIC:     10-50ΞΌs
x86 APIC:    2-10ΞΌs
ARM GIC:     1-5ΞΌs
RISC-V:      0.5-3ΞΌs

μµμ ν™” μ”μ†:
1. ν•λ“μ›¨μ–΄ λ³µμ΅λ„
2. λ²΅ν„° ν…μ΄λΈ” κµ¬μ΅°
3. μ»¨ν…μ¤νΈ μ €μ¥ λ°©μ‹
4. μΊμ‹ μΉν™”μ„±
```

---

## β΅ μΈν„°λ½νΈμ™€ μ‹μ¤ν… μ„±λ¥

### μΈν„°λ½νΈ μ¤λ²„ν—¤λ“ λ¶„μ„

#### μ§μ ‘μ  μ¤λ²„ν—¤λ“

**μ»¨ν…μ¤νΈ μ¤μ„μΉ­ λΉ„μ©**
```
ν•λ“μ›¨μ–΄ μλ™ μ €μ¥:
- ν”λκ·Έ λ μ§€μ¤ν„°: 1 ν΄λ΅
- μ½”λ“ μ„Έκ·Έλ¨ΌνΈ: 1 ν΄λ΅  
- λ…λ Ήμ–΄ ν¬μΈν„°: 1 ν΄λ΅
μ΄ 3ν΄λ΅ (μ•½ 1-3 λ‚λ…Έμ΄ @ 1-3GHz)

μ†ν”„νΈμ›¨μ–΄ μ €μ¥ (ISR):
- λ²”μ© λ μ§€μ¤ν„° 8κ°: 8 ν΄λ΅
- μ„Έκ·Έλ¨ΌνΈ λ μ§€μ¤ν„° 4κ°: 4 ν΄λ΅
- μ¶”κ°€ μƒνƒ μ •λ³΄: 2-5 ν΄λ΅
μ΄ 14-17ν΄λ΅ (μ•½ 5-15 λ‚λ…Έμ΄)

λ²΅ν„° ν…μ΄λΈ” μ°Έμ΅°:
- λ©”λ¨λ¦¬ μ ‘κ·Ό: 100-300 ν΄λ΅ (μΊμ‹ λ―Έμ¤ μ‹)
- L1 μΊμ‹ μ μ¤‘: 1-2 ν΄λ΅
ν‰κ·  5-10 ν΄λ΅
```

**μ‹¤μ  ISR μ‹¤ν–‰ μ‹κ°„**
```
κ°„λ‹¨ν• ISR (ν‚¤λ³΄λ“):
- μ¤μΊ” μ½”λ“ μ½κΈ°: 1-2 ν΄λ΅
- λ²„νΌ μ €μ¥: 1-2 ν΄λ΅  
- EOI μ „μ†΅: 1 ν΄λ΅
μ΄ 3-5 ν΄λ΅

λ³µμ΅ν• ISR (λ„¤νΈμ›ν¬):
- μƒνƒ ν™•μΈ: 5-10 ν΄λ΅
- ν¨ν‚· μ½κΈ°: 50-200 ν΄λ΅
- ν μ΅°μ‘: 20-50 ν΄λ΅
- ν”„λ΅ν† μ½ μ²λ¦¬: 100-1000 ν΄λ΅
μ΄ 175-1260 ν΄λ΅
```

#### κ°„μ ‘μ  μ¤λ²„ν—¤λ“

**μΊμ‹ μ¤μ—Ό (Cache Pollution)**
```
λ¬Έμ :
- ISRμ΄ μΊμ‹ λΌμΈμ„ μ μ 
- μ›λ ν”„λ΅κ·Έλ¨μ λ°μ΄ν„°κ°€ μΊμ‹μ—μ„ μ¶•μ¶λ¨
- μΈν„°λ½νΈ λ³µκ·€ ν›„ μΊμ‹ λ―Έμ¤ μ¦κ°€

μΈ΅μ • μμ‹:
μΈν„°λ½νΈ μ—†λ” κ²½μ°: 95% L1 μΊμ‹ μ μ¤‘λ¥ 
μΈν„°λ½νΈ μλ” κ²½μ°: 85% L1 μΊμ‹ μ μ¤‘λ¥ 
μ„±λ¥ μ €ν•: μ•½ 10-15%
```

**νμ΄ν”„λΌμΈ ν”λ¬μ‹**
```
ν„λ€ CPUμ νμ΄ν”„λΌμΈ:
- μΈν…” Core i7: 14-19 λ‹¨κ³„
- AMD Ryzen: 20λ‹¨κ³„
- ARM Cortex-A77: 13λ‹¨κ³„

μΈν„°λ½νΈ λ°μƒ μ‹:
- μ „μ²΄ νμ΄ν”„λΌμΈ ν”λ¬μ‹
- λ¶„κΈ° μμΈ΅ ν…μ΄λΈ” νΌλ€
- μμ‹­ ν΄λ΅μ μ„±λ¥ μ†μ‹¤
```

### μΈν„°λ½νΈ μµμ ν™” κΈ°λ²•

#### 1. μΈν„°λ½νΈ ν†µν•© (Interrupt Coalescing)

**κ°λ…κ³Ό κµ¬ν„**
```c
// μΈν„°λ½νΈ ν†µν•©μ„ μ„ν• κµ¬μ΅°μ²΄
struct interrupt_coalescing {
    uint32_t threshold;     // μ„κ³„ μ΄λ²¤νΈ μ
    uint32_t timeout;       // μµλ€ λ€κΈ° μ‹κ°„ (λ§μ΄ν¬λ΅μ΄)
    uint32_t pending_count; // λ€κΈ° μ¤‘μΈ μ΄λ²¤νΈ μ
    uint64_t last_interrupt; // λ§μ§€λ§‰ μΈν„°λ½νΈ μ‹κ°„
};

// λ„¤νΈμ›ν¬ μΉ΄λ“ μΈν„°λ½νΈ ν†µν•©
void network_interrupt_handler(void) {
    static struct interrupt_coalescing coalescing = {
        .threshold = 32,    // 32κ° ν¨ν‚·λ§λ‹¤ μΈν„°λ½νΈ
        .timeout = 50       // 50ΞΌs μµλ€ λ€κΈ°
    };
    
    uint32_t packets_processed = 0;
    uint64_t start_time = get_timestamp();
    
    // μ—¬λ¬ ν¨ν‚·μ„ ν• λ²μ— μ²λ¦¬
    while (has_pending_packet() && 
           packets_processed < coalescing.threshold) {
        process_packet();
        packets_processed++;
    }
    
    // ν†µκ³„ μ—…λ°μ΄νΈ
    update_coalescing_stats(&coalescing, packets_processed);
    send_eoi();
}
```

#### 2. μΈν„°λ½νΈ μΉν™”μ„± (Interrupt Affinity)

**CPU λ°”μΈλ”© μµμ ν™”**
```bash
# Linuxμ—μ„ μΈν„°λ½νΈ μΉν™”μ„± μ„¤μ •
# λ„¤νΈμ›ν¬ μΈν„°λ½νΈλ¥Ό CPU 2, 3μ—λ§ ν• λ‹Ή
echo 0x0C > /proc/irq/24/smp_affinity

# μ¤ν† λ¦¬μ§€ μΈν„°λ½νΈλ¥Ό CPU 0, 1μ—λ§ ν• λ‹Ή  
echo 0x03 > /proc/irq/25/smp_affinity

# μ„±λ¥ ν–¥μƒ ν¨κ³Ό:
# - μΊμ‹ μ§€μ—­μ„± κ°μ„ 
# - NUMA μ§€μ—­μ„± ν™μ©
# - CPU λ΅λ“ λ°Έλ°μ‹±
```

**λ™μ  μΉν™”μ„± μ΅°μ •**
```c
// λ™μ  μΈν„°λ½νΈ μΉν™”μ„± μ΅°μ •
void balance_interrupt_load(void) {
    for (int irq = 32; irq < 256; irq++) {
        uint64_t irq_count = get_irq_count(irq);
        int current_cpu = get_irq_affinity(irq);
        int cpu_load = get_cpu_load(current_cpu);
        
        // λ΅λ“κ°€ λ†’μΌλ©΄ λ‹¤λ¥Έ CPUλ΅ μ΄λ™
        if (cpu_load > LOAD_THRESHOLD) {
            int best_cpu = find_least_loaded_cpu();
            set_irq_affinity(irq, best_cpu);
        }
    }
}
```

#### 3. NAPI (New API) - Linux λ„¤νΈμ›ν¬ μµμ ν™”

**ν΄λ§κ³Ό μΈν„°λ½νΈ νΌν•©**
```c
// NAPI λ°©μ‹ λ„¤νΈμ›ν¬ λ“λΌμ΄λ²„
int napi_poll(struct napi_struct *napi, int budget) {
    int work_done = 0;
    
    // μΈν„°λ½νΈ λΉ„ν™μ„±ν™” μƒνƒμ—μ„ ν΄λ§
    while (work_done < budget && has_packets()) {
        process_one_packet();
        work_done++;
    }
    
    if (work_done < budget) {
        // λ¨λ“  ν¨ν‚· μ²λ¦¬ μ™„λ£ - μΈν„°λ½νΈ λ¨λ“λ΅ λ³µκ·€
        napi_complete(napi);
        enable_network_interrupts();
    }
    
    return work_done;
}

// μΈν„°λ½νΈ ν•Έλ“¤λ¬ (NAPI μ¤μΌ€μ¤„λ§)
void network_interrupt_handler(void) {
    if (napi_schedule_prep(&adapter->napi)) {
        // μΈν„°λ½νΈ λΉ„ν™μ„±ν™” ν›„ ν΄λ§ μ¤μΌ€μ¤„
        disable_network_interrupts();
        __napi_schedule(&adapter->napi);
    }
}
```

### μ„±λ¥ μΈ΅μ •κ³Ό λ¨λ‹ν„°λ§

#### μΈν„°λ½νΈ ν†µκ³„ μμ§‘

**μ‹μ¤ν… λ λ²¨ λ¨λ‹ν„°λ§**
```bash
# Linux μΈν„°λ½νΈ ν†µκ³„ ν™•μΈ
cat /proc/interrupts
watch -n 1 'cat /proc/interrupts'

# νΉμ • CPUμ μΈν„°λ½νΈ λ¶€ν• ν™•μΈ
mpstat -P ALL 1

# μΈν„°λ½νΈλ³„ μƒμ„Έ μ •λ³΄
cat /proc/stat | grep intr
```

**ν”„λ΅κ·Έλλ°μ„ ν†µν• μΈ΅μ •**
```c
// μΈν„°λ½νΈ μ„±λ¥ μΉ΄μ΄ν„°
struct interrupt_stats {
    uint64_t total_interrupts;
    uint64_t total_latency;      // λ„μ  μ§€μ—°μ‹κ°„ (λ‚λ…Έμ΄)
    uint64_t max_latency;        // μµλ€ μ§€μ—°μ‹κ°„
    uint64_t min_latency;        // μµμ† μ§€μ—°μ‹κ°„
    uint64_t cache_misses;       // μΊμ‹ λ―Έμ¤ μ
};

// ISRμ—μ„ μ„±λ¥ μΈ΅μ •
void __attribute__((interrupt)) measured_isr(void) {
    uint64_t start_time = rdtsc();  // μ‹μ‘ μ‹κ°„ κΈ°λ΅
    
    // μ‹¤μ  μΈν„°λ½νΈ μ²λ¦¬
    handle_interrupt();
    
    uint64_t end_time = rdtsc();    // μΆ…λ£ μ‹κ°„ κΈ°λ΅
    uint64_t latency = end_time - start_time;
    
    // ν†µκ³„ μ—…λ°μ΄νΈ
    update_interrupt_stats(latency);
    
    send_eoi();
}
```

### μ‹¤μ‹κ°„ μ‹μ¤ν…μ—μ„μ μΈν„°λ½νΈ

#### μΈν„°λ½νΈ μ§€μ—°μ‹κ°„ λ³΄μ¥

**ν•λ“ μ‹¤μ‹κ°„ μ”κµ¬μ‚¬ν•­**
```
ν•­κ³µκΈ° μ μ–΄: 10ΞΌs μ΄λ‚΄
μλ£ μ¥λΉ„: 100ΞΌs μ΄λ‚΄  
μ‚°μ—… μλ™ν™”: 1ms μ΄λ‚΄
λ©€ν‹°λ―Έλ””μ–΄: 10ms μ΄λ‚΄
```

**RT-Linuxμ μΈν„°λ½νΈ μ²λ¦¬**
```c
// μ‹¤μ‹κ°„ μ°μ„ μμ„ μΈν„°λ½νΈ μ¤λ λ“
int realtime_irq_thread(void *data) {
    struct irq_desc *desc = (struct irq_desc *)data;
    
    // μ‹¤μ‹κ°„ μ¤μΌ€μ¤„λ§ μ •μ±… μ„¤μ •
    struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
    sched_setscheduler(current, SCHED_FIFO, &param);
    
    while (!kthread_should_stop()) {
        // μΈν„°λ½νΈ λ€κΈ°
        wait_for_interrupt(desc);
        
        // μ§€μ—°μ‹κ°„ μΈ΅μ • μ‹μ‘
        uint64_t start = ktime_get_ns();
        
        // μ‹¤μ  μΈν„°λ½νΈ μ²λ¦¬
        handle_realtime_interrupt(desc);
        
        uint64_t latency = ktime_get_ns() - start;
        
        // μ‹¤μ‹κ°„ μ μ•½ μ„λ° κ²€μ‚¬
        if (latency > desc->max_allowed_latency) {
            report_latency_violation(desc, latency);
        }
    }
    
    return 0;
}
```

---

## π€ ν„λ€ μ‹μ¤ν…μ μΈν„°λ½νΈ

### κ°€μƒν™”μ™€ μΈν„°λ½νΈ

#### ν•μ΄νΌλ°”μ΄μ €μ μΈν„°λ½νΈ κ°€μƒν™”

**Intel VT-xμ κ°€μƒ μΈν„°λ½νΈ**
```
κΈ°λ¥:
- Virtual APIC: κ²μ¤νΈ OSμ© κ°€μƒ APIC
- Posted Interrupts: ν•μ΄νΌλ°”μ΄μ € κ°μ… μ—†λ” μΈν„°λ½νΈ μ „λ‹¬
- VMCS: VM μ μ–΄ κµ¬μ΅°μ²΄μ— μΈν„°λ½νΈ μ„¤μ • μ €μ¥

λ™μ‘ κ³Όμ •:
1. λ¬Όλ¦¬μ  μΈν„°λ½νΈ λ°μƒ
2. ν•μ΄νΌλ°”μ΄μ €κ°€ μΈν„°λ½νΈ μμ‹ 
3. ν•΄λ‹Ήν•λ” κ²μ¤νΈ VM ν™•μΈ
4. κ°€μƒ μΈν„°λ½νΈλ΅ λ³€ν™ν•μ—¬ κ²μ¤νΈμ— μ „λ‹¬
5. κ²μ¤νΈ OSκ°€ μΌλ° μΈν„°λ½νΈμ²λΌ μ²λ¦¬
```

**KVMμ μΈν„°λ½νΈ μ²λ¦¬**
```c
// KVM κ°€μƒ μΈν„°λ½νΈ μ£Όμ…
int kvm_inject_interrupt(struct kvm_vcpu *vcpu, int vector) {
    struct kvm_interrupt irq;
    irq.irq = vector;
    
    // κ²μ¤νΈκ°€ μΈν„°λ½νΈλ¥Ό λ°›μ„ μ μλ” μƒνƒμΈμ§€ ν™•μΈ
    if (!kvm_arch_interrupt_allowed(vcpu)) {
        return -EBUSY;
    }
    
    // VMCSμ— μΈν„°λ½νΈ μ •λ³΄ μ„¤μ •
    vmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 
                 INTR_INFO_VALID_MASK | 
                 INTR_TYPE_EXT_INTR | 
                 vector);
    
    return 0;
}
```

#### μ»¨ν…μ΄λ„μ™€ μΈν„°λ½νΈ κ²©λ¦¬

**λ„¤μ„μ¤νμ΄μ¤ κΈ°λ° μΈν„°λ½νΈ κ΄€λ¦¬**
```c
// μ»¨ν…μ΄λ„λ³„ μΈν„°λ½νΈ ν†µκ³„ λ¶„λ¦¬
struct container_irq_stats {
    struct task_struct *container_init;
    uint64_t irq_count[NR_IRQS];
    uint64_t irq_time[NR_IRQS];
    struct cgroup *cgroup;
};

// μ»¨ν…μ΄λ„λ³„ μΈν„°λ½νΈ μ–΄μΉ΄μ΄ν…
void account_irq_to_container(int irq, uint64_t processing_time) {
    struct task_struct *current_task = current;
    struct container_irq_stats *stats;
    
    // ν„μ¬ νƒμ¤ν¬κ°€ μ†ν• μ»¨ν…μ΄λ„ μ°ΎκΈ°
    stats = find_container_irq_stats(current_task);
    if (stats) {
        stats->irq_count[irq]++;
        stats->irq_time[irq] += processing_time;
    }
}
```

### MSI/MSI-X (Message Signaled Interrupts)

#### κΈ°μ΅΄ IRQ λΌμΈμ ν•κ³„

**μ „ν†µμ  IRQ λ°©μ‹μ λ¬Έμ **
```
ν•κ³„μ :
- μ ν•λ IRQ λΌμΈ μ (x86: 16κ°)
- κ³µμ λ΅ μΈν• μ„±λ¥ μ €ν•
- μ—£μ§€/λ λ²¨ κ°μ§€ λ³µμ΅μ„±
- λ©€ν‹°μ½”μ–΄ ν™•μ¥μ„± λ¶€μ΅±

PCI μ¬λ΅―λ³„ IRQ ν• λ‹Ή μμ‹:
PCI Slot 1: IRQ 10 (λ„¤νΈμ›ν¬ μΉ΄λ“)
PCI Slot 2: IRQ 11 (μ‚¬μ΄λ“ μΉ΄λ“)  
PCI Slot 3: IRQ 10 (USB μ»¨νΈλ΅¤λ¬) β† κ³µμ !
PCI Slot 4: IRQ 11 (μ¤ν† λ¦¬μ§€) β† κ³µμ !
```

#### MSIμ μ¥μ κ³Ό κµ¬ν„

**MSI λ©”μ»¤λ‹μ¦**
```
νΉμ§•:
- λ©”λ¨λ¦¬ μ“°κΈ° κΈ°λ° μΈν„°λ½νΈ
- κ° λ””λ°”μ΄μ¤κ°€ κ³ μ  λ²΅ν„° μ‚¬μ© κ°€λ¥
- λ” λ‚μ€ μ„±λ¥κ³Ό ν™•μ¥μ„±
- μ›μμ  μΈν„°λ½νΈ μ „λ‹¬

MSI λ©”μ‹μ§€ κµ¬μ΅° (x86):
Address: 0xFEE00000 | (dest_cpu << 12)
Data: vector | (trigger_mode << 15) | (level << 14)
```

**MSI μ„¤μ • μ½”λ“**
```c
// PCI λ””λ°”μ΄μ¤μ MSI ν™μ„±ν™”
int enable_msi(struct pci_dev *dev) {
    struct msi_desc *entry;
    int vector;
    
    // MSI λ¥λ ¥ κµ¬μ΅°μ²΄ μ°ΎκΈ°
    int pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
    if (!pos) {
        return -ENODEV;
    }
    
    // λ²΅ν„° ν• λ‹Ή
    vector = alloc_msi_vector();
    if (vector < 0) {
        return vector;
    }
    
    // MSI μ£Όμ†/λ°μ΄ν„° μ„¤μ •
    uint32_t address = 0xFEE00000;  // κ³ μ • μ£Όμ†
    uint32_t data = vector;         // λ²΅ν„° λ²νΈ
    
    pci_write_config_dword(dev, pos + PCI_MSI_ADDRESS_LO, address);
    pci_write_config_dword(dev, pos + PCI_MSI_DATA, data);
    
    // MSI ν™μ„±ν™”
    uint16_t control;
    pci_read_config_word(dev, pos + PCI_MSI_FLAGS, &control);
    control |= PCI_MSI_FLAGS_ENABLE;
    pci_write_config_word(dev, pos + PCI_MSI_FLAGS, control);
    
    return vector;
}
```

**MSI-Xμ ν™•μ¥ κΈ°λ¥**
```c
// MSI-X ν…μ΄λΈ” κµ¬μ΅°μ²΄
struct msix_entry {
    uint32_t msg_addr_lo;   // λ©”μ‹μ§€ μ£Όμ† ν•μ„ 32λΉ„νΈ
    uint32_t msg_addr_hi;   // λ©”μ‹μ§€ μ£Όμ† μƒμ„ 32λΉ„νΈ
    uint32_t msg_data;      // λ©”μ‹μ§€ λ°μ΄ν„°
    uint32_t vector_ctrl;   // λ²΅ν„° μ μ–΄ (λ§μ¤ν‚Ή)
};

// λ‹¤μ¤‘ MSI-X λ²΅ν„° μ„¤μ •
int setup_msix_vectors(struct pci_dev *dev, int num_vectors) {
    struct msix_entry *entries;
    int i;
    
    entries = kcalloc(num_vectors, sizeof(struct msix_entry), GFP_KERNEL);
    if (!entries) {
        return -ENOMEM;
    }
    
    // κ° λ²΅ν„°λ³„ μ„¤μ •
    for (i = 0; i < num_vectors; i++) {
        entries[i].entry = i;  // μ—”νΈλ¦¬ λ²νΈ
        entries[i].vector = alloc_msi_vector();
    }
    
    // MSI-X ν™μ„±ν™”
    int ret = pci_enable_msix(dev, entries, num_vectors);
    if (ret) {
        kfree(entries);
        return ret;
    }
    
    return 0;
}
```

### μΈν„°λ½νΈ κ°€μƒν™” μµμ ν™”

#### SR-IOV (Single Root I/O Virtualization)

**ν•λ“μ›¨μ–΄ κΈ°λ° I/O κ°€μƒν™”**
```
κµ¬μ„± μ”μ†:
- PF (Physical Function): λ¬Όλ¦¬ λ””λ°”μ΄μ¤
- VF (Virtual Function): κ°€μƒ λ””λ°”μ΄μ¤ (κ²μ¤νΈ μ „μ©)
- μ§μ ‘ ν• λ‹Ή: ν•μ΄νΌλ°”μ΄μ € μ°ν

μ¥μ :
- λ„¤μ΄ν‹°λΈ μμ¤€ μ„±λ¥
- μΈν„°λ½νΈ μ§μ ‘ μ „λ‹¬
- CPU μ¤λ²„ν—¤λ“ μµμ†ν™”
```

**SR-IOV μΈν„°λ½νΈ μ²λ¦¬**
```c
// SR-IOV VFμ μ§μ ‘ μΈν„°λ½νΈ μ²λ¦¬
void sriov_vf_interrupt_handler(void) {
    // κ²μ¤νΈ OSκ°€ μ§μ ‘ μΈν„°λ½νΈ μ²λ¦¬
    // ν•μ΄νΌλ°”μ΄μ € κ°μ… μ—†μ
    
    struct vf_device *vf = get_current_vf();
    
    // VFλ³„ λ…λ¦½μ  μ²λ¦¬
    process_vf_packets(vf);
    
    // κ²μ¤νΈμ EOIκ°€ μ§μ ‘ ν•λ“μ›¨μ–΄μ— μ „λ‹¬λ¨
    vf_send_eoi(vf);
}
```

### IoTμ™€ μ—£μ§€ μ»΄ν“¨ν…μ μΈν„°λ½νΈ

#### μ €μ „λ ¥ μΈν„°λ½νΈ κ΄€λ¦¬

**ARM Cortex-Mμ WFI (Wait For Interrupt)**
```c
// μ €μ „λ ¥ μΈν„°λ½νΈ λ€κΈ°
void low_power_interrupt_wait(void) {
    // λ¨λ“  non-critical ν΄λ΅ μ¤‘λ‹¨
    disable_peripheral_clocks();
    
    // μΈν„°λ½νΈ λ€κΈ° μƒνƒλ΅ μ§„μ…
    __asm__ volatile ("wfi");  // Wait For Interrupt
    
    // μΈν„°λ½νΈ λ°μƒ μ‹ μλ™μΌλ΅ κΉ¨μ–΄λ‚¨
    enable_peripheral_clocks();
}

// μ¬λ¦½ λ¨λ“ μΈν„°λ½νΈ μ„¤μ •
void setup_wakeup_interrupts(void) {
    // GPIO μΈν„°λ½νΈ (λ²„νΌ, μ„Όμ„)
    setup_gpio_interrupt(BUTTON_PIN, GPIO_RISING_EDGE);
    
    // RTC μΈν„°λ½νΈ (μ£ΌκΈ°μ  κΉ¨μ–΄λ‚¨)
    setup_rtc_alarm(WAKEUP_INTERVAL_SEC);
    
    // UART μΈν„°λ½νΈ (μ™Έλ¶€ ν†µμ‹ )
    setup_uart_wakeup();
}
```

#### μ‹¤μ‹κ°„ IoT μΈν„°λ½νΈ

**μ„Όμ„ λ°μ΄ν„° μ²λ¦¬**
```c
// κ³ μ† ADC μΈν„°λ½νΈ μ²λ¦¬
void __attribute__((interrupt)) adc_dma_complete_isr(void) {
    static uint16_t sensor_buffer[1024];
    static int buffer_index = 0;
    
    // DMAλ΅ μ „μ†΅λ ADC λ°μ΄ν„° μ²λ¦¬
    uint16_t adc_value = get_adc_result();
    sensor_buffer[buffer_index++] = adc_value;
    
    // λ²„νΌκ°€ κ°€λ“ μ°¬ κ²½μ°
    if (buffer_index >= 1024) {
        // μ‹ νΈ μ²λ¦¬ νƒμ¤ν¬μ— μ•λ¦Ό
        xTaskNotifyFromISR(signal_processing_task, 
                          BUFFER_READY_NOTIFICATION, 
                          eSetBits, 
                          &higher_priority_task_woken);
        buffer_index = 0;
    }
    
    // λ‹¤μ ADC λ³€ν™ μ‹μ‘
    start_next_adc_conversion();
    
    portYIELD_FROM_ISR(higher_priority_task_woken);
}
```

---

## π’» μ‹¤μ  μμ‹μ™€ ν”„λ΅κ·Έλλ°

### μ΄μμ²΄μ λ³„ μΈν„°λ½νΈ ν”„λ΅κ·Έλλ°

#### Linux μ»¤λ„ μΈν„°λ½νΈ μ²λ¦¬

**μΈν„°λ½νΈ ν•Έλ“¤λ¬ λ“±λ΅**
```c
#include <linux/interrupt.h>
#include <linux/module.h>

// μΈν„°λ½νΈ μ„λΉ„μ¤ λ£¨ν‹΄
static irqreturn_t my_interrupt_handler(int irq, void *dev_id) {
    // μΈν„°λ½νΈ μ²λ¦¬ μ½”λ“
    printk(KERN_INFO "Interrupt %d received\n", irq);
    
    // ν•λ“μ›¨μ–΄ λ μ§€μ¤ν„°μ—μ„ μƒνƒ μ½κΈ°
    uint32_t status = ioread32(device_base + STATUS_REG);
    
    if (status & TX_COMPLETE) {
        handle_tx_complete();
    }
    
    if (status & RX_READY) {
        handle_rx_ready();
    }
    
    // μΈν„°λ½νΈ ν΄λ¦¬μ–΄
    iowrite32(status, device_base + STATUS_REG);
    
    return IRQ_HANDLED;
}

// λ“λΌμ΄λ²„ μ΄κΈ°ν™”μ—μ„ μΈν„°λ½νΈ λ“±λ΅
static int __init my_driver_init(void) {
    int result;
    
    // IRQ μ”μ²­
    result = request_irq(MY_IRQ_NUMBER, 
                        my_interrupt_handler,
                        IRQF_SHARED,        // κ³µμ  κ°€λ¥ν• μΈν„°λ½νΈ
                        "my_device",        // λ””λ°”μ΄μ¤ μ΄λ¦„
                        &my_device);        // dev_id
    
    if (result) {
        printk(KERN_ERR "Cannot register IRQ %d\n", MY_IRQ_NUMBER);
        return result;
    }
    
    return 0;
}

// λ“λΌμ΄λ²„ μ •λ¦¬μ—μ„ μΈν„°λ½νΈ ν•΄μ 
static void __exit my_driver_exit(void) {
    free_irq(MY_IRQ_NUMBER, &my_device);
}
```

**κ³ μ„±λ¥ λ„¤νΈμ›ν¬ λ“λΌμ΄λ²„**
```c
// NAPI κΈ°λ° λ„¤νΈμ›ν¬ λ“λΌμ΄λ²„
struct my_net_adapter {
    struct net_device *netdev;
    struct napi_struct napi;
    void __iomem *base_addr;
    struct sk_buff_head rx_queue;
    spinlock_t lock;
};

// μΈν„°λ½νΈ ν•Έλ“¤λ¬ (NAPI μ¤μΌ€μ¤„λ§λ§)
static irqreturn_t net_interrupt_handler(int irq, void *data) {
    struct my_net_adapter *adapter = data;
    
    // μΈν„°λ½νΈ λΉ„ν™μ„±ν™”
    iowrite32(0, adapter->base_addr + INT_ENABLE_REG);
    
    // NAPI ν΄λ§ μ¤μΌ€μ¤„
    if (napi_schedule_prep(&adapter->napi)) {
        __napi_schedule(&adapter->napi);
    }
    
    return IRQ_HANDLED;
}

// NAPI ν΄λ§ ν•¨μ
static int net_napi_poll(struct napi_struct *napi, int budget) {
    struct my_net_adapter *adapter = container_of(napi, struct my_net_adapter, napi);
    int work_done = 0;
    
    // ν¨ν‚· μ²λ¦¬ (μΈν„°λ½νΈ λΉ„ν™μ„±ν™” μƒνƒ)
    while (work_done < budget) {
        struct sk_buff *skb = receive_packet(adapter);
        if (!skb) break;
        
        netif_receive_skb(skb);
        work_done++;
    }
    
    // λ¨λ“  ν¨ν‚· μ²λ¦¬ μ™„λ£ μ‹
    if (work_done < budget) {
        napi_complete(napi);
        // μΈν„°λ½νΈ μ¬ν™μ„±ν™”
        iowrite32(INT_ENABLE_MASK, adapter->base_addr + INT_ENABLE_REG);
    }
    
    return work_done;
}
```

#### Windows μ»¤λ„ μΈν„°λ½νΈ μ²λ¦¬

**WDM λ“λΌμ΄λ²„μ ISR**
```c
// Windows Driver Model ISR
BOOLEAN MyInterruptServiceRoutine(
    PKINTERRUPT Interrupt,
    PVOID ServiceContext
) {
    PMY_DEVICE_EXTENSION deviceExtension = (PMY_DEVICE_EXTENSION)ServiceContext;
    BOOLEAN interruptRecognized = FALSE;
    
    // ν•λ“μ›¨μ–΄ μƒνƒ ν™•μΈ
    ULONG status = READ_REGISTER_ULONG(&deviceExtension->Registers->Status);
    
    if (status & MY_INTERRUPT_PENDING) {
        // μΈν„°λ½νΈ ν΄λ¦¬μ–΄
        WRITE_REGISTER_ULONG(&deviceExtension->Registers->Status, status);
        
        // DPC νμ‰ (μ§€μ—°λ μ²λ¦¬)
        KeInsertQueueDpc(&deviceExtension->InterruptDpc, NULL, NULL);
        
        interruptRecognized = TRUE;
    }
    
    return interruptRecognized;
}

// DPC (Deferred Procedure Call) λ£¨ν‹΄
VOID MyDpcForIsr(
    PKDPC Dpc,
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
) {
    PMY_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    
    // μ‹κ°„μ΄ κ±Έλ¦¬λ” μ²λ¦¬ μ‘μ—…
    ProcessInterruptData(deviceExtension);
    
    // I/O μ”μ²­ μ™„λ£
    if (deviceExtension->PendingIrp) {
        IoCompleteRequest(deviceExtension->PendingIrp, IO_NO_INCREMENT);
        deviceExtension->PendingIrp = NULL;
    }
}
```

#### μ„λ² λ””λ“ μ‹μ¤ν… (FreeRTOS)

**μ‹¤μ‹κ°„ μ΄μμ²΄μ μ—μ„μ μΈν„°λ½νΈ**
```c
// FreeRTOS μΈν„°λ½νΈ ν•Έλ“¤λ¬
void USART1_IRQHandler(void) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    
    // USART μƒνƒ ν™•μΈ
    if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) {
        char received_char = USART_ReceiveData(USART1);
        
        // νμ— λ°μ΄ν„° μ „μ†΅ (ISRμ—μ„ μ•μ „ν• ν•¨μ μ‚¬μ©)
        xQueueSendFromISR(uart_rx_queue, &received_char, &xHigherPriorityTaskWoken);
        
        // μΈν„°λ½νΈ ν΄λ¦¬μ–΄
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    }
    
    // λ” λ†’μ€ μ°μ„ μμ„ νƒμ¤ν¬κ°€ κΉ¨μ–΄λ‚λ©΄ μ»¨ν…μ¤νΈ μ¤μ„μΉ­
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

// λ©”μΈ νƒμ¤ν¬μ—μ„ λ°μ΄ν„° μ²λ¦¬
void uart_processing_task(void *parameters) {
    char received_data;
    
    while (1) {
        // νμ—μ„ λ°μ΄ν„° λ€κΈ° (λΈ”λ΅ν‚Ή)
        if (xQueueReceive(uart_rx_queue, &received_data, portMAX_DELAY) == pdTRUE) {
            // μμ‹ λ λ°μ΄ν„° μ²λ¦¬
            process_uart_data(received_data);
        }
    }
}
```

### μ‚¬μ©μ κ³µκ°„μ—μ„μ μΈν„°λ½νΈ μ²λ¦¬

#### UIO (Userspace I/O) λ“λΌμ΄λ²„

**μ»¤λ„ μ°ν μΈν„°λ½νΈ μ²λ¦¬**
```c
// UIO λ“λΌμ΄λ²„ (μ»¤λ„ κ³µκ°„)
static irqreturn_t uio_interrupt_handler(int irq, struct uio_info *info) {
    // μΈν„°λ½νΈ λΉ„ν™μ„±ν™” (μ‚¬μ©μ κ³µκ°„μ—μ„ μ¬ν™μ„±ν™”)
    disable_device_interrupts(info->priv);
    
    return IRQ_HANDLED;
}

// μ‚¬μ©μ κ³µκ°„ μ• ν”λ¦¬μΌ€μ΄μ…
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    int uio_fd;
    int irq_count = 0;
    void *device_mem;
    
    // UIO λ””λ°”μ΄μ¤ μ—΄κΈ°
    uio_fd = open("/dev/uio0", O_RDWR);
    if (uio_fd < 0) {
        perror("Cannot open UIO device");
        return -1;
    }
    
    // λ””λ°”μ΄μ¤ λ©”λ¨λ¦¬ λ§¤ν•‘
    device_mem = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uio_fd, 0);
    if (device_mem == MAP_FAILED) {
        perror("Cannot mmap device memory");
        close(uio_fd);
        return -1;
    }
    
    // μΈν„°λ½νΈ ν™μ„±ν™”
    uint32_t enable = 1;
    write(uio_fd, &enable, sizeof(enable));
    
    while (1) {
        // μΈν„°λ½νΈ λ€κΈ° (λΈ”λ΅ν‚Ή)
        uint32_t pending;
        ssize_t result = read(uio_fd, &pending, sizeof(pending));
        
        if (result == sizeof(pending)) {
            printf("Interrupt received, count: %d\n", ++irq_count);
            
            // λ””λ°”μ΄μ¤ λ μ§€μ¤ν„° μ§μ ‘ μ ‘κ·Ό
            volatile uint32_t *status_reg = (volatile uint32_t*)device_mem;
            uint32_t status = *status_reg;
            
            // μΈν„°λ½νΈ μ²λ¦¬
            process_device_interrupt(status);
            
            // μΈν„°λ½νΈ μ¬ν™μ„±ν™”
            write(uio_fd, &enable, sizeof(enable));
        }
    }
    
    // μ •λ¦¬
    munmap(device_mem, 0x1000);
    close(uio_fd);
    return 0;
}
```

#### VFIO (Virtual Function I/O)

**κ°€μƒν™” ν™κ²½μ—μ„μ μ§μ ‘ μΈν„°λ½νΈ μ²λ¦¬**
```c
// VFIOλ¥Ό μ΄μ©ν• λ””λ°”μ΄μ¤ μ§μ ‘ μ ‘κ·Ό
#include <linux/vfio.h>

int setup_vfio_interrupts(int device_fd) {
    struct vfio_irq_info irq_info = {
        .argsz = sizeof(irq_info),
        .index = VFIO_PCI_MSI_IRQ_INDEX
    };
    
    // μΈν„°λ½νΈ μ •λ³΄ μ΅°ν
    if (ioctl(device_fd, VFIO_DEVICE_GET_IRQ_INFO, &irq_info) < 0) {
        perror("Cannot get IRQ info");
        return -1;
    }
    
    // μ΄λ²¤νΈ νμΌ λ””μ¤ν¬λ¦½ν„° μƒμ„±
    int eventfd = eventfd(0, EFD_CLOEXEC);
    if (eventfd < 0) {
        perror("Cannot create eventfd");
        return -1;
    }
    
    // μΈν„°λ½νΈμ™€ eventfd μ—°κ²°
    struct vfio_irq_set *irq_set;
    size_t irq_set_size = sizeof(*irq_set) + sizeof(int);
    irq_set = malloc(irq_set_size);
    
    irq_set->argsz = irq_set_size;
    irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER;
    irq_set->index = VFIO_PCI_MSI_IRQ_INDEX;
    irq_set->start = 0;
    irq_set->count = 1;
    *(int*)irq_set->data = eventfd;
    
    if (ioctl(device_fd, VFIO_DEVICE_SET_IRQS, irq_set) < 0) {
        perror("Cannot set IRQ");
        free(irq_set);
        close(eventfd);
        return -1;
    }
    
    free(irq_set);
    return eventfd;
}

// μΈν„°λ½νΈ μ²λ¦¬ λ£¨ν”„
void interrupt_handling_loop(int eventfd, volatile void *device_mmio) {
    struct pollfd pfd = {
        .fd = eventfd,
        .events = POLLIN
    };
    
    while (1) {
        // μΈν„°λ½νΈ λ€κΈ°
        int ret = poll(&pfd, 1, -1);
        if (ret > 0 && (pfd.revents & POLLIN)) {
            uint64_t event_count;
            read(eventfd, &event_count, sizeof(event_count));
            
            // λ””λ°”μ΄μ¤ μƒνƒ ν™•μΈ
            uint32_t status = *(volatile uint32_t*)(device_mmio + STATUS_OFFSET);
            
            // μΈν„°λ½νΈ μ²λ¦¬
            if (status & RX_READY) {
                handle_rx_interrupt(device_mmio);
            }
            
            if (status & TX_COMPLETE) {
                handle_tx_interrupt(device_mmio);
            }
            
            // μƒνƒ ν΄λ¦¬μ–΄
            *(volatile uint32_t*)(device_mmio + STATUS_OFFSET) = status;
        }
    }
}
```

### μ„±λ¥ λ²¤μΉλ§ν‚Ήκ³Ό μµμ ν™”

#### μΈν„°λ½νΈ μ§€μ—°μ‹κ°„ μΈ΅μ •

**μ •λ°€ν• νƒ€μ΄λ° μΈ΅μ •**
```c
// ν•λ“μ›¨μ–΄ νƒ€μ΄λ¨Έλ¥Ό μ΄μ©ν• μ§€μ—°μ‹κ°„ μΈ΅μ •
struct interrupt_latency_stats {
    uint64_t min_latency;
    uint64_t max_latency;
    uint64_t total_latency;
    uint64_t sample_count;
    uint64_t histogram[100];  // μ§€μ—°μ‹κ°„ νμ¤ν† κ·Έλ¨
};

static struct interrupt_latency_stats latency_stats;
static uint64_t interrupt_start_time;

// μ™Έλ¶€ μ‹ νΈμ™€ λ™κΈ°ν™”λ νƒ€μ΄λ° μΈ΅μ •
void __attribute__((interrupt)) timing_test_isr(void) {
    uint64_t current_time = read_tsc();  // Time Stamp Counter
    uint64_t latency = current_time - interrupt_start_time;
    
    // ν†µκ³„ μ—…λ°μ΄νΈ
    latency_stats.sample_count++;
    latency_stats.total_latency += latency;
    
    if (latency < latency_stats.min_latency || latency_stats.sample_count == 1) {
        latency_stats.min_latency = latency;
    }
    
    if (latency > latency_stats.max_latency) {
        latency_stats.max_latency = latency;
    }
    
    // νμ¤ν† κ·Έλ¨ μ—…λ°μ΄νΈ (λ§μ΄ν¬λ΅μ΄ λ‹¨μ„)
    uint64_t latency_us = latency / cpu_freq_mhz;
    if (latency_us < 100) {
        latency_stats.histogram[latency_us]++;
    }
    
    // μ‹¤μ  μΈν„°λ½νΈ μ²λ¦¬
    handle_test_interrupt();
    send_eoi();
}

// μ™Έλ¶€ μ‹ νΈ μƒμ„±κΈ°μ™€ λ™κΈ°ν™”
void trigger_test_interrupt(void) {
    interrupt_start_time = read_tsc();
    // μ™Έλ¶€ ν•λ“μ›¨μ–΄μ— μΈν„°λ½νΈ νΈλ¦¬κ±° μ‹ νΈ μ „μ†΅
    trigger_external_interrupt();
}
```

**μ„±λ¥ ν”„λ΅νμΌλ§**
```c
// μΈν„°λ½νΈ ν•Έλ“¤λ¬λ³„ μ„±λ¥ ν†µκ³„
struct isr_performance_stats {
    const char *name;
    uint64_t call_count;
    uint64_t total_cycles;
    uint64_t max_cycles;
    uint64_t cache_misses;
};

#define MAX_ISRS 256
static struct isr_performance_stats isr_stats[MAX_ISRS];

// μ„±λ¥ μΈ΅μ • λνΌ
#define MEASURE_ISR_PERFORMANCE(isr_id, handler_func) \
do { \
    uint64_t start_cycles = read_tsc(); \
    uint64_t start_cache_misses = read_cache_miss_counter(); \
    \
    handler_func(); \
    \
    uint64_t end_cycles = read_tsc(); \
    uint64_t end_cache_misses = read_cache_miss_counter(); \
    \
    uint64_t elapsed = end_cycles - start_cycles; \
    isr_stats[isr_id].call_count++; \
    isr_stats[isr_id].total_cycles += elapsed; \
    isr_stats[isr_id].cache_misses += (end_cache_misses - start_cache_misses); \
    \
    if (elapsed > isr_stats[isr_id].max_cycles) { \
        isr_stats[isr_id].max_cycles = elapsed; \
    } \
} while(0)

// μ„±λ¥ ν†µκ³„ μ¶λ ¥
void print_isr_performance_stats(void) {
    printf("ISR Performance Statistics:\n");
    printf("%-20s %10s %15s %15s %15s\n", 
           "Handler", "Count", "Avg Cycles", "Max Cycles", "Cache Misses");
    
    for (int i = 0; i < MAX_ISRS; i++) {
        if (isr_stats[i].call_count > 0) {
            uint64_t avg_cycles = isr_stats[i].total_cycles / isr_stats[i].call_count;
            printf("%-20s %10lu %15lu %15lu %15lu\n",
                   isr_stats[i].name,
                   isr_stats[i].call_count,
                   avg_cycles,
                   isr_stats[i].max_cycles,
                   isr_stats[i].cache_misses);
        }
    }
}
```

### λ””λ²„κΉ… λ„κµ¬μ™€ κΈ°λ²•

#### μΈν„°λ½νΈ λ””λ²„κΉ… κΈ°λ²•

**μ†ν”„νΈμ›¨μ–΄ νΈλ μ΄μ‹±**
```c
// μΈν„°λ½νΈ νΈλ μ΄μ¤ λ΅κΉ…
#define TRACE_BUFFER_SIZE 10000

struct interrupt_trace_entry {
    uint64_t timestamp;
    uint16_t irq_number;
    uint16_t cpu_id;
    uint32_t context;      // μΈν„°λ½νΈ λ°μƒ μ‹ μ»¨ν…μ¤νΈ
    uint32_t duration;     // μ²λ¦¬ μ‹κ°„ (μ‚¬μ΄ν΄)
};

static struct interrupt_trace_entry trace_buffer[TRACE_BUFFER_SIZE];
static volatile int trace_index = 0;

// μΈν„°λ½νΈ μ§„μ… μ‹ νΈλ μ΄μ¤
void trace_interrupt_entry(int irq) {
    int idx = __sync_fetch_and_add(&trace_index, 1) % TRACE_BUFFER_SIZE;
    
    trace_buffer[idx].timestamp = read_tsc();
    trace_buffer[idx].irq_number = irq;
    trace_buffer[idx].cpu_id = smp_processor_id();
    trace_buffer[idx].context = read_context_info();
    trace_buffer[idx].duration = 0;  // μ§„μ… μ‹μ—λ” 0
}

// μΈν„°λ½νΈ μΆ…λ£ μ‹ νΈλ μ΄μ¤
void trace_interrupt_exit(int irq) {
    // μµκ·Ό κ°™μ€ IRQμ μ—”νΈλ¦¬ μ°ΎκΈ°
    int current_idx = (trace_index - 1) % TRACE_BUFFER_SIZE;
    
    if (trace_buffer[current_idx].irq_number == irq && 
        trace_buffer[current_idx].duration == 0) {
        trace_buffer[current_idx].duration = 
            read_tsc() - trace_buffer[current_idx].timestamp;
    }
}

// νΈλ μ΄μ¤ λ¶„μ„
void analyze_interrupt_traces(void) {
    printf("Recent interrupt activity:\n");
    
    for (int i = 0; i < TRACE_BUFFER_SIZE; i++) {
        int idx = (trace_index + i) % TRACE_BUFFER_SIZE;
        struct interrupt_trace_entry *entry = &trace_buffer[idx];
        
        if (entry->timestamp != 0) {
            printf("IRQ %3d CPU %d Time %12lu Duration %8u Context 0x%08x\n",
                   entry->irq_number,
                   entry->cpu_id,
                   entry->timestamp,
                   entry->duration,
                   entry->context);
        }
    }
}
```

**ν•λ“μ›¨μ–΄ λ””λ²„κΉ… μ§€μ›**
```c
// JTAG/SWDλ¥Ό ν†µν• μ‹¤μ‹κ°„ μΈν„°λ½νΈ λ¨λ‹ν„°λ§
void setup_interrupt_debug_monitoring(void) {
    // DWT (Data Watchpoint and Trace) μ„¤μ •
    CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
    
    // μ‚¬μ΄ν΄ μΉ΄μ΄ν„° ν™μ„±ν™”
    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
    
    // PC μƒν”λ§ ν™μ„±ν™” (μΈν„°λ½νΈ μ„μΉ μ¶”μ )
    ITM->TCR |= ITM_TCR_ITMENA_Msk;
    ITM->TER |= (1UL << 0);  // μ±„λ„ 0 ν™μ„±ν™”
}

// μ‹¤μ‹κ°„ μΈν„°λ½νΈ μƒνƒ μ¶λ ¥ (λ””λ²„κ±° μ½μ†”)
void debug_print_interrupt_state(void) {
    uint32_t active_interrupts = NVIC->IABR[0];  // ν™μ„± μΈν„°λ½νΈ
    uint32_t pending_interrupts = NVIC->ISPR[0]; // λ€κΈ° μΈν„°λ½νΈ
    
    // ITMμ„ ν†µν•΄ λ””λ²„κ±°λ΅ μ „μ†΅
    ITM_SendChar('I');  // μΈν„°λ½νΈ μƒνƒ λ§μ»¤
    ITM_SendChar((active_interrupts >> 24) & 0xFF);
    ITM_SendChar((active_interrupts >> 16) & 0xFF);
    ITM_SendChar((active_interrupts >> 8) & 0xFF);
    ITM_SendChar(active_interrupts & 0xFF);
}
```

---

## π“ μ¤ν„°λ”” νκ³Ό μ΄μ •λ¦¬

### ν•™μµ λ‹¨κ³„λ³„ μ²΄ν¬λ¦¬μ¤νΈ

#### πΆ κΈ°μ΄ λ‹¨κ³„ (ν•„μ μ΄ν•΄)
```
β–΅ μΈν„°λ½νΈμ κΈ°λ³Έ κ°λ…κ³Ό ν•„μ”μ„± μ΄ν•΄
β–΅ μΈν„°λ½νΈ vs ν΄λ§ λ°©μ‹μ μ°¨μ΄μ  μ„¤λ… κ°€λ¥
β–΅ ν•λ“μ›¨μ–΄ μΈν„°λ½νΈ vs μ†ν”„νΈμ›¨μ–΄ μΈν„°λ½νΈ κµ¬λ¶„
β–΅ μΈν„°λ½νΈ λ°μƒλ¶€ν„° μ²λ¦¬κΉμ§€μ κΈ°λ³Έ κ³Όμ • 4λ‹¨κ³„ μ•”κΈ°
β–΅ λ§μ¤μ»¤λΈ” vs λ…Όλ§μ¤μ»¤λΈ” μΈν„°λ½νΈ μ°¨μ΄μ  μ΄ν•΄
β–΅ κΈ°λ³Έμ μΈ μ°μ„ μμ„ κ°λ… μ΄ν•΄
```

#### π΅ μ¤‘κΈ‰ λ‹¨κ³„ (μ‹¬ν™” μ΄ν•΄)
```
β–΅ μΈν„°λ½νΈ λ²΅ν„° ν…μ΄λΈ”μ κµ¬μ΅°μ™€ λ™μ‘ μ›λ¦¬ μ΄ν•΄
β–΅ μ»¨ν…μ¤νΈ μ¤μ„μΉ­μ μƒμ„Έ κ³Όμ • μ„¤λ… κ°€λ¥
β–΅ ISR μ‘μ„± μ‹ μ£Όμμ‚¬ν•­κ³Ό μµμ ν™” κΈ°λ²• μ™μ§€
β–΅ μΈν„°λ½νΈ μ¤‘μ²©κ³Ό μ„ μ μ— λ€ν• μ΄ν•΄
β–΅ μμ™Έ, νΈλ©κ³Όμ μ°¨μ΄μ  λ…ν™•ν κµ¬λ¶„
β–΅ PIC/APIC λ“± μΈν„°λ½νΈ μ»¨νΈλ΅¤λ¬ λ™μ‘ μ›λ¦¬ μ΄ν•΄
β–΅ κ°„λ‹¨ν• ISR μ½”λ“ μ‘μ„± λ° λ¶„μ„ κ°€λ¥
```

#### π”΄ κ³ κΈ‰ λ‹¨κ³„ (μ „λ¬Έκ°€ μμ¤€)
```
β–΅ μ•„ν‚¤ν…μ²λ³„ μΈν„°λ½νΈ κµ¬ν„ μ°¨μ΄μ  μ΄ν•΄ (x86, ARM, RISC-V)
β–΅ MSI/MSI-Xμ μ¥μ κ³Ό κµ¬ν„ λ°©μ‹ μ΄ν•΄
β–΅ κ°€μƒν™” ν™κ²½μ—μ„μ μΈν„°λ½νΈ μ²λ¦¬ λ©”μ»¤λ‹μ¦
β–΅ μ‹¤μ‹κ°„ μ‹μ¤ν…μ—μ„μ μΈν„°λ½νΈ μ μ•½μ‚¬ν•­κ³Ό ν•΄κ²°μ±…
β–΅ μ„±λ¥ μµμ ν™” κΈ°λ²• (NAPI, μΈν„°λ½νΈ ν†µν•© λ“±) μ μ© κ°€λ¥
β–΅ λ©€ν‹°μ½”μ–΄ ν™κ²½μ—μ„μ μΈν„°λ½νΈ λ¶„μ‚°κ³Ό μΉν™”μ„± κ΄€λ¦¬
β–΅ κ³ μ„±λ¥ λ“λΌμ΄λ²„ κ°λ° μ‹ μΈν„°λ½νΈ μµμ ν™” μ„¤κ³„ κ°€λ¥
```

### μ‹¤μµ ν”„λ΅μ νΈ μ¶”μ²

#### π”° μ΄κΈ‰ ν”„λ΅μ νΈ

**1. νƒ€μ΄λ¨Έ μΈν„°λ½νΈ κΈ°λ° LED κΉλΉ΅μ΄κΈ°**
```c
// Arduino/AVR κΈ°λ° κ°„λ‹¨ν• νƒ€μ΄λ¨Έ μΈν„°λ½νΈ
#include <avr/interrupt.h>

volatile int led_state = 0;

// νƒ€μ΄λ¨Έ1 μ¤λ²„ν”λ΅μ° μΈν„°λ½νΈ (μ•½ 1μ΄λ§λ‹¤)
ISR(TIMER1_OVF_vect) {
    led_state = !led_state;
    digitalWrite(13, led_state);
    
    // νƒ€μ΄λ¨Έ μ¬μ„¤μ •
    TCNT1 = 34286;  // 1μ΄ μ£ΌκΈ°λ¥Ό μ„ν• μ΄κΈ°κ°’
}

void setup() {
    pinMode(13, OUTPUT);
    
    // νƒ€μ΄λ¨Έ1 μ„¤μ •
    TCCR1A = 0;
    TCCR1B = (1 << CS12) | (1 << CS10);  // 1024 λ¶„μ£Ό
    TCNT1 = 34286;
    TIMSK1 = (1 << TOIE1);  // μ¤λ²„ν”λ΅μ° μΈν„°λ½νΈ ν™μ„±ν™”
    
    sei();  // μ „μ—­ μΈν„°λ½νΈ ν™μ„±ν™”
}

void loop() {
    // λ©”μΈ λ£¨ν”„λ” λ‹¤λ¥Έ μ‘μ—… μν–‰ κ°€λ¥
    // μΈν„°λ½νΈκ°€ LEDλ¥Ό μλ™μΌλ΅ μ μ–΄
}
```

**2. μ™Έλ¶€ μΈν„°λ½νΈλ¥Ό μ΄μ©ν• μΉ΄μ΄ν„°**
```c
// λ²„νΌ λ„λ¦„ κ°μ§€ μΈν„°λ½νΈ
volatile int button_count = 0;

ISR(INT0_vect) {
    // λ””λ°”μ΄μ‹±μ„ μ„ν• κ°„λ‹¨ν• μ§€μ—°
    _delay_ms(50);
    
    if (!(PIND & (1 << PD2))) {  // λ²„νΌμ΄ μ—¬μ „ν λλ ¤μμΌλ©΄
        button_count++;
        Serial.println(button_count);
    }
}

void setup() {
    Serial.begin(9600);
    
    // INT0 (PD2) μ„¤μ •
    DDRD &= ~(1 << PD2);   // μ…λ ¥μΌλ΅ μ„¤μ •
    PORTD |= (1 << PD2);   // ν’€μ—… μ €ν•­ ν™μ„±ν™”
    
    // μ™Έλ¶€ μΈν„°λ½νΈ μ„¤μ • (ν•κ°• μ—£μ§€)
    EICRA |= (1 << ISC01);
    EIMSK |= (1 << INT0);
    
    sei();
}
```

#### π”„ μ¤‘κΈ‰ ν”„λ΅μ νΈ

**3. UART μΈν„°λ½νΈ κΈ°λ° μ‹λ¦¬μ–Ό ν†µμ‹ **
```c
#define BUFFER_SIZE 128

volatile char rx_buffer[BUFFER_SIZE];
volatile int rx_head = 0;
volatile int rx_tail = 0;

// UART μμ‹  μ™„λ£ μΈν„°λ½νΈ
ISR(USART_RX_vect) {
    char received_byte = UDR0;
    
    int next_head = (rx_head + 1) % BUFFER_SIZE;
    
    // λ²„νΌ μ¤λ²„ν”λ΅μ° μ²΄ν¬
    if (next_head != rx_tail) {
        rx_buffer[rx_head] = received_byte;
        rx_head = next_head;
    }
}

// λ²„νΌμ—μ„ λ¬Έμ μ½κΈ° (λ…ΌλΈ”λ΅ν‚Ή)
int uart_getchar(void) {
    if (rx_head == rx_tail) {
        return -1;  // λ²„νΌ λΉ„μ–΄μμ
    }
    
    char c = rx_buffer[rx_tail];
    rx_tail = (rx_tail + 1) % BUFFER_SIZE;
    
    return c;
}

void setup_uart_interrupt(void) {
    // UART μ„¤μ • (9600 bps)
    UBRR0H = 0;
    UBRR0L = 103;  // 16MHzμ—μ„ 9600bps
    
    UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
    UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);  // 8λΉ„νΈ λ°μ΄ν„°
    
    sei();
}
```

**4. ADC μΈν„°λ½νΈ κΈ°λ° μ„Όμ„ λ°μ΄ν„° μμ§‘**
```c
#define SAMPLES_PER_SECOND 1000
#define SAMPLE_BUFFER_SIZE 100

volatile uint16_t adc_samples[SAMPLE_BUFFER_SIZE];
volatile int sample_index = 0;
volatile bool buffer_ready = false;

// ADC λ³€ν™ μ™„λ£ μΈν„°λ½νΈ
ISR(ADC_vect) {
    uint16_t adc_value = ADCL | (ADCH << 8);
    
    adc_samples[sample_index++] = adc_value;
    
    if (sample_index >= SAMPLE_BUFFER_SIZE) {
        sample_index = 0;
        buffer_ready = true;
    }
    
    // λ‹¤μ λ³€ν™ μ‹μ‘
    ADCSRA |= (1 << ADSC);
}

void setup_adc_interrupt(void) {
    // ADC κΈ°μ¤€ μ „μ••: AVCC
    ADMUX = (1 << REFS0);
    
    // ADC ν™μ„±ν™”, μΈν„°λ½νΈ ν™μ„±ν™”, 128 λ¶„μ£Ό
    ADCSRA = (1 << ADEN) | (1 << ADIE) | (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);
    
    // μ²« λ³€ν™ μ‹μ‘
    ADCSRA |= (1 << ADSC);
    
    sei();
}

void process_samples(void) {
    if (buffer_ready) {
        // μƒν” λ²„νΌ μ²λ¦¬
        uint32_t sum = 0;
        for (int i = 0; i < SAMPLE_BUFFER_SIZE; i++) {
            sum += adc_samples[i];
        }
        
        uint16_t average = sum / SAMPLE_BUFFER_SIZE;
        Serial.print("Average ADC: ");
        Serial.println(average);
        
        buffer_ready = false;
    }
}
```

#### π€ κ³ κΈ‰ ν”„λ΅μ νΈ

**5. λ©€ν‹°μ±„λ„ PWM μ μ–΄ μ‹μ¤ν…**
```c
// λ³µμ νƒ€μ΄λ¨Έλ¥Ό μ΄μ©ν• μ •λ°€ PWM μ μ–΄
struct pwm_channel {
    volatile uint8_t *port;
    uint8_t pin;
    uint16_t duty_cycle;    // 0-1000 (0.1% λ‹¨μ„)
    uint16_t period;        // PWM μ£ΌκΈ° (ΞΌs)
    uint16_t counter;
};

#define PWM_CHANNELS 4
volatile struct pwm_channel pwm_channels[PWM_CHANNELS];

// κ³ ν•΄μƒλ„ νƒ€μ΄λ¨Έ μΈν„°λ½νΈ (10kHz)
ISR(TIMER2_COMPA_vect) {
    static uint16_t master_counter = 0;
    master_counter++;
    
    for (int i = 0; i < PWM_CHANNELS; i++) {
        struct pwm_channel *ch = &pwm_channels[i];
        
        if (master_counter % (ch->period / 100) == 0) {
            ch->counter = 0;
            *(ch->port) |= (1 << ch->pin);  // HIGH
        }
        
        if (ch->counter == (ch->duty_cycle * ch->period / 100000)) {
            *(ch->port) &= ~(1 << ch->pin); // LOW
        }
        
        ch->counter++;
    }
}
```

**6. μ‹¤μ‹κ°„ μ¤μ‹¤λ΅μ¤μ½”ν”„ (μΈν„°λ½νΈ κΈ°λ°)**
```c
// κ³ μ† μƒν”λ§ λ° μ‹¤μ‹κ°„ λ””μ¤ν”λ μ΄
#define SAMPLE_RATE_HZ 100000  // 100kHz μƒν”λ§
#define DISPLAY_WIDTH 320
#define TRIGGER_LEVEL 512

volatile uint16_t sample_buffer[DISPLAY_WIDTH * 2];  // λ”λΈ” λ²„νΌλ§
volatile int active_buffer = 0;
volatile int sample_count = 0;
volatile bool trigger_found = false;

// κ³ μ† ADC μƒν”λ§ μΈν„°λ½νΈ
ISR(TIMER1_COMPA_vect) {
    // ν„μ¬ ν™μ„± λ²„νΌμ— μƒν” μ €μ¥
    uint16_t *buffer = (uint16_t*)sample_buffer + (active_buffer * DISPLAY_WIDTH);
    
    // ADC λ³€ν™ μ‹μ‘ λ° κ²°κ³Ό μ½κΈ° (λ™μ‹ μ§„ν–‰)
    ADCSRA |= (1 << ADSC);
    while (ADCSRA & (1 << ADSC));  // λ³€ν™ λ€κΈ°
    uint16_t sample = ADCL | (ADCH << 8);
    
    // νΈλ¦¬κ±° κ²€μ¶
    if (!trigger_found && sample_count > 0) {
        if (buffer[sample_count - 1] < TRIGGER_LEVEL && sample >= TRIGGER_LEVEL) {
            trigger_found = true;
            sample_count = 0;  // νΈλ¦¬κ±° μ§€μ λ¶€ν„° λ‹¤μ‹ μ‹μ‘
        }
    }
    
    if (trigger_found) {
        buffer[sample_count++] = sample;
        
        if (sample_count >= DISPLAY_WIDTH) {
            // λ²„νΌ μ¤μ„μΉ­
            active_buffer = 1 - active_buffer;
            sample_count = 0;
            trigger_found = false;
            
            // λ©”μΈ λ£¨ν”„μ— λ””μ¤ν”λ μ΄ μ—…λ°μ΄νΈ μ‹ νΈ
            set_display_update_flag();
        }
    }
}
```

### λ¬Έμ  ν•΄κ²° κ°€μ΄λ“

#### μΌλ°μ μΈ μΈν„°λ½νΈ λ²„κ·Έλ“¤

**1. μΈν„°λ½νΈμ—μ„ λΈ”λ΅ν‚Ή ν•¨μ νΈμ¶**
```c
// β μλ»λ μμ‹
void timer_isr(void) {
    printf("Timer interrupt\n");  // λΈ”λ΅ν‚Ή κ°€λ¥
    delay(100);                   // μ λ€ κΈμ§€!
    malloc(1024);                 // μ„ν—ν•¨
}

// β… μ¬λ°”λ¥Έ μμ‹  
void timer_isr(void) {
    timer_flag = true;           // ν”λκ·Έλ§ μ„¤μ •
    increment_counter();         // λΉ λ¥Έ μ²λ¦¬λ§
}

void main_loop(void) {
    if (timer_flag) {
        timer_flag = false;
        printf("Timer fired\n");  // λ©”μΈ λ£¨ν”„μ—μ„ μ²λ¦¬
    }
}
```

**2. κ³µμ  λ³€μ λ³΄νΈ μ‹¤ν¨**
```c
// β μ„ν—ν• μ½”λ“
volatile int shared_counter = 0;

void timer_isr(void) {
    shared_counter++;  // 32λΉ„νΈ μ¦κ°€λ” μ›μμ μ΄μ§€ μ•μ„ μ μμ
}

void main_function(void) {
    int local_copy = shared_counter;  // μ¤‘κ°„μ— μΈν„°λ½νΈ λ°μƒ μ‹ λ¬Έμ 
    printf("Counter: %d\n", local_copy);
}

// β… μ•μ „ν• μ½”λ“
void main_function(void) {
    cli();  // μΈν„°λ½νΈ λΉ„ν™μ„±ν™”
    int local_copy = shared_counter;
    sei();  // μΈν„°λ½νΈ μ¬ν™μ„±ν™”
    printf("Counter: %d\n", local_copy);
}
```

**3. μΈν„°λ½νΈ λ¬΄ν• λ£¨ν”„**
```c
// β EOI λ„λ½μΌλ΅ μΈν• λ¬Έμ 
void network_isr(void) {
    process_packets();
    // EOI μ „μ†΅ λ„λ½! β†’ μΈν„°λ½νΈκ°€ κ³„μ† λ€κΈ° μƒνƒ
}

// β… μ¬λ°”λ¥Έ EOI μ²λ¦¬
void network_isr(void) {
    process_packets();
    send_eoi_to_pic();  // λ°λ“μ‹ EOI μ „μ†΅
}
```

### μµμΆ… μ •λ¦¬: μΈν„°λ½νΈ λ§μ¤ν„°ν•κΈ°

#### π― ν•µμ‹¬ ν¬μΈνΈ μ”μ•½

**1. μΈν„°λ½νΈμ λ³Έμ§**
- **λΉ„λ™κΈ°μ„±**: μμΈ΅ λ¶κ°€λ¥ν• μ‹μ μ— λ°μƒ
- **μ°μ„ μμ„**: μ¤‘μ”λ„μ— λ”°λ¥Έ μ²λ¦¬ μμ„
- **ν¬λ…μ„±**: μ›λ ν”„λ΅κ·Έλ¨μ— μν–¥ μ—†μ
- **ν¨μ¨μ„±**: CPU μμ›μ μµμ  ν™μ©

**2. μ²λ¦¬ λ©”μ»¤λ‹μ¦μ ν•µμ‹¬**
- **μ»¨ν…μ¤νΈ λ³΄μ΅΄**: μ™„λ²½ν• μƒνƒ μ €μ¥/λ³µμ›
- **λΉ λ¥Έ μ²λ¦¬**: μµμ†ν•μ ISR μ‹¤ν–‰ μ‹κ°„
- **μ•μ „μ„±**: κ³µμ  μμ›μ λ³΄νΈ
- **ν™•μ¥μ„±**: λ©€ν‹°μ½”μ–΄/κ°€μƒν™” ν™κ²½ μ§€μ›

**3. μ„±λ¥ μµμ ν™”μ μ—΄μ‡ **
- **μΈν„°λ½νΈ ν†µν•©**: μ—¬λ¬ μ΄λ²¤νΈ μΌκ΄„ μ²λ¦¬
- **μƒ/ν•λ°λ¶€ λ¶„λ¦¬**: κΈ΄κΈ‰/λΉ„κΈ΄κΈ‰ μ‘μ—… κµ¬λ¶„
- **μΉν™”μ„± κ΄€λ¦¬**: CPUλ³„ μΈν„°λ½νΈ λ¶„μ‚°
- **μΊμ‹ ν¨μ¨μ„±**: λ©”λ¨λ¦¬ μ ‘κ·Ό ν¨ν„΄ μµμ ν™”

#### π“– μ¶”μ² ν•™μµ μλ£

**π“ ν•„μ λ„μ„**
- "Understanding the Linux Kernel" - Daniel P. Bovet
- "Computer Systems: A Programmer's Perspective" - Bryant & O'Hallaron  
- "ARM System Developer's Guide" - Andrew Sloss
- "Intel 64 and IA-32 Architectures Software Developer's Manual"

**π μ¨λΌμΈ λ¦¬μ†μ¤**
- Linux Kernel Source Code (github.com/torvalds/linux)
- OSDev Wiki (wiki.osdev.org)
- ARM Developer Documentation
- Intel Architecture Manuals

**π› οΈ μ‹¤μµ λ„κµ¬**
- **QEMU**: λ‹¤μ–‘ν• μ•„ν‚¤ν…μ² μ—λ®¬λ μ΄μ…
- **Bochs**: x86 μ‹μ¤ν… μ‹λ®¬λ μ΄μ…  
- **GDB**: μ»¤λ„ μμ¤€ λ””λ²„κΉ…
- **Wireshark**: λ„¤νΈμ›ν¬ μΈν„°λ½νΈ λ¶„μ„
- **perf**: Linux μ„±λ¥ ν”„λ΅νμΌλ§

#### π€ ν•™μµ λ΅λ“λ§µ

**1λ‹¨κ³„: κΈ°μ΄ λ‹¤μ§€κΈ° (2-4μ£Ό)**
- μΈν„°λ½νΈ κΈ°λ³Έ κ°λ… μ΄ν•΄
- κ°„λ‹¨ν• ISR μ‘μ„± μ—°μµ
- μ•„λ‘μ΄λ…Έ/AVRλ΅ μ‹¤μµ

**2λ‹¨κ³„: μ‹¬ν™” ν•™μµ (4-8μ£Ό)**  
- μ΄μμ²΄μ  μΈν„°λ½νΈ μ²λ¦¬ λ¶„μ„
- Linux μ»¤λ„ λ“λΌμ΄λ²„ λ¶„μ„
- μ„±λ¥ μΈ΅μ • λ° μµμ ν™”

**3λ‹¨κ³„: μ „λ¬Έκ°€ κ³Όμ • (8-12μ£Ό)**
- μ‹¤μ‹κ°„ μ‹μ¤ν… μ„¤κ³„
- κ°€μƒν™” ν™κ²½ μΈν„°λ½νΈ
- κ³ μ„±λ¥ μ‹μ¤ν… κ°λ°

**4λ‹¨κ³„: λ§μ¤ν„° λ λ²¨ (μ§€μ†μ )**
- μµμ‹  κΈ°μ  νΈλ λ“ μ¶”μ 
- μ»¤λ®¤λ‹ν‹° κΈ°μ—¬ (μ¤ν”μ†μ¤)
- μ—°κµ¬ λ° νμ‹ 

---
