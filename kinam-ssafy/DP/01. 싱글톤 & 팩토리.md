# 싱글톤 & 팩토리 패턴

## 들어가기 전 알아야 할 개념

| 개념 | 설명 |
|------|------|
| **디자인 패턴** | 소프트웨어 설계에서 반복되는 문제의 검증된 해결책 |
| **인스턴스** | 클래스로부터 생성된 실제 객체 |
| **생성자** | 객체를 생성할 때 호출되는 특별한 메서드 |
| **캡슐화** | 데이터와 메서드를 하나로 묶고 외부 접근을 제한 |

---

## 1. 싱글톤 패턴 (Singleton Pattern)

### 1.1 정의

**정의**: 클래스의 인스턴스가 오직 하나만 존재하도록 보장하고, 전역적인 접근점을 제공하는 패턴

**목적**:
- 시스템 전체에서 단 하나의 객체만 존재
- 전역 상태 관리
- 리소스 공유

---

### 1.2 핵심 구성 요소

| 요소 | 설명 | 역할 |
|------|------|------|
| **private 생성자** | 외부에서 new로 생성 불가 | 인스턴스 생성 통제 |
| **private static 인스턴스** | 클래스 내부에서 유일한 인스턴스 보관 | 단일 객체 보관 |
| **public static 메서드** | 인스턴스에 접근하는 공개 메서드 | 전역 접근점 제공 |

```
싱글톤 구조:

┌─────────────────────────┐
│   Singleton Class       │
├─────────────────────────┤
│ - instance (static)     │ ← 유일한 인스턴스
│ - Singleton()           │ ← private 생성자
├─────────────────────────┤
│ + getInstance() (static)│ ← 접근 메서드
└─────────────────────────┘
         ↑
         │ 항상 같은 객체 반환
         │
    [Client Code]
```

---

### 1.3 싱글톤 구현 방식

| 구현 방식 | 특징 | 장점 | 단점 |
|----------|------|------|------|
| **Eager Initialization** | 클래스 로딩 시점에 인스턴스 생성 | 구현 간단, 스레드 안전 | 사용 안 해도 메모리 차지 |
| **Lazy Initialization** | 최초 호출 시점에 인스턴스 생성 | 메모리 효율적 | 멀티스레드 환경에서 문제 |
| **Thread-Safe** | 동기화로 스레드 안전 보장 | 스레드 안전 | 성능 저하 (동기화 오버헤드) |
| **Double-Checked Locking** | 동기화 최소화 | 성능 향상 | 구현 복잡 |
| **Bill Pugh Solution** | Static inner class 활용 | 지연 로딩 + 스레드 안전 | - |
| **Enum** | Enum으로 구현 | 직렬화 안전, 리플렉션 방어 | Enum만 사용 가능 |

```
구현 방식 비교:

1. Eager (즉시 생성)
   클래스 로딩 → 인스턴스 생성 → getInstance() 호출 → 기존 인스턴스 반환

2. Lazy (지연 생성)
   클래스 로딩 → getInstance() 호출 → 인스턴스 생성 → 반환
   
3. Thread-Safe (동기화)
   클래스 로딩 → getInstance() 호출 → [Lock] → 인스턴스 확인/생성 → [Unlock] → 반환
```

---

### 1.4 싱글톤의 장단점

| 구분 | 내용 |
|------|------|
| **장점** | • 메모리 절약 (단일 인스턴스)<br>• 전역 접근 가능<br>• 인스턴스 생성 시점 제어 가능 |
| **단점** | • 전역 상태로 인한 결합도 증가<br>• 테스트 어려움 (Mock 객체 주입 곤란)<br>• 멀티스레드 환경 처리 복잡<br>• 단일 책임 원칙 위반 가능 |

---

### 1.5 싱글톤 사용 예시

| 사용처 | 이유 |
|--------|------|
| **설정 관리자** | 시스템 전체에서 동일한 설정 사용 |
| **로거** | 모든 곳에서 같은 로그 파일에 기록 |
| **데이터베이스 연결 풀** | 한정된 커넥션 리소스 관리 |
| **캐시** | 전역적으로 캐시 데이터 공유 |
| **스레드 풀** | 스레드 자원 중앙 관리 |

---

## 2. 팩토리 패턴 (Factory Pattern)

### 2.1 정의

**정의**: 객체 생성 로직을 별도의 클래스나 메서드로 분리하여 객체 생성을 캡슐화하는 패턴

**목적**:
- 객체 생성 로직 숨김
- 클라이언트 코드와 구체 클래스 분리
- 생성 로직 변경 시 클라이언트 코드 수정 최소화

---

### 2.2 팩토리 패턴의 종류

| 종류 | 설명 | 복잡도 |
|------|------|--------|
| **Simple Factory** | 단순한 팩토리 메서드로 객체 생성 | 낮음 |
| **Factory Method** | 서브클래스에서 객체 생성 결정 | 중간 |
| **Abstract Factory** | 관련된 객체 군(Family)을 생성 | 높음 |

---

### 2.3 Simple Factory (간단한 팩토리)

**구조**:
```
┌──────────┐
│  Client  │
└────┬─────┘
     │ 요청
     ↓
┌─────────────────┐      생성      ┌──────────┐
│ Simple Factory  │ ───────────→   │ Product  │
└─────────────────┘                └──────────┘
                                        ↑
                                        │ 상속
                           ┌────────────┴────────────┐
                           │                         │
                    ┌──────┴──────┐         ┌───────┴──────┐
                    │ ProductA    │         │ ProductB     │
                    └─────────────┘         └──────────────┘
```

**동작**:

| 단계 | 동작 |
|------|------|
| 1 | 클라이언트가 팩토리에 요청 (타입 전달) |
| 2 | 팩토리가 타입에 따라 적절한 객체 생성 |
| 3 | 생성된 객체를 클라이언트에 반환 |

```
예시:

클라이언트: factory.createProduct("A")
팩토리: if (type == "A") return new ProductA()
       else if (type == "B") return new ProductB()
```

---

### 2.4 Factory Method (팩토리 메서드)

**정의**: 객체 생성을 서브클래스에 위임하는 패턴

**구조**:
```
┌───────────────────┐
│    Creator        │ ← 추상 클래스/인터페이스
├───────────────────┤
│ + factoryMethod() │ ← 추상 메서드
│ + operation()     │
└────────┬──────────┘
         │ 상속
    ┌────┴────────────────┐
    │                     │
┌───┴──────────┐   ┌──────┴────────┐
│ ConcreteCreator1│   │ConcreteCreator2│
├─────────────┤   ├───────────────┤
│ factoryMethod()│   │factoryMethod() │
└───────────────┘   └───────────────┘
    │생성                 │생성
    ↓                     ↓
┌─────────┐         ┌─────────┐
│ProductA │         │ProductB │
└─────────┘         └─────────┘
```

**핵심 개념**:

| 요소 | 설명 |
|------|------|
| **Creator** | 객체 생성 인터페이스 정의 |
| **ConcreteCreator** | 실제 객체 생성 구현 |
| **Product** | 생성될 객체의 인터페이스 |
| **ConcreteProduct** | 실제 생성되는 구체 객체 |

---

### 2.5 Abstract Factory (추상 팩토리)

**정의**: 관련된 객체들의 집합(Family)을 생성하는 인터페이스 제공

**구조**:
```
┌──────────────────┐
│ Abstract Factory │
├──────────────────┤
│ + createProductA()│
│ + createProductB()│
└────────┬─────────┘
         │상속
    ┌────┴──────────────┐
    │                   │
┌───┴───────┐    ┌──────┴────┐
│ Factory1  │    │ Factory2  │
├───────────┤    ├───────────┤
│createProductA()│    │createProductA()│
│createProductB()│    │createProductB()│
└───────────┘    └───────────┘
    │생성             │생성
    ↓                 ↓
ProductA1         ProductA2
ProductB1         ProductB2
```

**사용 예시**:

| 팩토리 | 생성 제품군 |
|--------|------------|
| **WindowsFactory** | WindowsButton, WindowsCheckbox |
| **MacFactory** | MacButton, MacCheckbox |
| **LinuxFactory** | LinuxButton, LinuxCheckbox |

```
추상 팩토리 동작:

클라이언트 → GUIFactory 요청
            ↓
        OS 확인 (Windows)
            ↓
    WindowsFactory 생성
            ↓
    WindowsButton, WindowsCheckbox 생성
```

---

### 2.6 팩토리 패턴 비교

| 비교 | Simple Factory | Factory Method | Abstract Factory |
|------|----------------|----------------|------------------|
| **목적** | 객체 생성 단순화 | 생성 책임 분리 | 관련 객체군 생성 |
| **구조** | 단일 클래스 | 상속 구조 | 다중 팩토리 + 제품군 |
| **확장성** | 낮음 (수정 필요) | 높음 (서브클래스 추가) | 매우 높음 (팩토리 추가) |
| **복잡도** | 낮음 | 중간 | 높음 |
| **사용 시기** | 간단한 생성 로직 | 생성 방식 다양화 | 여러 관련 객체 생성 |

---

### 2.7 팩토리 패턴의 장단점

| 구분 | 내용 |
|------|------|
| **장점** | • 객체 생성 로직 캡슐화<br>• 클라이언트와 구체 클래스 분리 (결합도↓)<br>• 새로운 제품 추가 용이 (개방-폐쇄 원칙)<br>• 코드 재사용성 향상 |
| **단점** | • 클래스 개수 증가 (복잡도↑)<br>• 간단한 생성에는 오버엔지니어링<br>• 추상화 계층 증가 |

---

## 3. 싱글톤 vs 팩토리

| 비교 | 싱글톤 | 팩토리 |
|------|--------|--------|
| **목적** | 인스턴스 개수 제한 (1개) | 객체 생성 방식 캡슐화 |
| **생성 개수** | 단 하나 | 여러 개 가능 |
| **생성 주체** | 클래스 자신 | 별도의 팩토리 |
| **접근 방식** | getInstance() | createProduct() |
| **사용 이유** | 리소스 공유, 전역 상태 | 생성 로직 분리, 유연성 |
| **결합도** | 높음 (전역 상태) | 낮음 (인터페이스 의존) |

---

## 4. 패턴 조합

### 싱글톤 + 팩토리

**목적**: 팩토리 자체를 싱글톤으로 구현

```
싱글톤 팩토리 구조:

┌────────────────────────┐
│ Factory (Singleton)    │ ← 팩토리는 1개만 존재
├────────────────────────┤
│ - instance (static)    │
│ + getInstance()        │
│ + createProduct()      │
└───────────┬────────────┘
            │생성 (여러 개)
            ↓
     ┌──────────────┐
     │   Products   │ ← 제품은 여러 개 생성 가능
     └──────────────┘
```

**장점**:
- 팩토리 객체는 1개만 존재 (메모리 절약)
- 생성되는 제품은 여러 개 가능
- 전역적으로 팩토리 접근 가능

---

## 5. 핵심 정리

| 패턴 | 핵심 포인트 |
|------|------------|
| **싱글톤** | • 클래스의 인스턴스는 오직 1개<br>• private 생성자 + static 메서드<br>• 멀티스레드 환경 고려 필수 |
| **Simple Factory** | • 단일 클래스에서 객체 생성<br>• 타입에 따라 분기 처리 |
| **Factory Method** | • 서브클래스가 생성 결정<br>• 생성 책임 분리 |
| **Abstract Factory** | • 관련 객체군을 함께 생성<br>• 제품군(Family) 개념 |

---

## 면접 질문

### Q1. 싱글톤 패턴이 멀티스레드 환경에서 문제가 되는 이유와 해결 방법은?

**문제 상황**:
```
시간 순서:

Thread A                    Thread B
│                           │
├─ getInstance() 호출       │
├─ instance == null 확인    │
│                           ├─ getInstance() 호출
│                           ├─ instance == null 확인
├─ new Singleton() 생성     │
│                           ├─ new Singleton() 생성
└─ 인스턴스1 반환           └─ 인스턴스2 반환

→ 2개의 인스턴스 생성됨!
```

**해결 방법**:

| 방법 | 설명 | 비고 |
|------|------|------|
| **Synchronized** | getInstance()에 동기화 추가 | 성능 저하 |
| **Double-Checked Locking** | null 체크를 2번, 동기화 최소화 | 복잡하지만 성능↑ |
| **Eager Initialization** | 클래스 로딩 시 생성 | 스레드 안전, 메모리 사용 |
| **Bill Pugh (Inner Static)** | Static inner class 활용 | 권장 방식 |
| **Enum** | Enum으로 구현 | 가장 안전 |

---

### Q2. 팩토리 메서드와 추상 팩토리의 차이는?

| 구분 | Factory Method | Abstract Factory |
|------|----------------|------------------|
| **생성 단위** | 단일 제품 | 제품군 (여러 관련 제품) |
| **상속** | Creator를 상속하여 구현 | Factory를 구현 |
| **목적** | 한 가지 제품의 생성 방식 다양화 | 관련된 여러 제품을 일관성 있게 생성 |
| **예시** | 버튼 생성 (WindowsButton, MacButton) | UI 세트 생성 (WindowsButton+Checkbox, MacButton+Checkbox) |

**헷갈리기 쉬운 포인트**:

```
Factory Method:
- "어떤" 버튼을 만들까? → WindowsButton or MacButton
- 각 팩토리가 1가지 제품만 생성

Abstract Factory:
- "어떤 UI 세트"를 만들까? → Windows세트 or Mac세트
- 각 팩토리가 여러 관련 제품을 생성 (Button + Checkbox + ...)
```

**선택 기준**:
- 단일 제품의 다양한 변형 필요 → Factory Method
- 여러 관련 제품을 함께 생성 필요 → Abstract Factory