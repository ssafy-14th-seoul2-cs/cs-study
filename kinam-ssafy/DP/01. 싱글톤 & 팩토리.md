# 싱글톤 & 팩토리 패턴

## 들어가기 전 알아야 할 개념

### 디자인 패턴이란?

: 프로그램 설계 시 발생한 문제를 객체간의 상호관계 등을 이용해 해결할 수 있도록 하는 것  



---

## 1. 싱글톤 패턴 (Singleton Pattern)

### 1.1 정의

**정의**: 클래스의 인스턴스가 오직 하나만 존재하도록 보장하고, 전역적인 접근점을 제공하는 패턴

**목적**:
- 시스템 전체에서 단 하나의 객체만 존재
- 전역 상태 관리
- 리소스 공유

### 탄생 배경
 - 개발을 하다 보니, 시스템 내에서 딱 하나만 있어야 논리적으로 맞는 것들이 생김
 - **무분별한 생성**과 **데이터 불일치**를 막기 위해 태어남


### 핵심 이유
```
1. 자원 낭비 방지: 메모리에 설정 파일(Settings)이나 DB 연결(Connection) 같은 무거운 객체를 100번 호출한다고 100개 다 만들면 메모리가 터짐. 하나만 만들어 돌려쓰는 게 효율적

2. 데이터 일관성 (전역 상태 관리): 여러 곳에서 동시에 데이터를 수정할 때, 서로 다른 객체를 보고 있으면 안 됩니다. 모두가 같은 장부를 봐야 한다는 원칙을 강제하기 위해 나옴

```


---

### 1.2 핵심 구성 요소

| 요소 | 설명 | 역할 |
|------|------|------|
| **private 생성자** | 외부에서 new로 생성 불가 | 인스턴스 생성 통제 |
| **private static 인스턴스** | 클래스 내부에서 유일한 인스턴스 보관 | 단일 객체 보관 |
| **public static 메서드** | 인스턴스에 접근하는 공개 메서드 | 전역 접근점 제공 |

```
싱글톤 구조:

┌─────────────────────────┐
│   Singleton Class       │
├─────────────────────────┤
│ - instance (static)     │ ← 유일한 인스턴스
│ - Singleton()           │ ← private 생성자
├─────────────────────────┤
│ + getInstance() (static)│ ← 접근 메서드
└─────────────────────────┘
         ↑
         │ 항상 같은 객체 반환
         │
    [Client Code]
```

---

### 1.3 싱글톤 구현 방식

| 구현 방식 | 특징 | 장점 | 단점 |
|----------|------|------|------|
| **Eager Initialization** | 클래스 로딩 시점에 인스턴스 생성 | 구현 간단, 스레드 안전 | 사용 안 해도 메모리 차지 |
| **Lazy Initialization** | 최초 호출 시점에 인스턴스 생성 | 메모리 효율적 | 멀티스레드 환경에서 문제 |
| **Thread-Safe** | 동기화로 스레드 안전 보장 | 스레드 안전 | 성능 저하 (동기화 오버헤드) |
| **Double-Checked Locking** | 동기화 최소화 | 성능 향상 | 구현 복잡 |
| **Bill Pugh Solution** | Static inner class 활용 | 지연 로딩 + 스레드 안전 | - |
| **Enum** | Enum으로 구현 | 직렬화 안전, 리플렉션 방어 | Enum만 사용 가능 |

```
구현 방식 비교:

1. Eager (즉시 생성)
   클래스 로딩 → 인스턴스 생성 → getInstance() 호출 → 기존 인스턴스 반환

2. Lazy (지연 생성)
   클래스 로딩 → getInstance() 호출 → 인스턴스 생성 → 반환
   
3. Thread-Safe (동기화)
   클래스 로딩 → getInstance() 호출 → [Lock] → 인스턴스 확인/생성 → [Unlock] → 반환
```


```
구체적인 과정

1. Eager
    JVM(자바 가상 머신)이 Singleton 클래스 파일을 읽어서 메모리에 올림

    클래스를 읽자마자, 클래스 안에 있는 static 변수들을 찾아서 초기화

    private static Singleton instance = new Singleton();

    new Singleton()이 실행

    이제 누군가 부를 때까지 기다림

    나중에 클라이언트가 "야, 인스턴스 줘" 하고 호출

    새로 만드는 과정 없이, 아까 2번 단계에서 만들어둔 걸 바로 던져줌
```
```java
// Eager Initialization
public class Singleton {
    // [핵심] static 변수에 'new'를 바로 붙여버림.
    // 이 줄은 클래스가 로딩될 때 바로 실행됨(메서드 호출 전!)
    private static Singleton instance = new Singleton(); 
    
    private Singleton() {}

    public static Singleton getInstance() {
        return instance; // 그냥 주기만 하면 됨
    }
}
```java
// Lazy Initialization
public class Singleton {
    private static Singleton instance; // 선언만 하고 비워둠 (null)

    private Singleton() {}

    public static Singleton getInstance() {
        // [핵심] 메서드가 호출되었을 때 비로소 체크하고 생성함
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

### 문제 상황
```
스레드 A(일꾼 1)와 스레드 B(일꾼 2)가 동시에 getInstance()를 호출함.

일꾼 1: "어? 인스턴스(도시락) 없네? 내가 만들어야지." (하고 재료 가지러 감)

일꾼 2: (일꾼 1이 아직 만들기 전이라) "어? 인스턴스 없네? 나도 만들어야지."

결과: 결국 인스턴스(도시락)가 2개가 만들어짐. -> 싱글톤 원칙(오직 하나) 깨짐!
```
>> 멀티스레드 환경에서 싱글톤이 위험해지는 상황 발생



#### Thread-Safe
```
스레드 A가 getInstance()를 호출

[잠금] 메서드 입구에서 자물쇠(Synchronized)를 걸어줌. 다른 스레드는 못 들어옴

instance가 있는지 확인하고 없으면 만듦

instance를 반환
[해제] 자물쇠를 풉니다. 이제 스레드 B가 들어옴
```

>> 인스턴스가 이미 만들어져 있어서 그냥 가져가기만 하면 되는데도, 무조건 자물쇠를 잠그고 푸는 과정을 거쳐야 함.

#### Double-Checked Locking (DCL)
```
[1차 검사] 자물쇠 없이 봄 "인스턴스 있어?"

있으면? → 바로 반환 (빠름! 자물쇠 안 씀)

없으면? → 그때서야 자물쇠를 준비함

[잠금] 이제 동기화 블록에 들어감

[2차 검사] "진짜 없는 거 맞지?" 하고 한 번 더 확인 (그 사이에 딴 놈이 만들었을 수도 있으니까)

진짜 없으면 new로 생성

[해제] 자물쇠를 해제함
```
>> 성능은 좋지만, 코드가 복잡하고 volatile 같은 키워드를 정확히 써야 해서 구현 난이도가 높음


#### Bill Pugh Solution (Static Inner Class)
```
Singleton 클래스 안에 Holder라는 내부(Inner) 클래스를 하나 더 둚

클래스 로딩: Singleton 클래스가 로딩됨. 하지만 안에 있는 Holder 클래스는 아직 로딩되지 않음 (메모리 안 먹음)

대기: 아무 일도 안 일어납니다.

호출: 누군가 getInstance()를 호출합니다.

내부 클래스 로딩: 그때서야 Holder 클래스가 로딩되면서, 그 안에 있던 instance가 생성됩니다.

반환: 만들어진 걸 줍니다
```

>> VM이 클래스를 로딩할 때 스레드 안전을 보장해주기 때문에 개발자가 따로 synchronized를 걸 필요가 없음. 알아서 Lazy하고, 알아서 안전




#### Enum (열거형)
```
enum Singleton { INSTANCE; } 라고 씀

끝.

사용할 때는 Singleton.INSTANCE로 부름
```

#### 내부 컴파일러 해석?
```java
// 자바가 변환하는 실제 모습 (대략적)
public final class Singleton extends java.lang.Enum {
    // 프로그램 시작 시 딱 1번만 만들어지는 static final 상수
    public static final Singleton INSTANCE = new Singleton();
    
    private Singleton() {} // 생성자도 막혀있음
}
```

>> 리플렉션 방어: 나쁜 마음을 먹은 개발자가 코드로 억지로 생성자를 뚫고 들어와서(Reflection) 객체를 하나 더 만드는 해킹을 원천 봉쇄 

```
리플렉션?

리플렉션은 자바의 강력한 기능으로, private으로 잠긴 문(생성자)도 억지로 열고 들어갈 수 있는 해킹 도구 같은 기술

일반 싱글톤의 경우: 나쁜 개발자가 setAccessible(true)라는 코드를 쓰면 private 생성자를 강제로 실행해서 new Singleton()을 또 할 수 있음.(방어 불가)

하지만 enum 사용 시
"어? 너 Enum이네? 근데 감히 리플렉션으로 생성하려고 해? 안 돼!" 하고 예외(에러)를 터뜨려 버림
```




>>직렬화 안전: 객체를 파일로 저장했다가 다시 불러올 때(Deserialization) 복제본이 생기는 걸 언어가 막아줌

```
직렬화(Serialization)?
: 직렬화는 객체를 파일이나 네트워크로 보낼 때 010101... 데이터로 만드는 거고, 역직렬화는 그걸 다시 객체로 만드는 과정


일반 싱글톤의 경우: 파일에 저장된 데이터를 읽어와서 객체를 다시 만들면(역직렬화), 자바는 기본적으로 **새로운 객체(복제본)**를 만들어 줌. 그럼 싱글톤이 2개가 되어 버림 (이를 막으려면 readResolve라는 복잡한 메서드를 구현해야 함)


Enum의 경우 (이름표만 저장): Enum은 직렬화할 때 객체 내용을 저장하는 게 아니라, 단순히 "이 녀석 이름은 INSTANCE야" 라는 **문자열(String)**만 저장함. 나중에 파일에서 불러올 때(역직렬화), 자바는 "이름이 INSTANCE인 애를 데려와"라고 하고, 이미 메모리에 떠 있는 그 유일한 Enum 상수를 찾아서 줌. 새로 만드는 게 아니라, 원래 있던 걸 찾아주니까 안전
```



>> 단점: 상속(Inheritance)을 못 받음. 다른 클래스를 상속받아야 하는 상황이면 못 씀
```
자바는 다중 상속(부모가 둘 이상)을 금지

모든 enum은 태어날 때부터 이미 java.lang.Enum이라는 클래스를 상속받고 있음
```

---

### 1.4 싱글톤의 장단점

| 구분 | 내용 |
|------|------|
| **장점** | • 메모리 절약 (단일 인스턴스)<br>• 전역 접근 가능<br>• 인스턴스 생성 시점 제어 가능 |
| **단점** | • 전역 상태로 인한 결합도 증가<br>• 테스트 어려움 (Mock 객체 주입 곤란)<br>• 멀티스레드 환경 처리 복잡<br>• 단일 책임 원칙 위반 가능 |

---

### 1.5 싱글톤 사용 예시

| 사용처 | 이유 |
|--------|------|
| **설정 관리자** | 시스템 전체에서 동일한 설정 사용 |
| **로거** | 모든 곳에서 같은 로그 파일에 기록 |
| **데이터베이스 연결 풀** | 한정된 커넥션 리소스 관리 |
| **캐시** | 전역적으로 캐시 데이터 공유 |
| **스레드 풀** | 스레드 자원 중앙 관리 |

---

## 2. 팩토리 패턴 (Factory Pattern)

### 2.1 정의

**정의**: 객체 생성 로직을 별도의 클래스나 메서드로 분리하여 객체 생성을 캡슐화하는 패턴

**목적**:
- 객체 생성 로직 숨김
- 클라이언트 코드와 구체 클래스 분리
- 생성 로직 변경 시 클라이언트 코드 수정 최소화


### 탄생 배경

- 게임을 만드는데 `Monster`라는 클래스를 게임 로직 곳곳에서 직접 생성(`new Monster()`)했다고 가정

```C++
// 코드 곳곳에 퍼져있는 직접 생성 코드
void GameStage1() {
    Monster m = new Monster(); // 여기도 직접 생성
    // ...
}

void GameStage2() {
    Monster m = new Monster(); // 저기도 직접 생성
    // ...
}
```

- 어느 날 기획자가 모든 몬스터를 SuperMonster로 바꿔주세요! 라고 요청
- 개발자는 소스 코드 전체를 뒤져서 `new Monster()`라고 적힌 부분을 전부 `new SuperMonster()`로 수정해야 함
- 이 문제를 해결하기 위해 객체 생성을 전담하는 녀석(Factory)을 따로 두기로 함
```C++
// Factory 클래스 하나만 수정하면 끝!
class MonsterFactory {
    public Monster createMonster() {
        return new SuperMonster(); // 여기만 바꾸면 게임 전체 적용 완료!
    }
}

```



---

### 2.2 팩토리 패턴의 종류

| 종류 | 설명 | 복잡도 |
|------|------|--------|
| **Simple Factory** | 단순한 팩토리 메서드로 객체 생성 | 낮음 |
| **Factory Method** | 서브클래스에서 객체 생성 결정 | 중간 |
| **Abstract Factory** | 관련된 객체 군(Family)을 생성 | 높음 |

---

### 2.3 Simple Factory (간단한 팩토리)

**구조**:
```
┌──────────┐
│  Client  │
└────┬─────┘
     │ 요청
     ↓
┌─────────────────┐      생성      ┌──────────┐
│ Simple Factory  │ ───────────→   │ Product  │
└─────────────────┘                └──────────┘
                                        ↑
                                        │ 상속
                           ┌────────────┴────────────┐
                           │                         │
                    ┌──────┴──────┐         ┌───────┴──────┐
                    │ ProductA    │         │ ProductB     │
                    └─────────────┘         └──────────────┘
```

**동작**:

| 단계 | 동작 |
|------|------|
| 1 | 클라이언트가 팩토리에 요청 (타입 전달) |
| 2 | 팩토리가 타입에 따라 적절한 객체 생성 |
| 3 | 생성된 객체를 클라이언트에 반환 |

```
예시:

클라이언트: factory.createProduct("A")
팩토리: if (type == "A") return new ProductA()
       else if (type == "B") return new ProductB()
```

---

### 2.4 Factory Method (팩토리 메서드)

**정의**: 객체 생성을 서브클래스에 위임하는 패턴

**구조**:
```
┌───────────────────┐
│    Creator        │ ← 추상 클래스/인터페이스
├───────────────────┤
│ + factoryMethod() │ ← 추상 메서드
│ + operation()     │
└────────┬──────────┘
         │ 상속
    ┌────┴────────────────┐
    │                     │
┌───┴──────────┐   ┌──────┴────────┐
│ ConcreteCreator1│   │ConcreteCreator2│
├─────────────┤   ├───────────────┤
│ factoryMethod()│   │factoryMethod() │
└───────────────┘   └───────────────┘
    │생성                 │생성
    ↓                     ↓
┌─────────┐         ┌─────────┐
│ProductA │         │ProductB │
└─────────┘         └─────────┘
```

### 예시

- 부모 클래스(본사)는 "물건을 만들어야 한다"는 사실과 "언제 만든다"는 흐름만 알고 있고, 실제로 무엇을 만들지는 자식 클래스(지점)가 결정하는 패턴

```
[ 본사 (Creator) ]
       "버거를 만드시오 (makeBurger)"
             │ 추상 메서드
             │
      ┌──────┴──────┐
      │             │ 상속 (Override)
      ▼             ▼
 [ 서울점 ]       [ 뉴욕점 ]
 "불고기버거 만듦"  "치즈버거 만듦"
      │             │
      ▼             ▼
 (불고기버거)      (치즈버거)

```

**핵심 개념**:

| 요소 | 설명 |
|------|------|
| **Creator** | 객체 생성 인터페이스 정의 |
| **ConcreteCreator** | 실제 객체 생성 구현 |
| **Product** | 생성될 객체의 인터페이스 |
| **ConcreteProduct** | 실제 생성되는 구체 객체 |

---

### 2.5 Abstract Factory (추상 팩토리)

**정의**: 관련된 객체들의 집합(Family)을 생성하는 인터페이스 제공

**구조**:
```
┌──────────────────┐
│ Abstract Factory │
├──────────────────┤
│ + createProductA()│
│ + createProductB()│
└────────┬─────────┘
         │상속
    ┌────┴──────────────┐
    │                   │
┌───┴───────┐    ┌──────┴────┐
│ Factory1  │    │ Factory2  │
├───────────┤    ├───────────┤
│createProductA()│    │createProductA()│
│createProductB()│    │createProductB()│
└───────────┘    └───────────┘
    │생성             │생성
    ↓                 ↓
ProductA1         ProductA2
ProductB1         ProductB2
```

### 예시

- 단순히 객체 하나가 아니라, 서로 관련된 여러 객체들을 한 번에 묶어서(세트로) 만들어야 할 때 사용


```
[ 추상 팩토리 (전자제품 공장) ]
       + createPhone()
       + createEarphone()
             │
      ┌──────┴──────┐
      │             │
 [ 삼성 공장 ]     [ 애플 공장 ]
      │             │
      │             │
 ┌────┴────┐   ┌────┴────┐
 │ 갤럭시   │   │ 아이폰    │ (Phone)
 │ 버즈     │   │ 에어팟    │ (Earphone)
 └─────────┘   └─────────┘
  (삼성 세트)     (애플 세트)
```


**사용 예시**:

| 팩토리 | 생성 제품군 |
|--------|------------|
| **WindowsFactory** | WindowsButton, WindowsCheckbox |
| **MacFactory** | MacButton, MacCheckbox |
| **LinuxFactory** | LinuxButton, LinuxCheckbox |

```
추상 팩토리 동작:

클라이언트 → GUIFactory 요청
            ↓
        OS 확인 (Windows)
            ↓
    WindowsFactory 생성
            ↓
    WindowsButton, WindowsCheckbox 생성
```

---

### 2.6 팩토리 패턴 비교3

| 구분 | 팩토리 메서드 (Factory Method) | 추상 팩토리 (Abstract Factory) |
| :--- | :--- | :--- |
| **만드는 개수** | **딱 1개의 제품** 생성에 집중 | **여러 제품(세트)** 생성에 집중 |
| **핵심 원리** | **상속 (Inheritance)**<br>부모는 시키고 자식이 만듦 | **구성 (Composition)**<br>관련된 제품끼리 묶음 |
| **초점** | "어떤 클래스를 생성할지"를 서브클래스에 위임 | "관련된 객체들"을 섞이지 않게 통일 |
| **코드 예시** | `createMonster()` → 오크 생성 | `createUI()` → 윈도우 버튼, 윈도우 창, 윈도우 스크롤바 생성 |

---

### 2.6 팩토리 패턴 비교4

| 비교 | Simple Factory | Factory Method | Abstract Factory |
|------|----------------|----------------|------------------|
| **목적** | 객체 생성 단순화 | 생성 책임 분리 | 관련 객체군 생성 |
| **구조** | 단일 클래스 | 상속 구조 | 다중 팩토리 + 제품군 |
| **확장성** | 낮음 (수정 필요) | 높음 (서브클래스 추가) | 매우 높음 (팩토리 추가) |
| **복잡도** | 낮음 | 중간 | 높음 |
| **사용 시기** | 간단한 생성 로직 | 생성 방식 다양화 | 여러 관련 객체 생성 |

---

### 2.7 팩토리 패턴의 장단점

| 구분 | 내용 |
|------|------|
| **장점** | • 객체 생성 로직 캡슐화<br>• 클라이언트와 구체 클래스 분리 (결합도↓)<br>• 새로운 제품 추가 용이 (개방-폐쇄 원칙)<br>• 코드 재사용성 향상 |
| **단점** | • 클래스 개수 증가 (복잡도↑)<br>• 간단한 생성에는 오버엔지니어링<br>• 추상화 계층 증가 |

---

## 3. 싱글톤 vs 팩토리

| 비교 | 싱글톤 | 팩토리 |
|------|--------|--------|
| **목적** | 인스턴스 개수 제한 (1개) | 객체 생성 방식 캡슐화 |
| **생성 개수** | 단 하나 | 여러 개 가능 |
| **생성 주체** | 클래스 자신 | 별도의 팩토리 |
| **접근 방식** | getInstance() | createProduct() |
| **사용 이유** | 리소스 공유, 전역 상태 | 생성 로직 분리, 유연성 |
| **결합도** | 높음 (전역 상태) | 낮음 (인터페이스 의존) |

---

## 4. 패턴 조합

### 싱글톤 + 팩토리

**목적**: 팩토리 자체를 싱글톤으로 구현

```
싱글톤 팩토리 구조:

┌────────────────────────┐
│ Factory (Singleton)    │ ← 팩토리는 1개만 존재
├────────────────────────┤
│ - instance (static)    │
│ + getInstance()        │
│ + createProduct()      │
└───────────┬────────────┘
            │생성 (여러 개)
            ↓
     ┌──────────────┐
     │   Products   │ ← 제품은 여러 개 생성 가능
     └──────────────┘
```

**장점**:
- 팩토리 객체는 1개만 존재 (메모리 절약)
- 생성되는 제품은 여러 개 가능
- 전역적으로 팩토리 접근 가능

---

## 5. 핵심 정리

| 패턴 | 핵심 포인트 |
|------|------------|
| **싱글톤** | • 클래스의 인스턴스는 오직 1개<br>• private 생성자 + static 메서드<br>• 멀티스레드 환경 고려 필수 |
| **Simple Factory** | • 단일 클래스에서 객체 생성<br>• 타입에 따라 분기 처리 |
| **Factory Method** | • 서브클래스가 생성 결정<br>• 생성 책임 분리 |
| **Abstract Factory** | • 관련 객체군을 함께 생성<br>• 제품군(Family) 개념 |

---

## 면접 질문

### Q1. 싱글톤 패턴이 멀티스레드 환경에서 문제가 되는 이유와 해결 방법은?

**문제 상황**:
```
시간 순서:

Thread A                    Thread B
│                           │
├─ getInstance() 호출       │
├─ instance == null 확인    │
│                           ├─ getInstance() 호출
│                           ├─ instance == null 확인
├─ new Singleton() 생성     │
│                           ├─ new Singleton() 생성
└─ 인스턴스1 반환           └─ 인스턴스2 반환

→ 2개의 인스턴스 생성됨!
```

**해결 방법**:

| 방법 | 설명 | 비고 |
|------|------|------|
| **Synchronized** | getInstance()에 동기화 추가 | 성능 저하 |
| **Double-Checked Locking** | null 체크를 2번, 동기화 최소화 | 복잡하지만 성능↑ |
| **Eager Initialization** | 클래스 로딩 시 생성 | 스레드 안전, 메모리 사용 |
| **Bill Pugh (Inner Static)** | Static inner class 활용 | 권장 방식 |
| **Enum** | Enum으로 구현 | 가장 안전 |

---

### Q2. 팩토리 메서드와 추상 팩토리의 차이는?

| 구분 | Factory Method | Abstract Factory |
|------|----------------|------------------|
| **생성 단위** | 단일 제품 | 제품군 (여러 관련 제품) |
| **상속** | Creator를 상속하여 구현 | Factory를 구현 |
| **목적** | 한 가지 제품의 생성 방식 다양화 | 관련된 여러 제품을 일관성 있게 생성 |
| **예시** | 버튼 생성 (WindowsButton, MacButton) | UI 세트 생성 (WindowsButton+Checkbox, MacButton+Checkbox) |

**헷갈리기 쉬운 포인트**:

```
Factory Method:
- "어떤" 버튼을 만들까? → WindowsButton or MacButton
- 각 팩토리가 1가지 제품만 생성

Abstract Factory:
- "어떤 UI 세트"를 만들까? → Windows세트 or Mac세트
- 각 팩토리가 여러 관련 제품을 생성 (Button + Checkbox + ...)
```

**선택 기준**:
- 단일 제품의 다양한 변형 필요 → Factory Method
- 여러 관련 제품을 함께 생성 필요 → Abstract Factory