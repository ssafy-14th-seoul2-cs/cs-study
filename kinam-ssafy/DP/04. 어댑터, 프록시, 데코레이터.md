# 04\. 어댑터, 프록시, 데코레이터

## 개요

  * **디자인 패턴**: 설계 문제에 대한 검증된 해결책이자 템플릿.
  * **구조 패턴**: 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴들.

-----

## 1\. 어댑터 패턴 (Adapter Pattern)

### 1.1 핵심 개념

  * 호환되지 않는 인터페이스를 가진 객체들을 연결해주는 **변환기** 역할.
  * 한 객체의 인터페이스를 다른 객체가 이해할 수 있도록 변환함.

### 1.2 탄생 배경 (Why?)

  * **문제**: 외부 라이브러리나 레거시 코드를 가져와야 하는데 인터페이스가 맞지 않음. 외부 코드는 수정 불가하고, 내 코드를 고치기엔 비용이 너무 큼.
  * **해결**: 두 인터페이스 사이에서 **중개자(Adapter)** 클래스를 만들어, 기존 코드 수정 없이 연결함.

### 1.3 구조 및 요소

  * **Target**: 사용자가 필요로 하는 목표 인터페이스.
  * **Adaptee**: 변환이 필요한 기존 클래스 (호환 안 됨).
  * **Adapter**: Target을 구현하며 내부적으로 Adaptee를 호출하여 변환함.

### 1.4 코드 예시 (간소화)

```java
// 1. Target (필요한 인터페이스)
interface Standard {
    void process();
}

// 2. Adaptee (기존 코드 - 호환 불가)
class Legacy {
    void specificRequest() {
        System.out.println("기존 방식 작동");
    }
}

// 3. Adapter (변환기)
class Adapter implements Standard {
    private Legacy legacy;

    public Adapter(Legacy legacy) {
        this.legacy = legacy;
    }

    @Override
    public void process() {
        // Target 요청을 Adaptee 메서드로 연결
        legacy.specificRequest();
    }
}
```

-----

## 2\. 데코레이터 패턴 (Decorator Pattern)

### 2.1 핵심 개념

  * 객체에 **동적으로 새로운 기능**을 추가하는 패턴.
  * 상속 대신 객체를 감싸는(Wrapping) 방식으로 유연하게 확장함.

### 2.2 탄생 배경 (Why?)

  * **문제**: 다양한 기능 조합이 필요할 때 상속을 사용하면 **클래스 폭발(Class Explosion)** 발생. (예: `MilkCoffee`, `SugarCoffee`, `MilkSugarCoffee`...)
  * **해결**: 기능을 상속으로 고정하지 않고, **장식자(Decorator)** 클래스로 객체를 겹겹이 감싸 기능을 조합함.

### 2.3 구조 및 요소

  * **Component**: 기본 기능을 정의하는 인터페이스.
  * **ConcreteComponent**: 기본 기능을 구현하는 원본 객체.
  * **Decorator**: Component를 감싸며 추가 기능을 구현하는 클래스.

### 2.4 코드 예시 (간소화)

```java
// 1. Component
interface Service {
    void run();
}

// 2. ConcreteComponent (원본)
class BasicService implements Service {
    public void run() { System.out.print("기본"); }
}

// 3. Decorator (장식자)
class Decorator implements Service {
    private Service service; // 원본 보유

    public Decorator(Service service) { this.service = service; }

    public void run() {
        service.run(); // 원래 기능
        System.out.print(" + 추가기능"); // 확장
    }
}
```

-----

## 3\. 프록시 패턴 (Proxy Pattern)

### 3.1 핵심 개념

  * 실제 객체에 대한 **대리자** 역할을 수행.
  * 객체 접근을 **제어**하거나 부가 작업을 수행함.

### 3.2 탄생 배경 (Why?)

  * **문제**: 객체 생성 비용이 너무 크거나(메모리 낭비), 보안상 직접 접근을 막아야 함.
  * **해결**: \*\*대리인(Proxy)\*\*을 세워 요청을 가로채고, 권한 확인이나 지연 로딩(Lazy Loading)을 수행함.

### 3.3 구조 및 요소

  * **Subject**: 공통 인터페이스.
  * **RealSubject**: 실제 작업을 수행하는 무거운 객체.
  * **Proxy**: RealSubject 참조를 가지며 접근을 제어함.

### 3.4 코드 예시 (간소화)

```java
// 1. Subject
interface Data {
    void read();
}

// 2. RealSubject (무거운 객체)
class RealData implements Data {
    public void read() { System.out.println("데이터 읽기"); }
}

// 3. Proxy (대리자)
class ProxyData implements Data {
    private RealData real;

    public void read() {
        // 지연 로딩: 필요할 때 생성
        if (real == null) real = new RealData();
        
        System.out.println("접근 제어");
        real.read();
    }
}
```

-----

## 4\. 요약 및 비교

| 패턴 | 핵심 역할 | 탄생 원인 (문제 해결) | 구조적 특징 |
| :--- | :--- | :--- | :--- |
| **어댑터** | **변환** (Conversion) | 인터페이스 불일치로 인한 **연결 불가** 해결 | 다른 인터페이스를 감싸서 맞춤 |
| **데코레이터** | **확장** (Extension) | 상속 남발로 인한 **클래스 폭발** 해결 | 같은 인터페이스를 감싸서 기능 추가 |
| **프록시** | **제어** (Control) | 직접 접근 시 **성능/보안 문제** 해결 | 같은 인터페이스를 감싸서 접근 관리 |