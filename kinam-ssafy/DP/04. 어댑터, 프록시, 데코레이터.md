# 어댑터, 데코레이터 & 프록시 패턴

## 들어가기 전에

### 디자인 패턴이란

**개념**
- 소프트웨어 설계에서 자주 발생하는 문제들에 대한 **검증된 해결책**
- 특정 상황에서 어떻게 코드를 구조화할지에 대한 **설계 템플릿**

**분류**
- **생성 패턴**: 객체 생성 방식 (싱글톤, 팩토리, 빌더)
- **구조 패턴**: 객체 간 관계 구성 (어댑터, 데코레이터, 프록시)
- **행위 패턴**: 객체 간 협력 방식 (전략, 옵저버, 커맨드)

```
오늘 배울 패턴들은 모두 구조 패턴

공통점: 기존 클래스를 수정하지 않고 기능을 확장하거나 제어
차이점: 각각 다른 목적과 방식으로 접근
```

---

## 어댑터 패턴 (Adapter Pattern)

### 핵심 개념

**사전적 의미**
- 어댑터(Adapter): "연결해주는 장치", "변환기"

**패턴 정의**
- 호환되지 않는 인터페이스를 가진 객체들을 함께 동작시키기 위한 패턴
- 기존 클래스의 인터페이스를 클라이언트가 기대하는 인터페이스로 **변환**

```
실생활 비유:
220V 콘센트 ←[어댑터]→ 110V 전자기기
한국 플러그 ←[어댑터]→ 유럽 콘센트
```

### 언제 사용하나

| 상황 | 설명 |
|------|------|
| 레거시 코드 통합 | 오래된 코드를 새 시스템에 연결 |
| 외부 라이브러리 사용 | 서드파티 라이브러리 인터페이스 변환 |
| 인터페이스 불일치 | 기존 클래스 수정 없이 호환 |

### 구조

```
┌──────────────┐
│   Client     │ ← 클라이언트가 원하는 인터페이스
└──────┬───────┘
       │ 사용
       ↓
┌──────────────┐
│   Target     │ ← 목표 인터페이스
│  (interface) │
└──────────────┘
       ↑
       │ 구현
┌──────────────┐      ┌──────────────┐
│   Adapter    │─────→│   Adaptee    │
│              │ 위임  │ (기존 클래스) │
└──────────────┘      └──────────────┘
```

### 구성 요소

| 요소 | 역할 |
|------|------|
| **Target** | 클라이언트가 사용하는 인터페이스 |
| **Adapter** | Target 인터페이스를 구현하며 Adaptee를 감싸서 변환 |
| **Adaptee** | 변환이 필요한 기존 클래스 |
| **Client** | Target 인터페이스를 통해 작업 수행 |

### 동작 방식

```
실행 흐름:

1. Client가 Target 인터페이스로 요청
   ↓
2. Adapter가 요청을 받음
   ↓
3. Adapter가 Adaptee의 메서드로 변환
   ↓
4. Adaptee가 실제 작업 수행
   ↓
5. Adapter가 결과를 Target 형식으로 반환
```

### 실제 예시

**상황**: 구형 프린터(Adaptee)를 새 시스템(Target)에 연결

```java
// Target 인터페이스 (새 시스템이 기대하는 방식)
interface ModernPrinter {
    void print(String document);
}

// Adaptee (기존 구형 프린터)
class LegacyPrinter {
    void printDocument(byte[] data) {
        System.out.println("구형 프린터로 출력: " + new String(data));
    }
}

// Adapter (변환기)
class PrinterAdapter implements ModernPrinter {
    private LegacyPrinter legacyPrinter;
    
    public PrinterAdapter(LegacyPrinter legacyPrinter) {
        this.legacyPrinter = legacyPrinter;
    }
    
    @Override
    public void print(String document) {
        // String을 byte[]로 변환하여 구형 프린터에 전달
        byte[] data = document.getBytes();
        legacyPrinter.printDocument(data);
    }
}

// Client 사용
ModernPrinter printer = new PrinterAdapter(new LegacyPrinter());
printer.print("Hello World");  // 새 방식으로 호출, 구형 프린터로 출력
```

**실무 사례**

| 사례 | 설명 |
|------|------|
| DB 드라이버 | JDBC → 각 DB별 드라이버 (MySQL, Oracle) |
| 결제 시스템 | 통합 결제 인터페이스 → 각 PG사 API |
| 로깅 라이브러리 | SLF4J → Log4j, Logback 등 |

### 장단점

**장점**
```
✓ 기존 코드 수정 없이 호환
✓ 단일 책임 원칙 (SRP) 준수
✓ 개방-폐쇄 원칙 (OCP) 준수
✓ 클라이언트 코드와 라이브러리 분리
```

**단점**
```
✗ 새로운 클래스가 추가되어 복잡도 증가
✗ 때로는 직접 수정이 더 간단할 수 있음
```

---

## 데코레이터 패턴 (Decorator Pattern)

### 핵심 개념

**사전적 의미**
- 데코레이터(Decorator): "장식하는 것", "꾸미는 것"

**패턴 정의**
- 객체에 **동적으로 새로운 책임(기능)을 추가**하는 패턴
- 기존 코드 변경 없이 객체의 기능을 **확장**

```
실생활 비유:
기본 커피 → 우유 추가 → 시럽 추가 → 휘핑크림 추가
각 단계마다 기능(맛)이 추가됨
```

### 언제 사용하나

| 상황 | 설명 |
|------|------|
| 동적 기능 추가 | 런타임에 객체에 기능 추가/제거 |
| 상속의 대안 | 상속 없이 기능 확장 |
| 조합 가능한 기능 | 여러 기능을 자유롭게 조합 |

### 구조

```
┌─────────────┐
│  Component  │ ← 기본 인터페이스
│ (interface) │
└──────┬──────┘
       │
   ┌───┴───┐
   │       │
┌──┴────┐  │
│Concrete│  │
│Component  │
└────────┘  │
            │
      ┌─────┴─────┐
      │ Decorator │ ← Component를 감싸는 추상 클래스
      │ (abstract)│
      └─────┬─────┘
            │
    ┌───────┴───────┐
    │               │
┌───┴────┐    ┌────┴────┐
│Concrete│    │Concrete │
│DecoratorA    │DecoratorB
└────────┘    └─────────┘
```

### 구성 요소

| 요소 | 역할 |
|------|------|
| **Component** | 기본 기능을 정의하는 인터페이스 |
| **ConcreteComponent** | 기본 기능을 구현한 클래스 |
| **Decorator** | Component를 감싸는 추상 클래스 |
| **ConcreteDecorator** | 실제 추가 기능을 구현 |

### 동작 방식

```
실행 흐름:

기본 객체
   ↓
데코레이터A로 감싸기 (기능 A 추가)
   ↓
데코레이터B로 감싸기 (기능 B 추가)
   ↓
최종 객체 = 기본 기능 + A + B
```

### 실제 예시

**상황**: 커피 주문 시스템 (기본 커피 + 추가 옵션)

```java
// Component 인터페이스
interface Coffee {
    String getDescription();
    int getCost();
}

// ConcreteComponent (기본 커피)
class Espresso implements Coffee {
    @Override
    public String getDescription() {
        return "에스프레소";
    }
    
    @Override
    public int getCost() {
        return 2000;
    }
}

// Decorator 추상 클래스
abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;
    
    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
}

// ConcreteDecorator (우유 추가)
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription() + " + 우유";
    }
    
    @Override
    public int getCost() {
        return coffee.getCost() + 500;
    }
}

// ConcreteDecorator (시럽 추가)
class SyrupDecorator extends CoffeeDecorator {
    public SyrupDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription() + " + 시럽";
    }
    
    @Override
    public int getCost() {
        return coffee.getCost() + 300;
    }
}

// 사용
Coffee coffee = new Espresso();  // 에스프레소 2000원
coffee = new MilkDecorator(coffee);  // + 우유 500원
coffee = new SyrupDecorator(coffee);  // + 시럽 300원

System.out.println(coffee.getDescription());  // 에스프레소 + 우유 + 시럽
System.out.println(coffee.getCost());  // 2800원
```

**실무 사례**

| 사례 | 설명 |
|------|------|
| Java I/O | BufferedInputStream, DataInputStream 등 |
| GUI 컴포넌트 | 스크롤바, 테두리 등 추가 |
| 웹 필터 | 인증, 로깅, 압축 필터 체인 |

```
Java I/O 예시:
InputStream in = new FileInputStream("file.txt");
in = new BufferedInputStream(in);  // 버퍼링 기능 추가
in = new DataInputStream(in);      // 데이터 타입 읽기 기능 추가
```

### 장단점

**장점**
```
✓ 런타임에 동적으로 기능 추가/제거
✓ 기능 조합의 유연성
✓ 단일 책임 원칙 (각 데코레이터가 하나의 기능만)
✓ 개방-폐쇄 원칙 준수
```

**단점**
```
✗ 작은 객체들이 많이 생성되어 복잡도 증가
✗ 디버깅 어려움 (여러 겹으로 감싸져 있음)
✗ 데코레이터 순서에 따라 결과가 달라질 수 있음
```

---

## 프록시 패턴 (Proxy Pattern)

### 핵심 개념

**사전적 의미**
- 프록시(Proxy): "대리인", "대신하는 것"

**패턴 정의**
- 실제 객체에 대한 **대리자(대리인) 역할**을 하는 패턴
- 실제 객체에 대한 접근을 **제어**하거나 **기능을 추가**

```
실생활 비유:
본인 ←[비서]→ 외부인
비서가 일정 확인, 중요도 판단, 전달 등을 대신 처리

VPN 사용:
사용자 ←[프록시 서버]→ 실제 웹사이트
```

### 언제 사용하나

| 상황 | 설명 |
|------|------|
| 지연 로딩 | 필요할 때만 실제 객체 생성 |
| 접근 제어 | 권한 검사 후 실제 객체 접근 |
| 로깅/캐싱 | 실제 작업 전후로 부가 기능 |

### 구조

```
┌──────────┐
│  Client  │
└────┬─────┘
     │ 사용
     ↓
┌────────────┐
│  Subject   │ ← 공통 인터페이스
│(interface) │
└────────────┘
     ↑
     │ 구현
  ┌──┴──┐
  │     │
┌─┴───┐ │
│Proxy│ │
└──┬──┘ │
   │참조 │
   ↓    │
┌──────┴─────┐
│RealSubject │ ← 실제 객체
└────────────┘
```

### 구성 요소

| 요소 | 역할 |
|------|------|
| **Subject** | Proxy와 RealSubject의 공통 인터페이스 |
| **RealSubject** | 실제 작업을 수행하는 객체 |
| **Proxy** | RealSubject를 감싸고 접근을 제어 |

### 프록시 종류

| 종류 | 목적 | 사용 예시 |
|------|------|----------|
| **가상 프록시** | 지연 로딩 (Lazy Loading) | 대용량 이미지 로딩 |
| **보호 프록시** | 접근 제어 | 권한 검사 |
| **원격 프록시** | 원격 객체 대리 | RMI, 웹 서비스 |
| **캐싱 프록시** | 결과 캐싱 | DB 쿼리 결과 저장 |
| **로깅 프록시** | 작업 로그 기록 | 메서드 호출 추적 |

### 동작 방식

```
실행 흐름:

1. Client가 Proxy에 요청
   ↓
2. Proxy가 전처리 (권한 체크, 캐시 확인 등)
   ↓
3-1. 캐시에 있으면 → 바로 반환
3-2. 없으면 → RealSubject 호출
   ↓
4. RealSubject가 실제 작업 수행
   ↓
5. Proxy가 후처리 (로깅, 캐싱 등)
   ↓
6. Client에 결과 반환
```

### 실제 예시

**예시 1: 가상 프록시 (이미지 지연 로딩)**

```java
// Subject 인터페이스
interface Image {
    void display();
}

// RealSubject (실제 이미지)
class RealImage implements Image {
    private String filename;
    
    public RealImage(String filename) {
        this.filename = filename;
        loadFromDisk();  // 생성 시 디스크에서 로딩 (비용 큼)
    }
    
    private void loadFromDisk() {
        System.out.println(filename + " 로딩 중... (오래 걸림)");
    }
    
    @Override
    public void display() {
        System.out.println(filename + " 표시");
    }
}

// Proxy (이미지 프록시)
class ImageProxy implements Image {
    private String filename;
    private RealImage realImage;
    
    public ImageProxy(String filename) {
        this.filename = filename;
        // 실제 객체는 아직 생성하지 않음
    }
    
    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename);  // 필요할 때 생성
        }
        realImage.display();
    }
}

// 사용
Image image = new ImageProxy("photo.jpg");
// 아직 로딩 안 됨

image.display();  // 이때 로딩됨
// 출력: photo.jpg 로딩 중... (오래 걸림)
//       photo.jpg 표시

image.display();  // 이미 로딩되어 있어 빠름
// 출력: photo.jpg 표시
```

**예시 2: 보호 프록시 (접근 제어)**

```java
interface Document {
    void view();
    void edit();
}

class RealDocument implements Document {
    private String content;
    
    public RealDocument(String content) {
        this.content = content;
    }
    
    @Override
    public void view() {
        System.out.println("문서 내용: " + content);
    }
    
    @Override
    public void edit() {
        System.out.println("문서 편집 중...");
    }
}

class ProtectedDocument implements Document {
    private RealDocument realDocument;
    private String userRole;
    
    public ProtectedDocument(String content, String userRole) {
        this.realDocument = new RealDocument(content);
        this.userRole = userRole;
    }
    
    @Override
    public void view() {
        realDocument.view();  // 모두 가능
    }
    
    @Override
    public void edit() {
        if ("ADMIN".equals(userRole)) {
            realDocument.edit();  // 관리자만 가능
        } else {
            System.out.println("권한 없음: 편집 불가");
        }
    }
}

// 사용
Document adminDoc = new ProtectedDocument("기밀문서", "ADMIN");
adminDoc.view();  // 가능
adminDoc.edit();  // 가능

Document userDoc = new ProtectedDocument("기밀문서", "USER");
userDoc.view();  // 가능
userDoc.edit();  // 불가: 권한 없음
```

**실무 사례**

| 사례 | 설명 |
|------|------|
| Spring AOP | 트랜잭션, 로깅, 보안 등 프록시로 처리 |
| Hibernate | 지연 로딩으로 DB 성능 최적화 |
| CDN | 콘텐츠 캐싱 프록시 |
| 방화벽 | 네트워크 접근 제어 프록시 |

### 장단점

**장점**
```
✓ 실제 객체의 생성 시점 제어 (지연 로딩)
✓ 접근 제어로 보안 강화
✓ 실제 객체 수정 없이 기능 추가
✓ 개방-폐쇄 원칙 준수
```

**단점**
```
✗ 코드 복잡도 증가
✗ 응답 시간 지연 가능 (프록시 처리 시간)
```

---

## 세 패턴 비교

### 핵심 차이

| 패턴 | 목적 | 관계 | 주요 용도 |
|------|------|------|----------|
| **어댑터** | 인터페이스 **변환** | 다른 인터페이스 → 호환 | 레거시 통합 |
| **데코레이터** | 기능 **확장** | 같은 인터페이스 + 기능 추가 | 동적 기능 조합 |
| **프록시** | 접근 **제어** | 같은 인터페이스 + 접근 관리 | 지연 로딩, 보안 |

### 구조 비교

```
어댑터:
Client → [Adapter] → Adaptee (다른 인터페이스)
         변환 역할

데코레이터:
Client → [Decorator] → [Decorator] → Component
         기능 추가      기능 추가

프록시:
Client → [Proxy] → RealSubject
         제어 역할
```

### 사용 시점 비교

| 상황 | 선택할 패턴 |
|------|-----------|
| 인터페이스가 맞지 않음 | 어댑터 |
| 기능을 동적으로 추가하고 싶음 | 데코레이터 |
| 객체 생성/접근을 제어하고 싶음 | 프록시 |
| 여러 기능을 조합하고 싶음 | 데코레이터 |
| 권한 검사가 필요함 | 프록시 |
| 레거시 시스템 연동 | 어댑터 |

### 실무 활용 예시

| 시나리오 | 패턴 | 이유 |
|---------|------|------|
| 구형 결제 모듈을 새 시스템에 연동 | 어댑터 | 인터페이스 불일치 해결 |
| 커피 옵션 추가 (우유, 시럽 등) | 데코레이터 | 조합 가능한 기능 확장 |
| 대용량 이미지 지연 로딩 | 프록시 | 성능 최적화 |
| 로그인한 사용자만 문서 편집 | 프록시 | 접근 제어 |
| Java I/O 스트림 (버퍼, 압축 등) | 데코레이터 | 기능의 동적 조합 |

---

## 핵심 정리

### 패턴별 핵심 키워드

**어댑터**
```
키워드: 변환, 호환, 인터페이스 맞추기
상황: "이 코드를 저 시스템에서 쓰고 싶은데 인터페이스가 안 맞아"
해결: 중간에 변환기(어댑터) 추가
```

**데코레이터**
```
키워드: 확장, 조합, 기능 추가
상황: "기본 기능에 여러 옵션을 동적으로 붙이고 싶어"
해결: 기능을 겹겹이 감싸서 조합
```

**프록시**
```
키워드: 제어, 대리, 접근 관리
상황: "실제 객체 접근을 제어하고 싶어"
해결: 대리자(프록시)를 통해 간접 접근
```

### 선택 가이드

```
질문 1: 기존 객체의 인터페이스를 바꿔야 하나?
└─ YES → 어댑터

질문 2: 기존 객체에 기능을 추가하고 싶나?
├─ YES → 질문 3으로
└─ NO → 질문 4로

질문 3: 여러 기능을 자유롭게 조합하고 싶나?
├─ YES → 데코레이터
└─ NO → 프록시

질문 4: 객체 접근을 제어하고 싶나?
└─ YES → 프록시
```

### 실무 팁

**어댑터 사용 시**
```
✓ 레거시 코드는 가능한 건드리지 말 것
✓ 인터페이스 변환 로직만 어댑터에 집중
✗ 너무 많은 변환 로직은 유지보수 어려움
```

**데코레이터 사용 시**
```
✓ 각 데코레이터는 단일 기능만 담당
✓ 데코레이터 순서가 중요한 경우 문서화
✗ 너무 많은 겹은 디버깅 어려움
```

**프록시 사용 시**
```
✓ 프록시에서는 제어 로직만, 실제 로직은 원본 객체에
✓ 캐싱 프록시는 메모리 관리 주의
✗ 불필요한 프록시 레이어는 성능 저하
```