# 옵저버 & 퍼블리셔-서브스크라이버 패턴

## 들어가기 전 알아야 할 개념

| 개념 | 설명 |
|------|------|
| **의존성** | 한 객체가 다른 객체의 변화에 영향받는 관계 |
| **결합도** | 모듈 간 의존성의 강도 (낮을수록 좋음) |
| **이벤트** | 시스템에서 발생하는 특정 사건 |
| **알림(Notification)** | 상태 변화를 다른 객체에 전달하는 행위 |

---

## 1. 옵저버 패턴 (Observer Pattern)

### 1.1 정의

**정의**: 객체의 상태 변화를 관찰하다가 변화가 있을 때 옵저버들에게 자동으로 알림을 보내는 패턴

**핵심 아이디어**: 일대다(1:N) 의존 관계에서 한 객체의 상태가 변하면 의존하는 모든 객체에 자동 통지

**목적**:
- 객체 간 느슨한 결합
- 상태 변화 자동 전파
- 동적으로 옵저버 추가/제거

---

### 1.2 옵저버 패턴 구조

```
┌──────────────────┐                 ┌──────────────┐
│    Subject       │                 │   Observer   │
├──────────────────┤                 ├──────────────┤
│ - observers[]    │◆────────────────│ + update()   │
├──────────────────┤                 └──────┬───────┘
│ + attach(o)      │                        │구현
│ + detach(o)      │                   ┌────┴────────┐
│ + notify()       │                   │             │
└────────┬─────────┘            ┌──────┴──────┐ ┌───┴────────┐
         │구현                   │ ObserverA   │ │ ObserverB  │
         │                       ├─────────────┤ ├────────────┤
┌────────┴──────────┐            │ update()    │ │ update()   │
│ ConcreteSubject   │            └─────────────┘ └────────────┘
├───────────────────┤
│ - state           │
├───────────────────┤
│ + getState()      │
│ + setState()      │ ← 상태 변경 시 notify() 호출
└───────────────────┘
```

**구성 요소**:

| 요소 | 역할 |
|------|------|
| **Subject** | 옵저버를 관리, 상태 변화 시 알림 |
| **Observer** | 업데이트 인터페이스 정의 |
| **ConcreteSubject** | 실제 상태를 보유, 변경 시 통지 |
| **ConcreteObserver** | Subject 상태 변화에 대응 |

---

### 1.3 옵저버 패턴 동작 흐름

```
동작 순서:

1. 등록 단계:
   subject.attach(observerA)
   subject.attach(observerB)
   subject.attach(observerC)

2. 상태 변경:
   subject.setState(newState)
   └─→ notify() 자동 호출

3. 알림 전파:
   notify()
   ├─→ observerA.update() 호출
   ├─→ observerB.update() 호출
   └─→ observerC.update() 호출

4. 옵저버 처리:
   각 옵저버가 subject.getState()로 새 상태 조회 및 처리
```

**상세 흐름**:

| 단계 | Subject | Observer |
|------|---------|----------|
| **1. 구독** | observers 리스트에 추가 | - |
| **2. 상태 변경** | state 변경, notify() 호출 | - |
| **3. 알림** | 모든 observers에게 update() 호출 | update() 받음 |
| **4. 조회** | - | getState()로 최신 상태 조회 |
| **5. 처리** | - | 새 상태에 따라 자신의 로직 실행 |

---

### 1.4 옵저버 패턴 예시

**뉴스 구독 시스템**:

```
구조:

NewsAgency (Subject)
├─ news (상태)
├─ subscribers[] (옵저버 리스트)
└─ publishNews(news) → 모든 구독자에게 알림

EmailSubscriber (Observer)
└─ update() → 이메일 발송

SMSSubscriber (Observer)
└─ update() → SMS 발송

AppSubscriber (Observer)
└─ update() → 앱 푸시 알림
```

**동작 예시**:

| 시간 | 동작 |
|------|------|
| T0 | EmailSubscriber가 NewsAgency 구독 |
| T1 | SMSSubscriber가 NewsAgency 구독 |
| T2 | NewsAgency.publishNews("새 뉴스!") |
| T3 | → EmailSubscriber.update() 호출 (이메일 발송) |
| T4 | → SMSSubscriber.update() 호출 (SMS 발송) |

---

### 1.5 Push vs Pull 방식

| 방식 | 설명 | 장점 | 단점 |
|------|------|------|------|
| **Push** | Subject가 변경 데이터를 update(data)로 전달 | 옵저버가 조회 불필요 | 불필요한 데이터도 전달 |
| **Pull** | Subject가 update()만 호출, 옵저버가 getState()로 조회 | 필요한 데이터만 조회 | 추가 메서드 호출 필요 |

```
Push 방식:
subject.setState(100)
└─→ observer.update(100) ← 데이터를 직접 전달

Pull 방식:
subject.setState(100)
└─→ observer.update()
    └─→ observer는 subject.getState()로 직접 조회
```

---

### 1.6 옵저버 패턴의 장단점

| 구분 | 내용 |
|------|------|
| **장점** | • Subject와 Observer 느슨한 결합<br>• 런타임에 동적으로 관계 설정<br>• 개방-폐쇄 원칙 (새 옵저버 추가 쉬움)<br>• 브로드캐스트 통신 (일대다) |
| **단점** | • 옵저버 순서 보장 어려움<br>• 메모리 누수 위험 (구독 해제 안 하면)<br>• 복잡한 업데이트 시 성능 저하<br>• Subject와 Observer 직접 연결 (여전히 의존성 존재) |

---

## 2. 퍼블리셔-서브스크라이버 패턴 (Pub-Sub Pattern)

### 2.1 정의

**정의**: 메시지를 발행하는 퍼블리셔와 구독하는 서브스크라이버 사이에 중간 채널을 두어 완전히 분리하는 패턴

**핵심 아이디어**: 퍼블리셔와 서브스크라이버가 서로를 몰라도 됨, 중간 브로커가 메시지 전달

**목적**:
- 완전한 느슨한 결합
- 확장성 향상
- 비동기 통신 지원

---

### 2.2 Pub-Sub 패턴 구조

```
┌──────────────┐                    ┌────────────────┐
│ Publisher    │                    │ Subscriber     │
├──────────────┤                    ├────────────────┤
│ publish(msg) │                    │ onMessage(msg) │
└──────┬───────┘                    └────────┬───────┘
       │                                     │
       │ 메시지 발행                          │ 구독
       ↓                                     ↓
┌──────────────────────────────────────────────────┐
│         Event Channel / Message Broker           │
├──────────────────────────────────────────────────┤
│ • 메시지 큐                                       │
│ • 토픽/채널 관리                                  │
│ • 라우팅                                          │
│ • 필터링                                          │
└──────────────────────────────────────────────────┘
       ↑                                     ↑
       │ subscribe("topic")                  │
       │                                     │
┌──────┴──────┐                      ┌──────┴──────┐
│ PublisherA  │                      │ SubscriberX │
└─────────────┘                      └─────────────┘
```

**구성 요소**:

| 요소 | 역할 |
|------|------|
| **Publisher** | 메시지 발행, 서브스크라이버를 모름 |
| **Subscriber** | 특정 토픽 구독, 퍼블리셔를 모름 |
| **Event Channel/Broker** | 메시지 전달 중개, 라우팅, 필터링 |
| **Topic/Channel** | 메시지 분류 기준 |

---

### 2.3 Pub-Sub 동작 흐름

```
동작 순서:

1. 구독 단계:
   subscriberA.subscribe("news")
   subscriberB.subscribe("news")
   subscriberC.subscribe("sports")
   → Event Channel에 구독 정보 등록

2. 발행 단계:
   publisherX.publish("news", "새 뉴스 발생")
   → Event Channel에 메시지 전달

3. 라우팅:
   Event Channel
   ├─→ "news" 토픽 구독자 확인
   └─→ subscriberA, subscriberB에게만 전달

4. 전달:
   subscriberA.onMessage("새 뉴스 발생")
   subscriberB.onMessage("새 뉴스 발생")
   subscriberC는 받지 않음 (다른 토픽 구독)
```

---

### 2.4 Pub-Sub 예시

**실시간 알림 시스템**:

```
구조:

PublisherA → "user-login" 토픽으로 발행
PublisherB → "order-created" 토픽으로 발행
PublisherC → "payment-completed" 토픽으로 발행
              ↓
      [Message Broker]
      (토픽별 라우팅)
              ↓
SubscriberX ← "user-login" 구독 (로그 기록)
SubscriberY ← "user-login" 구독 (통계 수집)
SubscriberZ ← "order-created" 구독 (재고 감소)
```

**시나리오**:

| 이벤트 | Publisher | Topic | Subscriber | 동작 |
|--------|-----------|-------|------------|------|
| 로그인 | AuthService | "user-login" | LogService | 로그 기록 |
| 로그인 | AuthService | "user-login" | AnalyticsService | 통계 업데이트 |
| 주문 | OrderService | "order-created" | InventoryService | 재고 감소 |
| 주문 | OrderService | "order-created" | EmailService | 주문 확인 메일 |

---

### 2.5 Pub-Sub의 장단점

| 구분 | 내용 |
|------|------|
| **장점** | • 완전한 분리 (퍼블리셔 ↔ 서브스크라이버 독립)<br>• 확장성 매우 높음<br>• 동적 토픽 구독<br>• 비동기 처리 용이<br>• 메시지 필터링, 버퍼링 가능 |
| **단점** | • 중간 브로커 필요 (복잡도↑)<br>• 메시지 전달 보장 어려움 (브로커 장애 시)<br>• 디버깅 어려움 (간접 연결)<br>• 메시지 순서 보장 복잡 |

---

## 3. 옵저버 vs Pub-Sub

| 비교 | 옵저버 패턴 | Pub-Sub 패턴 |
|------|------------|--------------|
| **연결 방식** | **직접 연결** (Subject ↔ Observer) | **간접 연결** (중간 브로커 경유) |
| **결합도** | 느슨한 결합 (하지만 서로 알고 있음) | 완전 분리 (서로 모름) |
| **통신 방식** | 동기적 (주로) | 비동기적 (주로) |
| **중개자** | 없음 | Event Channel/Broker 존재 |
| **확장성** | 제한적 | 매우 높음 |
| **메시지 필터링** | Subject가 직접 처리 | Broker가 토픽/채널로 처리 |
| **관계** | 1:N (한 Subject → 여러 Observer) | M:N (여러 Publisher → 여러 Subscriber) |
| **사용 사례** | UI 이벤트, 모델-뷰 동기화 | 마이크로서비스, 이벤트 기반 아키텍처 |

```
옵저버 패턴:

Subject ──직접 호출──→ ObserverA
        ├────────────→ ObserverB
        └────────────→ ObserverC

→ Subject가 모든 Observer를 알고 있음


Pub-Sub 패턴:

PublisherA ──발행──→ [Event Broker] ──전달──→ SubscriberX
PublisherB ──발행──→ [토픽별 라우팅] ──전달──→ SubscriberY
                                      ──전달──→ SubscriberZ

→ Publisher와 Subscriber는 서로 모름
```

---

## 4. 상세 비교

### 4.1 구조적 차이

| 특징 | 옵저버 | Pub-Sub |
|------|--------|---------|
| **Subject/Publisher가 Observer/Subscriber를 아는가?** | Yes (리스트로 보유) | No (브로커만 앎) |
| **Observer/Subscriber가 Subject/Publisher를 아는가?** | Yes (참조 필요) | No (토픽만 앎) |
| **메시지 전달** | Subject가 직접 호출 | Broker가 중개 |
| **토픽/채널** | 없음 | 있음 (메시지 분류) |

---

### 4.2 동작 방식 차이

```
옵저버 패턴 흐름:

subject.setState(100)
└─→ subject.notify()
    ├─→ observerA.update() ← 직접 호출
    ├─→ observerB.update() ← 직접 호출
    └─→ observerC.update() ← 직접 호출


Pub-Sub 패턴 흐름:

publisher.publish("topic", data)
└─→ broker.receive("topic", data)
    └─→ broker.route("topic")
        ├─→ subscriberX.onMessage(data) ← 브로커가 전달
        └─→ subscriberY.onMessage(data) ← 브로커가 전달
```

---

### 4.3 메모리 관리

| 패턴 | 메모리 누수 위험 | 이유 |
|------|-----------------|------|
| **옵저버** | 높음 | Subject가 Observer 참조 보유, detach() 안 하면 GC 불가 |
| **Pub-Sub** | 낮음 | Broker가 관리, 서브스크라이버 종료 시 자동 정리 가능 |

---

## 5. 사용 시기

### 5.1 옵저버 패턴 사용 시기

| 상황 | 설명 |
|------|------|
| **단일 애플리케이션** | 같은 프로세스 내에서 객체 간 통신 |
| **즉각 반응** | 상태 변화를 즉시 전파 (동기적) |
| **간단한 의존 관계** | 1:N 관계가 명확 |
| **UI 이벤트** | 버튼 클릭, 모델 변경 시 뷰 업데이트 |
| **경량 시스템** | 추가 인프라 불필요 |

**예시**:
- GUI 프레임워크 (MVC 패턴)
- 이벤트 리스너 (버튼 클릭, 키보드 입력)
- 데이터 바인딩 (모델 ↔ 뷰)

---

### 5.2 Pub-Sub 패턴 사용 시기

| 상황 | 설명 |
|------|------|
| **분산 시스템** | 여러 서버/서비스 간 통신 |
| **비동기 처리** | 메시지 큐잉, 배치 처리 |
| **확장성 필요** | 퍼블리셔/서브스크라이버 동적 추가 |
| **메시지 필터링** | 토픽별 선택적 수신 |
| **느슨한 결합** | 완전 독립적 컴포넌트 |

**예시**:
- 마이크로서비스 아키텍처
- 실시간 알림 시스템
- IoT 데이터 수집
- 로그 수집 및 분석
- 이벤트 소싱

---

## 6. 실전 구현 예시

### 6.1 옵저버 패턴 구현

```
핵심 인터페이스:

Observer
└─ update(data)

Subject
├─ attach(observer)
├─ detach(observer)
└─ notify()

구현 시 주의사항:
• Observer 리스트 동기화 (멀티스레드)
• detach() 반드시 호출 (메모리 누수 방지)
• notify() 중 예외 처리 (한 옵저버 실패 시 다른 옵저버 영향 최소화)
```

---

### 6.2 Pub-Sub 패턴 구현

```
핵심 컴포넌트:

EventBus/MessageBroker
├─ subscribe(topic, subscriber)
├─ unsubscribe(topic, subscriber)
└─ publish(topic, message)

구현 시 주의사항:
• 토픽별 서브스크라이버 관리 (Map<Topic, List<Subscriber>>)
• 메시지 큐잉 (비동기 처리)
• 에러 핸들링 (서브스크라이버 실패 시)
• 메시지 직렬화 (네트워크 전송 시)
```

**실제 기술 스택**:

| 기술 | 용도 | 특징 |
|------|------|------|
| **Redis Pub/Sub** | 간단한 메시징 | 빠르지만 메시지 영속성 없음 |
| **RabbitMQ** | 메시지 큐 | 메시지 보장, 라우팅 다양 |
| **Apache Kafka** | 대용량 이벤트 스트리밍 | 높은 처리량, 영속성 |
| **AWS SNS/SQS** | 클라우드 메시징 | 관리형 서비스 |

---

## 7. 핵심 정리

| 패턴 | 핵심 포인트 |
|------|-----------|
| **옵저버** | • Subject와 Observer **직접 연결**<br>• **동기적** 통신<br>• **느슨한 결합** (하지만 서로 앎)<br>• 단일 애플리케이션 적합 |
| **Pub-Sub** | • **중간 브로커** 경유<br>• **비동기적** 통신<br>• **완전 분리** (서로 모름)<br>• 분산 시스템 적합 |

```
선택 가이드:

같은 프로세스 내? → 옵저버
여러 서버 간 통신? → Pub-Sub
즉각 반응 필요? → 옵저버
비동기 처리? → Pub-Sub
간단한 구조? → 옵저버
확장성 중요? → Pub-Sub
```

---

## 면접 질문

### Q1. 옵저버 패턴과 Pub-Sub 패턴의 가장 큰 차이는?

**핵심 답변**:

| 차이점 | 옵저버 패턴 | Pub-Sub 패턴 |
|--------|------------|--------------|
| **핵심 차이** | **직접 연결** (Subject ↔ Observer 서로 앎) | **간접 연결** (중간 브로커, 서로 모름) |
| **결합도** | 느슨한 결합 | 완전 분리 |
| **구조** | Subject가 Observer 리스트 보유 | Broker가 중개 |

```
옵저버:
Subject ─(알고 있음)─→ Observer
Observer ─(참조함)─→ Subject

Pub-Sub:
Publisher ──→ [Broker] ←── Subscriber
(서로 모름)    (중개자)    (서로 모름)
```

**추가 설명**:
- **옵저버**: Subject가 notify() 호출 시 직접 observer.update() 실행
- **Pub-Sub**: Publisher는 발행만, Broker가 라우팅하여 Subscriber에 전달

**비유**:
- 옵저버: 선생님(Subject)이 학생들(Observer)을 직접 불러서 공지
- Pub-Sub: 방송국(Publisher)이 전파(Broker)를 통해 라디오(Subscriber)로 전달

---

### Q2. 왜 Pub-Sub이 더 확장성이 높은가?

**답변**:

| 이유 | 설명 |
|------|------|
| **동적 추가/제거** | 퍼블리셔나 서브스크라이버가 브로커에만 등록, 서로 영향 없음 |
| **다대다 관계** | M개 퍼블리셔 → N개 서브스크라이버 자유롭게 연결 |
| **토픽 분리** | 토픽별 독립 처리, 서브스크라이버가 관심 토픽만 구독 |
| **분산 배치** | 브로커만 통신하므로 물리적 위치 무관 |
| **부하 분산** | 여러 서브스크라이버가 같은 토픽 처리 (워커 패턴) |

```
옵저버의 한계:

Subject에 100개 Observer 등록
→ Subject가 100개 참조 보유
→ notify() 시 100번 직접 호출
→ 하나라도 느리면 전체 지연

Pub-Sub의 확장성:

100개 Publisher → Broker → 1000개 Subscriber
→ Publisher는 브로커에만 발행
→ Broker가 비동기 라우팅
→ Subscriber 추가해도 Publisher 영향 없음
→ 브로커 클러스터링으로 수평 확장
```

**헷갈리기 쉬운 포인트**:

"옵저버도 인터페이스 쓰면 느슨한 결합 아닌가요?"
→ 맞지만 **Subject가 여전히 Observer를 직접 보유하고 호출**함. Pub-Sub은 **서로의 존재 자체를 모름**, Broker만 알면 됨.

"Pub-Sub도 결국 Observer 패턴의 확장 아닌가요?"
→ 개념적으로는 유사하지만, **중간 브로커의 유무**가 핵심. 브로커가 있으면:
- 메시지 큐잉 가능
- 메시지 필터링/라우팅
- 영속성 보장 가능
- 여러 서버에 분산 배치 가능

**선택 기준**:

| 상황 | 선택 |
|------|------|
| 같은 프로세스, 간단한 이벤트 | 옵저버 |
| 마이크로서비스, 수평 확장 필요 | Pub-Sub |
| 실시간 동기 응답 필요 | 옵저버 |
| 메시지 큐잉, 재시도 필요 | Pub-Sub |
| 추가 인프라 없이 구현 | 옵저버 |
| Redis, Kafka 등 사용 가능 | Pub-Sub |