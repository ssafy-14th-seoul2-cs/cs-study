# 전략 & 템플릿 메서드 패턴

## 들어가기 전 알아야 할 개념

| 개념 | 설명 |
|------|------|
| **상속** | 부모 클래스의 기능을 자식 클래스가 물려받음 |
| **인터페이스** | 구현해야 할 메서드 명세만 정의 |
| **다형성** | 같은 인터페이스로 다른 동작 수행 |
| **알고리즘** | 특정 문제를 해결하는 절차나 방법 |

---

## 1. 전략 패턴 (Strategy Pattern)

### 1.1 정의

**정의**: 알고리즘을 캡슐화하여 동적으로 교체 가능하게 만드는 패턴

**핵심 아이디어**: 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있음

**목적**:
- 알고리즘 군을 정의하고 캡슐화
- 런타임에 알고리즘 교체 가능
- 조건문(if-else, switch) 제거

---

### 1.2 전략 패턴 구조

```
┌──────────────┐
│   Context    │ ← 전략을 사용하는 클래스
├──────────────┤
│ - strategy   │ ← 전략 객체 보유
├──────────────┤
│ + setStrategy()│
│ + execute()  │
└───────┬──────┘
        │사용
        ↓
┌──────────────────┐
│ Strategy         │ ← 인터페이스
├──────────────────┤
│ + algorithm()    │
└────────┬─────────┘
         │구현
    ┌────┴──────────────┐
    │                   │
┌───┴────────┐   ┌──────┴──────┐
│StrategyA   │   │StrategyB    │
├────────────┤   ├─────────────┤
│ algorithm()│   │ algorithm() │
└────────────┘   └─────────────┘
```

**구성 요소**:

| 요소 | 역할 |
|------|------|
| **Strategy** | 알고리즘 인터페이스 정의 |
| **ConcreteStrategy** | 실제 알고리즘 구현 |
| **Context** | Strategy를 사용하는 클래스, 런타임에 교체 가능 |

---

### 1.3 전략 패턴 동작 흐름

```
동작 순서:

1. Context 생성
   context = new Context()

2. 전략 설정
   context.setStrategy(new StrategyA())

3. 실행
   context.execute() → StrategyA의 algorithm() 호출

4. 전략 변경
   context.setStrategy(new StrategyB())

5. 다시 실행
   context.execute() → StrategyB의 algorithm() 호출
```

---

### 1.4 전략 패턴 예시

**결제 시스템**:

| 전략(Strategy) | 구체적 구현 |
|----------------|-------------|
| **PaymentStrategy** | 인터페이스: pay() |
| **CreditCardStrategy** | 신용카드 결제 로직 |
| **KakaoPayStrategy** | 카카오페이 결제 로직 |
| **NaverPayStrategy** | 네이버페이 결제 로직 |

```
전통적 방식 (조건문):

if (paymentType == "creditcard") {
    // 신용카드 결제
} else if (paymentType == "kakaopay") {
    // 카카오페이 결제
} else if (paymentType == "naverpay") {
    // 네이버페이 결제
}

전략 패턴:

context.setStrategy(kakaoPayStrategy)
context.pay() → 카카오페이로 결제

context.setStrategy(naverPayStrategy)
context.pay() → 네이버페이로 결제
```

---

### 1.5 전략 패턴의 장단점

| 구분 | 내용 |
|------|------|
| **장점** | • 알고리즘 교체 용이 (런타임 변경)<br>• 조건문 제거로 코드 간결<br>• 개방-폐쇄 원칙 준수 (새 전략 추가 쉬움)<br>• 테스트 용이 (각 전략 독립 테스트) |
| **단점** | • 클래스 개수 증가<br>• 클라이언트가 전략을 알고 선택해야 함<br>• 전략이 적으면 오버엔지니어링 |

---

### 1.6 전략 패턴 사용 시기

| 상황 | 설명 |
|------|------|
| **유사한 알고리즘 다수** | 같은 목적의 여러 알고리즘이 존재 |
| **런타임 교체 필요** | 실행 중 알고리즘 변경 필요 |
| **조건문 과다** | if-else, switch가 복잡하게 얽힘 |
| **알고리즘 독립성** | 알고리즘을 클라이언트와 분리 |

---

## 2. 템플릿 메서드 패턴 (Template Method Pattern)

### 2.1 정의

**정의**: 알고리즘의 골격을 정의하고, 일부 단계를 서브클래스에서 구현하도록 하는 패턴

**핵심 아이디어**: 전체 알고리즘 구조는 상위 클래스에서 정의하고, 세부 구현은 하위 클래스에 위임

**목적**:
- 알고리즘 구조 재사용
- 공통 로직 중복 제거
- 변하지 않는 부분과 변하는 부분 분리

---

### 2.2 템플릿 메서드 구조

```
┌─────────────────────────┐
│   Abstract Class        │ ← 추상 클래스
├─────────────────────────┤
│ + templateMethod()      │ ← 템플릿 메서드 (final)
│   ├─ step1()            │ ← 공통 로직
│   ├─ step2()            │ ← 추상 메서드 (구현 위임)
│   └─ step3()            │ ← 공통 로직
├─────────────────────────┤
│ # step1()               │ ← 구체 메서드
│ # step2() (abstract)    │ ← 추상 메서드
│ # step3()               │ ← 구체 메서드
└──────────┬──────────────┘
           │상속
    ┌──────┴───────────┐
    │                  │
┌───┴────────┐  ┌──────┴──────┐
│ConcreteA   │  │ConcreteB    │
├────────────┤  ├─────────────┤
│ step2()    │  │ step2()     │ ← 추상 메서드 구현
└────────────┘  └─────────────┘
```

**구성 요소**:

| 요소 | 역할 |
|------|------|
| **Abstract Class** | 템플릿 메서드 정의, 알고리즘 골격 제공 |
| **Template Method** | 알고리즘 구조 정의 (보통 final) |
| **Primitive Operations** | 서브클래스에서 구현할 추상 메서드 |
| **Concrete Class** | 추상 메서드 구체적 구현 |

---

### 2.3 템플릿 메서드 동작 흐름

```
실행 흐름:

Client → ConcreteA.templateMethod() 호출
         │
         └─→ AbstractClass의 templateMethod() 실행
             │
             ├─ step1() (공통) ← AbstractClass 구현
             ├─ step2() (변경) ← ConcreteA 구현
             └─ step3() (공통) ← AbstractClass 구현

핵심: 전체 흐름은 상위 클래스가 제어, 세부 구현만 하위 클래스
```

---

### 2.4 템플릿 메서드 예시

**음료 제조 과정**:

| 단계 | 공통/변경 | 설명 |
|------|----------|------|
| 1. 물 끓이기 | **공통** | 모든 음료에서 동일 |
| 2. 재료 우려내기 | **변경** | 커피: 커피 우리기 / 차: 차 우리기 |
| 3. 컵에 따르기 | **공통** | 모든 음료에서 동일 |
| 4. 첨가물 추가 | **변경** | 커피: 설탕/우유 / 차: 레몬 |

```
템플릿 메서드 구조:

AbstractBeverage
└─ prepareRecipe() [템플릿 메서드]
   ├─ boilWater()        [구체 메서드 - 공통]
   ├─ brew()             [추상 메서드 - 변경]
   ├─ pourInCup()        [구체 메서드 - 공통]
   └─ addCondiments()    [추상 메서드 - 변경]

Coffee (구현)
├─ brew() → "커피 우리기"
└─ addCondiments() → "설탕과 우유 추가"

Tea (구현)
├─ brew() → "차 우리기"
└─ addCondiments() → "레몬 추가"
```

---

### 2.5 Hook 메서드

**정의**: 서브클래스가 선택적으로 오버라이드할 수 있는 메서드

| 메서드 타입 | 설명 | 오버라이드 |
|------------|------|-----------|
| **추상 메서드** | 반드시 구현해야 함 | 필수 |
| **구체 메서드** | 기본 구현 제공 | 불가 (final) |
| **Hook 메서드** | 기본 구현 있음, 선택적 오버라이드 | 선택 |

```
Hook 메서드 예시:

AbstractClass
└─ templateMethod()
   ├─ step1()
   ├─ step2() [추상 - 필수 구현]
   ├─ step3()
   └─ customerWantsCondiments() [Hook - 선택 구현]
      └─ 기본값: return true

ConcreteClass
└─ customerWantsCondiments() 오버라이드
   └─ return false (첨가물 원하지 않음)
```

---

### 2.6 템플릿 메서드의 장단점

| 구분 | 내용 |
|------|------|
| **장점** | • 코드 재사용성 높음 (공통 로직 상위 클래스)<br>• 알고리즘 구조 통제 (상위 클래스가 제어)<br>• 중복 코드 제거<br>• 할리우드 원칙 (Don't call us, we'll call you) |
| **단점** | • 상속 구조 강제 (상속의 단점 포함)<br>• 알고리즘 단계가 많으면 복잡<br>• 템플릿 메서드 수정 시 모든 서브클래스 영향 |

---

### 2.7 템플릿 메서드 사용 시기

| 상황 | 설명 |
|------|------|
| **공통 로직 존재** | 여러 클래스가 유사한 알고리즘 구조 공유 |
| **알고리즘 골격 고정** | 전체 흐름은 변경 불가, 세부만 변경 |
| **중복 코드 제거** | 공통 부분을 상위 클래스로 추출 |
| **제어 역전** | 상위 클래스가 하위 클래스 메서드 호출 |

---

## 3. 전략 vs 템플릿 메서드

| 비교 | 전략 패턴 | 템플릿 메서드 패턴 |
|------|-----------|-------------------|
| **관계** | **구성 (Composition)** | **상속 (Inheritance)** |
| **알고리즘 교체** | 런타임에 동적 교체 | 컴파일 타임에 고정 |
| **구조** | Context가 Strategy 객체 보유 | 서브클래스가 부모 상속 |
| **변경 범위** | 전체 알고리즘 교체 | 알고리즘 일부 단계만 변경 |
| **유연성** | 높음 (런타임 교체) | 낮음 (상속으로 고정) |
| **결합도** | 낮음 (인터페이스 의존) | 높음 (부모에 의존) |
| **클라이언트 역할** | 전략 선택 및 설정 | 서브클래스 선택만 |
| **목적** | 알고리즘 캡슐화 | 알고리즘 구조 재사용 |

```
전략 패턴:

Context ──has-a──→ Strategy
  │                   ↑
  │              ┌────┴────┐
  │              A         B
  └─→ 런타임에 A ↔ B 교체 가능


템플릿 메서드:

AbstractClass
  ↑ is-a
  │
┌─┴─┐
A   B
└─→ 컴파일 시 A 또는 B 선택, 이후 변경 불가
```

---

## 4. 언제 무엇을 사용할까?

| 선택 기준 | 전략 패턴 | 템플릿 메서드 패턴 |
|----------|-----------|-------------------|
| **런타임 교체 필요** | ✓ 사용 | ✗ 부적합 |
| **알고리즘 전체 교체** | ✓ 사용 | ✗ 부적합 |
| **공통 로직 재사용** | △ 가능하나 비효율 | ✓ 최적 |
| **알고리즘 구조 고정** | ✗ 부적합 | ✓ 사용 |
| **상속 피하고 싶음** | ✓ 사용 (구성 활용) | ✗ 불가 (상속 필수) |
| **다중 알고리즘 조합** | ✓ 여러 전략 조합 가능 | ✗ 어려움 |

---

## 5. 실전 사용 예시

### 전략 패턴 사용 예시

| 시스템 | 전략 대상 |
|--------|-----------|
| **정렬** | QuickSort, MergeSort, BubbleSort |
| **압축** | ZIP, RAR, GZIP |
| **암호화** | AES, DES, RSA |
| **로깅** | FileLogger, ConsoleLogger, CloudLogger |
| **할인** | PercentDiscount, AmountDiscount, NoDiscount |

### 템플릿 메서드 사용 예시

| 시스템 | 공통 골격 |
|--------|-----------|
| **데이터 처리** | 읽기 → 처리 → 쓰기 (처리만 변경) |
| **게임 AI** | 상태 확인 → 행동 선택 → 실행 (선택만 변경) |
| **테스트** | setUp → 테스트 실행 → tearDown |
| **웹 요청** | 인증 → 요청 처리 → 응답 (처리만 변경) |

---

## 6. 핵심 정리

| 패턴 | 핵심 포인트 |
|------|-----------|
| **전략** | • 알고리즘을 **캡슐화**하여 교체 가능<br>• **구성(Composition)** 사용<br>• **런타임** 변경 가능<br>• 조건문 제거 |
| **템플릿 메서드** | • 알고리즘 **골격 정의**, 세부는 위임<br>• **상속(Inheritance)** 사용<br>• **컴파일 타임** 고정<br>• 코드 재사용 |

```
선택 가이드:

런타임에 교체 필요? → 전략 패턴
공통 로직이 많고 일부만 변경? → 템플릿 메서드
상속 피하고 싶음? → 전략 패턴
알고리즘 구조는 고정? → 템플릿 메서드
```

---

## 면접 질문

### Q1. 전략 패턴과 템플릿 메서드 패턴의 가장 큰 차이는?

**핵심 답변**:

| 차이점 | 전략 패턴 | 템플릿 메서드 패턴 |
|--------|-----------|-------------------|
| **핵심 차이** | **구성(Has-a)** | **상속(Is-a)** |
| **교체 시점** | 런타임 동적 교체 | 컴파일 타임 고정 |
| **변경 범위** | 전체 알고리즘 교체 | 알고리즘의 일부 단계만 변경 |

```
전략 패턴:
Context context = new Context(new StrategyA())
context.execute() → A 실행
context.setStrategy(new StrategyB()) ← 런타임 교체
context.execute() → B 실행

템플릿 메서드:
ConcreteA a = new ConcreteA()
a.templateMethod() → A의 구현 실행
ConcreteB b = new ConcreteB() ← 객체 자체를 바꿔야 함
b.templateMethod() → B의 구현 실행
```

**추가 설명**:
- 전략: 알고리즘을 **객체로** 취급 (교체 가능한 부품처럼)
- 템플릿 메서드: 알고리즘을 **클래스로** 정의 (상속으로 변형)

---

### Q2. 둘 다 알고리즘을 다루는데, 언제 어떤 것을 선택해야 하는가?

**판단 기준**:

| 질문 | Yes → 전략 | Yes → 템플릿 메서드 |
|------|-----------|-------------------|
| 실행 중 알고리즘을 바꿔야 하는가? | ✓ | |
| 전체 알고리즘을 통째로 교체하는가? | ✓ | |
| 알고리즘들이 공통 골격을 공유하는가? | | ✓ |
| 공통 로직이 많고 일부만 다른가? | | ✓ |
| 상속을 사용해도 괜찮은가? | | ✓ |
| 여러 알고리즘을 조합해야 하는가? | ✓ | |

**구체적 예시**:

```
상황 1: 결제 방식 선택
- 사용자가 체크아웃 시 결제 방식 선택
- 신용카드 ↔ 카카오페이 ↔ 네이버페이 전환
→ 전략 패턴 (런타임 교체 필요)

상황 2: 데이터 리포트 생성
- 모든 리포트: 데이터 로드 → 가공 → 저장
- 가공 방식만 다름 (CSV, Excel, PDF)
→ 템플릿 메서드 (공통 골격 + 일부 변경)
```

**헷갈리기 쉬운 포인트**:

"전략 패턴도 상속을 쓸 수 있지 않나요?"
→ 전략에서 Strategy 인터페이스를 구현할 때 상속 사용하지만, **Context와 Strategy는 구성 관계**. 핵심은 Context가 Strategy 객체를 **교체 가능하게 보유**한다는 점.

"템플릿 메서드도 런타임에 바꿀 수 있지 않나요?"
→ 객체를 새로 생성하면 가능하지만, **같은 객체의 알고리즘을 런타임에 바꿀 수는 없음**. 전략 패턴은 객체는 그대로 두고 내부 전략만 교체.