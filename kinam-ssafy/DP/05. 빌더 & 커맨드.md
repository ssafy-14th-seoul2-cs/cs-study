# 빌더 & 커맨드 패턴

## 들어가기 전에

### 디자인 패턴 복습

```
생성 패턴 (객체 생성 방식)
└─ 빌더: 복잡한 객체를 단계별로 생성 ← 오늘 학습

행위 패턴 (객체 간 협력)
└─ 커맨드: 요청을 객체로 캡슐화 ← 오늘 학습
```

---

## 빌더 패턴 (Builder Pattern)

### 핵심 개념

**패턴 정의**
- 복잡한 객체의 생성 과정을 **단계별로 분리**하는 패턴
- 동일한 생성 절차로 **다양한 표현**의 객체를 생성

### 빌더 패턴이 필요한 이유

**문제 상황 1: 점층적 생성자 패턴**

```java
// 나쁜 예: 생성자 폭발
Pizza(int size) { }
Pizza(int size, boolean cheese) { }
Pizza(int size, boolean cheese, boolean pepperoni) { }
Pizza(int size, boolean cheese, boolean pepperoni, boolean bacon) { }
// ... 무한 증가

// 사용 시 문제
Pizza pizza = new Pizza(12, true, false, true, false);
// 무엇이 무엇인지 알 수 없음
```

**문제 상황 2: 자바빈즈 패턴**

```java
// 나쁜 예: setter 남용
Pizza pizza = new Pizza();
pizza.setSize(12);
pizza.setCheese(true);
// 문제: 객체가 일관성 없는 중간 상태로 존재
// 문제: 불변 객체를 만들 수 없음
```

### 구조

```
┌──────────────┐
│   Builder    │ ← 생성 단계 정의
│  (interface) │
└──────┬───────┘
       │
┌──────┴────────┐
│ConcreteBuilder│ ← 실제 조립
└──────┬────────┘
       │
       ↓
┌──────────────┐
│   Product    │ ← 최종 객체
└──────────────┘
```

### 구성 요소

| 요소 | 역할 |
|------|------|
| **Builder** | 객체 생성 단계를 정의하는 인터페이스 |
| **ConcreteBuilder** | 실제 객체 조립 로직 구현 |
| **Product** | 최종 생성되는 복잡한 객체 |
| **Director** | (선택) 생성 과정을 지휘 |

### 동작 흐름

```
1. Builder 객체 생성
   ↓
2. method1().method2().method3() (메서드 체이닝)
   ↓
3. build() 호출
   ↓
4. 완전한 Product 반환
```

### 코드 흐름 예시

```java
// Product
class Pizza {
    private final int size;        // 필수
    private final boolean cheese;  // 선택
    private final boolean pepperoni;
    
    private Pizza(Builder builder) {
        this.size = builder.size;
        this.cheese = builder.cheese;
        this.pepperoni = builder.pepperoni;
    }
    
    // Builder (내부 정적 클래스)
    public static class Builder {
        private final int size;  // 필수
        private boolean cheese = false;  // 선택 (기본값)
        private boolean pepperoni = false;
        
        public Builder(int size) {  // 필수는 생성자
            this.size = size;
        }
        
        public Builder cheese(boolean value) {  // 선택은 메서드
            cheese = value;
            return this;  // 체이닝을 위해 this 반환
        }
        
        public Builder pepperoni(boolean value) {
            pepperoni = value;
            return this;
        }
        
        public Pizza build() {
            return new Pizza(this);
        }
    }
}

// 사용
Pizza pizza = new Pizza.Builder(12)
    .cheese(true)
    .pepperoni(true)
    .build();
```

**핵심 포인트**
```
1. 생성자는 private → 외부에서 직접 생성 불가
2. Builder는 static 내부 클래스
3. 필수 매개변수 → Builder 생성자
4. 선택 매개변수 → 메서드 (return this)
5. build()에서 최종 객체 생성
```

### 장단점

| 장점 | 단점 |
|------|------|
| 가독성 향상 (어떤 값인지 명확) | 코드량 증가 |
| 불변 객체 생성 가능 | 작은 객체엔 과도 |
| 객체 생성 일관성 보장 | 성능 오버헤드 |
| 선택적 매개변수 처리 용이 | |
| 메서드 체이닝 | |

### 빌더 변형: Step Builder

```java
// 순서 강제
interface NameStep {
    AgeStep name(String name);
}

interface AgeStep {
    BuildStep age(int age);
}

interface BuildStep {
    User build();
}

// 사용: 순서대로만 호출 가능
User user = new UserBuilder()
    .name("홍길동")  // 1. 이름 먼저 (필수)
    .age(30)        // 2. 나이 다음 (필수)
    .build();       // 3. build만 가능
```

---

## 커맨드 패턴 (Command Pattern)

### 핵심 개념

**패턴 정의**
- 요청(작업)을 **객체로 캡슐화**하는 패턴
- 요청을 큐에 저장, 로그 기록, **실행 취소** 지원

### 언제 사용하나

| 상황 | 설명 |
|------|------|
| 실행 취소(Undo) | 이전 상태로 되돌리기 |
| 요청 큐잉 | 작업을 큐에 저장 후 순차 실행 |
| 로깅/기록 | 모든 작업 기록 |
| 매크로 | 여러 명령 묶어서 실행 |

### 구조

```
┌──────────────┐
│   Command    │ ← 명령 인터페이스
│  + execute() │
│  + undo()    │
└──────┬───────┘
       │
┌──────┴────────┐
│ConcreteCommand│
│ - receiver    │ ← Receiver 참조
└───────────────┘
       │
       ↓
┌──────────────┐
│   Receiver   │ ← 실제 작업 수행
└──────────────┘

       ↑
       │
┌──────────────┐
│   Invoker    │ ← 명령 실행자
└──────────────┘
```

### 구성 요소

| 요소 | 역할 |
|------|------|
| **Command** | 명령 인터페이스 (execute, undo) |
| **ConcreteCommand** | 실제 명령 구현, Receiver 호출 |
| **Receiver** | 실제 작업 수행 |
| **Invoker** | 명령 실행 (버튼, 메뉴 등) |
| **Client** | Command 생성 및 Receiver 설정 |

### 동작 흐름

```
1. Client: ConcreteCommand 생성 (Receiver 설정)
   ↓
2. Invoker: Command 등록
   ↓
3. Invoker.execute() 호출
   ↓
4. Command.execute() 실행
   ↓
5. Receiver.action() 호출 (실제 작업)
   ↓
6. (필요시) 이전 상태 저장 (Undo용)
```

### 코드 흐름 예시: 텍스트 에디터

```java
// Command 인터페이스
interface Command {
    void execute();
    void undo();
}

// Receiver
class TextEditor {
    private StringBuilder text = new StringBuilder();
    
    void write(String words) { text.append(words); }
    void delete(int length) { /* 삭제 로직 */ }
}

// ConcreteCommand
class WriteCommand implements Command {
    private TextEditor editor;
    private String words;
    
    WriteCommand(TextEditor editor, String words) {
        this.editor = editor;
        this.words = words;
    }
    
    public void execute() {
        editor.write(words);  // Receiver 호출
    }
    
    public void undo() {
        editor.delete(words.length());  // 반대 동작
    }
}

// Invoker
class CommandManager {
    private Stack<Command> history = new Stack<>();
    
    void execute(Command cmd) {
        cmd.execute();
        history.push(cmd);  // 기록
    }
    
    void undo() {
        if (!history.isEmpty()) {
            Command cmd = history.pop();
            cmd.undo();
        }
    }
}

// 사용
TextEditor editor = new TextEditor();
CommandManager manager = new CommandManager();

manager.execute(new WriteCommand(editor, "Hello"));
manager.execute(new WriteCommand(editor, " World"));
manager.undo();  // "World" 삭제
```

**핵심 포인트**
```
1. Command는 Receiver를 참조
2. execute()는 Receiver 메서드 호출
3. undo()는 반대 동작 수행
4. Invoker가 Command를 관리 (History)
5. Client는 Command만 생성, 실행은 Invoker가
```

### 매크로 커맨드

```java
// 여러 명령을 묶기
class MacroCommand implements Command {
    private Command[] commands;
    
    MacroCommand(Command[] commands) {
        this.commands = commands;
    }
    
    public void execute() {
        for (Command cmd : commands) {
            cmd.execute();  // 순차 실행
        }
    }
    
    public void undo() {
        // 역순으로 undo
        for (int i = commands.length - 1; i >= 0; i--) {
            commands[i].undo();
        }
    }
}

// 사용
Command[] nightCommands = {
    new LightOffCommand(light1),
    new LightOffCommand(light2),
    new TVOffCommand(tv)
};
Command nightMacro = new MacroCommand(nightCommands);
manager.execute(nightMacro);  // 한 번에 실행
```

### 장단점

| 장점 | 단점 |
|------|------|
| 실행 취소/재실행 가능 | 명령마다 클래스 생성 |
| 요청과 실행 분리 | 단순 작업엔 과도 |
| 명령 조합 가능 (매크로) | |
| 명령 큐잉/로깅 | |

---

## 두 패턴 비교

### 핵심 차이

| 구분 | 빌더 | 커맨드 |
|------|------|--------|
| **분류** | 생성 패턴 | 행위 패턴 |
| **목적** | 객체 생성 | 요청 캡슐화 |
| **초점** | 복잡한 객체 조립 | 작업을 객체로 만들어 제어 |
| **핵심 메서드** | build() | execute(), undo() |

### 적용 시점

```
빌더:
"생성자 매개변수가 너무 많아"
→ 단계별로 설정 후 build()

커맨드:
"작업을 취소하거나 기록하고 싶어"
→ 작업을 객체로 만들어 제어
```

### 구조 비교

```
빌더:
Client → Builder.set1()
              .set2()
              .build() → Product

커맨드:
Client → Command 생성
       → Invoker.execute()
       → Command.execute()
       → Receiver.action()
```

### 판단 기준

| 질문 | 답변 | 패턴 |
|------|------|------|
| 생성자 매개변수 4개 이상? | YES | 빌더 |
| 선택적 매개변수 많음? | YES | 빌더 |
| 불변 객체 필요? | YES | 빌더 |
| Undo 기능 필요? | YES | 커맨드 |
| 작업 큐잉 필요? | YES | 커맨드 |
| 작업 로깅 필요? | YES | 커맨드 |

---

## 핵심 정리

### 패턴별 체크리스트

**빌더 패턴**
```
사용 전 체크:
□ 매개변수 4개 이상?
□ 선택적 매개변수 많음?
□ 불변 객체 필요?

구현 시:
□ 필수 → Builder 생성자
□ 선택 → 메서드 (return this)
□ build()에서 유효성 검증
```

**커맨드 패턴**
```
사용 전 체크:
□ Undo 필요?
□ 작업 큐잉 필요?
□ 작업 로깅 필요?

구현 시:
□ Command는 Receiver 참조
□ execute()는 Receiver 호출
□ undo()는 반대 동작
□ Invoker가 History 관리
```

### 빠른 선택 가이드

```
Q: 객체 생성이 복잡한가?
└─ YES → 빌더

Q: 작업을 취소해야 하나?
└─ YES → 커맨드

Q: 생성 시 단계가 중요한가?
└─ YES → 빌더

Q: 작업을 나중에 실행하거나 기록해야 하나?
└─ YES → 커맨드
```

### 자주 하는 실수

**빌더**
```
❌ 모든 클래스에 빌더 적용
   → 매개변수 2-3개면 일반 생성자로 충분

✅ 매개변수 4개 이상이거나 선택 매개변수 많을 때만
```

**커맨드**
```
❌ 모든 메서드를 Command로 만들기
   → 단순 메서드는 그냥 호출

✅ Undo가 필요하거나 기록이 필요할 때만
```

### 함께 사용하기

```java
// 빌더로 복잡한 Command 생성
Command cmd = new EmailCommand.Builder()
    .to("user@example.com")
    .subject("제목")
    .body("내용")
    .build();

// 커맨드로 실행 제어
manager.execute(cmd);
manager.undo();
```