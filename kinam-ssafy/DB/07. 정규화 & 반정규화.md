# 정규화 & 반정규화

## 들어가기 앞서

**선행 개념**
- 테이블: 행(Row)과 열(Column)로 구성된 데이터 집합
- 기본키(PK): 각 행을 고유하게 식별하는 컬럼
- 외래키(FK): 다른 테이블의 기본키를 참조하는 컬럼
- 중복(Redundancy): 같은 데이터가 여러 곳에 저장됨
- 이상(Anomaly): 데이터 조작 시 발생하는 문제

## 정규화(Normalization)란?

데이터 중복을 최소화하고 무결성을 보장하기 위해 테이블을 분해하는 과정

**목적**
- 데이터 중복 제거
- 이상 현상 방지
- 데이터 일관성 유지
- 저장 공간 효율화

## 이상 현상 3가지

### 정규화 전 테이블 예시

| 학생ID | 학생명 | 학과 | 학과전화 | 과목코드 | 과목명 | 성적 |
|--------|--------|------|----------|----------|--------|------|
| 1 | 김철수 | 컴공 | 02-1111 | CS101 | 자료구조 | A |
| 1 | 김철수 | 컴공 | 02-1111 | CS102 | 알고리즘 | B |
| 2 | 이영희 | 전자 | 02-2222 | EE101 | 회로이론 | A |

### 이상 현상 유형

| 이상 현상 | 설명 | 예시 |
|----------|------|------|
| **삽입 이상** | 불필요한 데이터를 함께 입력해야 함 | 신입생 등록 시 수강과목이 없으면 입력 불가 |
| **갱신 이상** | 중복 데이터 중 일부만 수정 시 불일치 발생 | 학과전화 변경 시 모든 행을 수정해야 함 |
| **삭제 이상** | 필요한 데이터까지 함께 삭제됨 | 김철수가 모든 과목을 취소하면 학생 정보도 삭제됨 |

## 정규화 단계

### 정규형 흐름도

```
비정규형(0NF)
    ↓ 원자값으로 분해
제1정규형(1NF)
    ↓ 부분 함수 종속 제거
제2정규형(2NF)
    ↓ 이행적 함수 종속 제거
제3정규형(3NF)
    ↓ 결정자가 후보키가 아닌 경우 제거
BCNF
    ↓ 다치 종속 제거
제4정규형(4NF)
    ↓ 조인 종속 제거
제5정규형(5NF)
```

**실무에서는 주로 3NF까지 적용**

## 제1정규형 (1NF)

**조건**: 모든 속성 값이 원자값(Atomic Value)이어야 함

### 1NF 위반 예시

| 학생ID | 학생명 | 연락처 |
|--------|--------|--------|
| 1 | 김철수 | 010-1111, 010-2222 |

### 1NF 적용 후

| 학생ID | 학생명 | 연락처 |
|--------|--------|--------|
| 1 | 김철수 | 010-1111 |
| 1 | 김철수 | 010-2222 |

**핵심**: 한 컬럼에 여러 값을 저장하지 않음

## 제2정규형 (2NF)

**조건**: 1NF를 만족하고 + 부분 함수 종속 제거

**부분 함수 종속**: 기본키의 일부에만 종속되는 속성

### 2NF 위반 예시

**기본키: (학생ID, 과목코드)**

| 학생ID | 과목코드 | 학생명 | 과목명 | 성적 |
|--------|----------|--------|--------|------|
| 1 | CS101 | 김철수 | 자료구조 | A |
| 1 | CS102 | 김철수 | 알고리즘 | B |

```
문제점:
- 학생명은 학생ID에만 종속 (부분 함수 종속)
- 과목명은 과목코드에만 종속 (부분 함수 종속)
```

### 2NF 적용 후

**학생 테이블**

| 학생ID (PK) | 학생명 |
|-------------|--------|
| 1 | 김철수 |
| 2 | 이영희 |

**과목 테이블**

| 과목코드 (PK) | 과목명 |
|--------------|--------|
| CS101 | 자료구조 |
| CS102 | 알고리즘 |

**수강 테이블**

| 학생ID (PK) | 과목코드 (PK) | 성적 |
|-------------|--------------|------|
| 1 | CS101 | A |
| 1 | CS102 | B |

**핵심**: 복합키의 일부에만 종속되는 컬럼 분리

## 제3정규형 (3NF)

**조건**: 2NF를 만족하고 + 이행적 함수 종속 제거

**이행적 함수 종속**: A → B, B → C일 때 A → C가 성립

### 3NF 위반 예시

| 학생ID (PK) | 학생명 | 학과코드 | 학과명 | 학과전화 |
|-------------|--------|----------|--------|----------|
| 1 | 김철수 | CS | 컴공 | 02-1111 |
| 2 | 이영희 | EE | 전자 | 02-2222 |

```
함수 종속 관계:
학생ID → 학과코드 → 학과명, 학과전화
(이행적 함수 종속 발생)
```

### 3NF 적용 후

**학생 테이블**

| 학생ID (PK) | 학생명 | 학과코드 (FK) |
|-------------|--------|---------------|
| 1 | 김철수 | CS |
| 2 | 이영희 | EE |

**학과 테이블**

| 학과코드 (PK) | 학과명 | 학과전화 |
|--------------|--------|----------|
| CS | 컴공 | 02-1111 |
| EE | 전자 | 02-2222 |

**핵심**: 기본키가 아닌 컬럼에 종속되는 컬럼 분리

## BCNF (Boyce-Codd Normal Form)

**조건**: 3NF를 만족하고 + 모든 결정자가 후보키

### BCNF 위반 예시

| 학생ID | 과목 | 교수 |
|--------|------|------|
| 1 | DB | 김교수 |
| 2 | DB | 김교수 |
| 3 | 알고리즘 | 이교수 |

```
함수 종속:
(학생ID, 과목) → 교수
교수 → 과목 (한 교수는 한 과목만 강의)
문제: 교수가 결정자이지만 후보키가 아님
```

### BCNF 적용 후

**수강 테이블**

| 학생ID (PK) | 교수 (PK) |
|-------------|----------|
| 1 | 김교수 |
| 2 | 김교수 |
| 3 | 이교수 |

**강의 테이블**

| 교수 (PK) | 과목 |
|----------|------|
| 김교수 | DB |
| 이교수 | 알고리즘 |

## 정규화 단계별 요약

| 정규형 | 제거 대상 | 핵심 조건 |
|--------|----------|----------|
| **1NF** | 반복 그룹 | 원자값만 저장 |
| **2NF** | 부분 함수 종속 | 복합키의 일부에 종속 금지 |
| **3NF** | 이행적 함수 종속 | 일반 컬럼 간 종속 금지 |
| **BCNF** | 결정자가 후보키 아닌 경우 | 모든 결정자는 후보키여야 함 |

## 반정규화(Denormalization)란?

정규화된 테이블을 의도적으로 병합하거나 중복을 허용하여 **조회 성능을 향상**시키는 기법

**목적**
- 조회 성능 향상
- 조인 횟수 감소
- 계산 작업 최소화

## 반정규화 기법

### 1. 테이블 병합

**정규화된 구조**
```
주문 테이블 + 주문상세 테이블 (1:N 관계)
조회 시 항상 JOIN 필요
```

**반정규화**
```
주문+상세 통합 테이블
JOIN 없이 한 번에 조회
```

| 기법 | 설명 | 예시 |
|------|------|------|
| **1:1 병합** | 1:1 관계 테이블 병합 | 회원 + 회원상세 → 회원 |
| **1:N 병합** | 자주 조회되는 1:N 병합 | 주문 + 주문상세 → 주문 |
| **슈퍼/서브타입 병합** | 상속 관계 통합 | 일반회원 + VIP회원 → 회원 |

### 2. 컬럼 중복

**예시**: 주문 테이블에 상품명 추가

| 주문ID | 상품ID (FK) | 상품명 (중복) | 수량 |
|--------|------------|--------------|------|
| 1 | 100 | 노트북 | 1 |
| 2 | 101 | 마우스 | 2 |

```
장점: 상품 테이블 조인 없이 상품명 조회 가능
단점: 상품명 변경 시 모든 주문 데이터 수정 필요
```

### 3. 파생 컬럼 추가

자주 계산하는 값을 미리 저장

| 기법 | 설명 | 예시 |
|------|------|------|
| **집계 컬럼** | SUM, COUNT 등 저장 | 주문 테이블에 총금액 저장 |
| **계산 컬럼** | 계산 결과 저장 | 나이 = 현재년도 - 생년 |
| **상태 플래그** | 자주 확인하는 상태 저장 | is_premium, is_deleted |

**예시**: 주문 총액 미리 계산

| 주문ID | 총금액 (파생) |
|--------|--------------|
| 1 | 1,500,000 |
| 2 | 50,000 |

```sql
-- 반정규화 전: 매번 계산
SELECT order_id, SUM(price * quantity)
FROM order_detail
GROUP BY order_id;

-- 반정규화 후: 저장된 값 조회
SELECT order_id, total_amount
FROM orders;
```

### 4. 이력 테이블 추가

변경 이력을 별도 저장

```
상품 테이블 (현재 가격만 저장)
+ 상품가격이력 테이블 (모든 가격 변경 이력)
```

## 정규화 vs 반정규화

| 구분 | 정규화 | 반정규화 |
|------|--------|----------|
| **목적** | 데이터 무결성, 중복 제거 | 조회 성능 향상 |
| **조회 성능** | 느림 (JOIN 多) | 빠름 (JOIN 少) |
| **저장 공간** | 효율적 | 비효율적 (중복 존재) |
| **삽입/수정/삭제** | 빠름 | 느림 (중복 데이터 관리) |
| **데이터 일관성** | 높음 | 낮음 (관리 필요) |
| **적용 시점** | 설계 초기 | 성능 문제 발생 시 |

## 반정규화 적용 기준

### 반정규화가 필요한 경우

| 상황 | 예시 |
|------|------|
| 조회가 매우 빈번 | 메인 페이지, 상품 목록 |
| JOIN이 과도하게 많음 | 5개 이상 테이블 조인 |
| 집계 연산이 복잡함 | 통계 대시보드 |
| 실시간 응답 필요 | 검색 결과, API 응답 |

### 반정규화 하지 말아야 할 경우

| 상황 | 이유 |
|------|------|
| 데이터 정합성이 중요 | 금융, 결제 시스템 |
| 쓰기 작업이 빈번 | 실시간 주문, 채팅 |
| 저장 공간 제약 | 대용량 데이터 |
| 조회 빈도가 낮음 | 관리자 기능 |

## 반정규화 시 주의사항

### 1. 데이터 동기화 관리

```sql
-- 트리거 활용
CREATE TRIGGER update_total_amount
AFTER INSERT ON order_detail
FOR EACH ROW
UPDATE orders
SET total_amount = total_amount + NEW.price
WHERE order_id = NEW.order_id;
```

### 2. 트랜잭션 처리

```sql
START TRANSACTION;

-- 주문 생성
INSERT INTO orders (id, total_amount) VALUES (1, 1000);

-- 주문상세 생성
INSERT INTO order_detail (order_id, price) VALUES (1, 1000);

COMMIT;
```

### 3. 정합성 검증

```sql
-- 정기적으로 검증
SELECT o.order_id, o.total_amount, SUM(od.price) as calc_amount
FROM orders o
JOIN order_detail od ON o.order_id = od.order_id
GROUP BY o.order_id
HAVING o.total_amount != calc_amount;
```

## 실무 적용 전략

### 단계별 접근

```
1단계: 완전한 정규화 설계
2단계: 성능 테스트 및 병목 구간 파악
3단계: 필요한 부분만 선택적 반정규화
4단계: 모니터링 및 지속적인 최적화
```

### 하이브리드 전략

| 영역 | 전략 |
|------|------|
| **OLTP (트랜잭션)** | 정규화 유지 |
| **OLAP (분석)** | 반정규화 적용 |
| **캐시 레이어** | 반정규화된 데이터 저장 |
| **읽기 전용 복제본** | 반정규화 적용 |

## 핵심 정리

1. **정규화는 기본**: 설계 시 3NF까지 정규화 적용
2. **반정규화는 성능 최적화 기법**: 조회 성능 문제 발생 시 선택적 적용
3. **트레이드오프 인식**: 조회 성능 ↑ vs 데이터 일관성 ↓
4. **상황에 맞는 선택**: OLTP는 정규화, OLAP/분석은 반정규화
5. **점진적 적용**: 성능 테스트 후 필요한 부분만 반정규화
6. **동기화 메커니즘 필수**: 트리거, 배치, 애플리케이션 로직으로 일관성 유지