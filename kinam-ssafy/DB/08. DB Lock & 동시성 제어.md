# DB Lock & 동시성 제어

## 들어가기 앞서

**선행 개념**
- 트랜잭션: 데이터베이스 작업의 논리적 단위
- 동시성(Concurrency): 여러 트랜잭션이 동시에 실행되는 상황
- 격리 수준: 트랜잭션 간 격리 정도 (READ COMMITTED, REPEATABLE READ 등)
- 데이터 정합성: 데이터의 일관성과 정확성

## Lock이란?

여러 트랜잭션이 동시에 같은 데이터에 접근할 때 데이터 정합성을 보장하기 위한 메커니즘

**목적**
- 데이터 무결성 보장
- 동시성 문제 방지
- 일관된 읽기/쓰기 보장

## Lock 없이 발생하는 문제

### Lost Update (갱신 손실)

```
[시나리오: 계좌 잔액 = 1000원]

T1: READ balance (1000)
T2: READ balance (1000)
T1: balance = 1000 + 500 = 1500
T2: balance = 1000 - 300 = 700
T1: WRITE 1500
T2: WRITE 700  ← T1의 +500이 손실됨!

결과: 1200이어야 하는데 700
```

## Lock의 종류

### 1. 공유 Lock vs 배타 Lock

| Lock 종류 | 영문명 | 기호 | 설명 | 다른 트랜잭션 |
|----------|--------|------|------|--------------|
| **공유 Lock** | Shared Lock | S-Lock | 읽기 전용 락 | 읽기 가능, 쓰기 불가 |
| **배타 Lock** | Exclusive Lock | X-Lock | 읽기/쓰기 락 | 읽기/쓰기 모두 불가 |

### Lock 호환성 표

|  | S-Lock | X-Lock |
|---|--------|--------|
| **S-Lock** | ✅ 허용 | ❌ 대기 |
| **X-Lock** | ❌ 대기 | ❌ 대기 |

**예시**
```sql
-- T1: 공유 Lock
SELECT * FROM account WHERE id = 1 FOR SHARE;

-- T2: 읽기 가능
SELECT * FROM account WHERE id = 1 FOR SHARE;  ✅

-- T3: 쓰기 대기
UPDATE account SET balance = 500 WHERE id = 1;  ⏳ 대기
```

### 2. Lock 단위 (Granularity)

| Lock 단위 | 설명 | 장점 | 단점 |
|----------|------|------|------|
| **Row Lock** | 행 단위 잠금 | 동시성 높음 | Lock 관리 오버헤드 |
| **Page Lock** | 페이지 단위 잠금 | 균형적 | 중간 수준 동시성 |
| **Table Lock** | 테이블 전체 잠금 | Lock 관리 간단 | 동시성 낮음 |
| **Database Lock** | DB 전체 잠금 | 백업/복구 시 사용 | 동시성 매우 낮음 |

**실무 선택 기준**

```
Row Lock: 일반적인 OLTP (UPDATE, DELETE)
Table Lock: DDL 작업, 대량 배치 작업
```

### 3. 의도 Lock (Intent Lock)

상위 레벨 Lock을 효율적으로 관리하기 위한 Lock

| Lock 종류 | 설명 |
|----------|------|
| **IS (Intent Shared)** | 하위 레벨에 S-Lock이 존재함을 표시 |
| **IX (Intent Exclusive)** | 하위 레벨에 X-Lock이 존재함을 표시 |
| **SIX** | S-Lock + IX-Lock (테이블 읽기 + 일부 행 수정) |

**Lock 계층 구조**
```
Database
  ↓
Table (IS, IX, S, X)
  ↓
Page (IS, IX, S, X)
  ↓
Row (S, X)
```

## Lock 발생 시점

### SELECT 문

| SQL 문 | Lock 종류 | 설명 |
|--------|----------|------|
| `SELECT *` | Lock 없음 (일반적) | MVCC 사용 시 |
| `SELECT ... FOR SHARE` | S-Lock | 명시적 공유 Lock |
| `SELECT ... FOR UPDATE` | X-Lock | 명시적 배타 Lock |

### DML 문

| SQL 문 | Lock 종류 |
|--------|----------|
| `INSERT` | X-Lock (삽입된 행) |
| `UPDATE` | X-Lock (수정된 행) |
| `DELETE` | X-Lock (삭제된 행) |

### DDL 문

| SQL 문 | Lock 종류 |
|--------|----------|
| `CREATE TABLE` | Database Lock |
| `ALTER TABLE` | Table Lock (X-Lock) |
| `DROP TABLE` | Table Lock (X-Lock) |

## DeadLock (교착 상태)

두 개 이상의 트랜잭션이 서로의 Lock을 기다리며 무한 대기하는 상태

### DeadLock 발생 예시

```
[초기 상태]
계좌A: 1000원
계좌B: 2000원

시간  T1                              T2
1    BEGIN                           BEGIN
2    X-Lock 계좌A                    X-Lock 계좌B
3    UPDATE 계좌A (1000→500)         UPDATE 계좌B (2000→1500)
4    X-Lock 계좌B 요청 ⏳             X-Lock 계좌A 요청 ⏳
5    [T2의 Lock 대기]                [T1의 Lock 대기]
     ← DeadLock 발생! →
```

### DeadLock 4가지 조건

| 조건 | 설명 |
|------|------|
| **상호 배제** | 한 번에 하나의 트랜잭션만 자원 사용 |
| **점유와 대기** | 자원을 가진 채로 다른 자원 대기 |
| **비선점** | 강제로 자원을 빼앗을 수 없음 |
| **순환 대기** | 대기 관계가 원형 구조 |

### DeadLock 해결 방법

| 방법 | 설명 | 예시 |
|------|------|------|
| **예방** | 발생 조건을 원천 차단 | 자원 순서 정의 (항상 계좌A → 계좌B) |
| **회피** | 안전한 상태만 허용 | 은행원 알고리즘 |
| **탐지 & 복구** | 발생 후 감지하여 해결 | 타임아웃, Victim 선택 후 롤백 |

**실무 해결 전략**

```sql
-- 1. 접근 순서 통일
UPDATE account SET balance = balance - 100 
WHERE id IN (1, 2) 
ORDER BY id;  -- 항상 id 순서대로 Lock

-- 2. 트랜잭션 시간 최소화
BEGIN;
-- 빠르게 처리
UPDATE account SET balance = balance - 100 WHERE id = 1;
COMMIT;

-- 3. Lock 타임아웃 설정
SET innodb_lock_wait_timeout = 10;  -- 10초 대기 후 롤백
```

## 동시성 제어 기법

### 1. 2PL (Two-Phase Locking)

트랜잭션을 Growing Phase와 Shrinking Phase로 구분

```
[Growing Phase]
Lock 획득만 가능
Lock 해제 불가

[Shrinking Phase]
Lock 해제만 가능
Lock 획득 불가
```

| Phase | 동작 |
|-------|------|
| **Growing** | Lock 획득, 데이터 읽기/쓰기 |
| **Shrinking** | Lock 해제, 트랜잭션 종료 |

**장점**: 직렬성(Serializability) 보장
**단점**: DeadLock 발생 가능, Cascading Rollback 위험

### 2. MVCC (Multi-Version Concurrency Control)

데이터의 여러 버전을 유지하여 읽기와 쓰기가 서로 블로킹하지 않도록 함

```
[데이터 버전 관리]
Version 1: balance = 1000 (T1이 읽음)
Version 2: balance = 500  (T2가 수정)

T1은 Version 1을 계속 읽음 (일관된 읽기)
T2는 Version 2를 생성 (블로킹 없음)
```

### MVCC 동작 방식

| 동작 | 설명 |
|------|------|
| **읽기** | 트랜잭션 시작 시점의 스냅샷 읽기 |
| **쓰기** | 새로운 버전 생성, Undo Log 기록 |
| **커밋** | 최신 버전으로 확정 |
| **롤백** | Undo Log로 이전 버전 복구 |

**장점**
- 읽기와 쓰기가 서로 블로킹하지 않음
- 높은 동시성
- SELECT 성능 향상

**단점**
- 버전 관리 오버헤드
- Undo Log 공간 필요

### 3. 타임스탬프 기반

각 트랜잭션에 고유한 타임스탬프를 부여하여 순서 제어

```
T1 (TS: 100)
T2 (TS: 200)
T3 (TS: 300)

TS 순서대로 실행됨을 보장
```

| 규칙 | 설명 |
|------|------|
| **Read Rule** | TS가 최신 쓰기 TS보다 크거나 같아야 읽기 가능 |
| **Write Rule** | TS가 최신 읽기/쓰기 TS보다 커야 쓰기 가능 |

## 격리 수준과 Lock의 관계

| 격리 수준 | 읽기 시 Lock | 쓰기 시 Lock | MVCC 사용 |
|----------|-------------|-------------|----------|
| **READ UNCOMMITTED** | Lock 없음 | X-Lock | ❌ |
| **READ COMMITTED** | S-Lock 즉시 해제 | X-Lock | ✅ |
| **REPEATABLE READ** | S-Lock 트랜잭션 종료까지 | X-Lock | ✅ |
| **SERIALIZABLE** | S-Lock 트랜잭션 종료까지 | X-Lock | ❌ |

## Lock 최적화 전략

### 1. Lock 범위 최소화

```sql
-- 나쁨: 불필요한 Lock
BEGIN;
SELECT * FROM account WHERE id = 1 FOR UPDATE;
-- 오랜 시간 걸리는 작업
COMMIT;

-- 좋음: Lock 시간 최소화
-- 오랜 시간 걸리는 작업 먼저
BEGIN;
SELECT * FROM account WHERE id = 1 FOR UPDATE;
UPDATE account SET balance = balance - 100 WHERE id = 1;
COMMIT;
```

### 2. Lock 순서 통일

```sql
-- DeadLock 위험
T1: Lock A → Lock B
T2: Lock B → Lock A

-- DeadLock 방지
T1: Lock A → Lock B
T2: Lock A → Lock B  -- 순서 통일
```

### 3. 인덱스 활용

```sql
-- 나쁨: Table Lock
UPDATE account SET balance = balance - 100;  -- WHERE 없음

-- 좋음: Row Lock
UPDATE account SET balance = balance - 100 
WHERE id = 1;  -- 인덱스 컬럼 사용
```

### 4. Batch 작업 분할

```sql
-- 나쁨: 대량 Lock
UPDATE account SET status = 'inactive' 
WHERE last_login < '2024-01-01';  -- 100만 건

-- 좋음: 작은 단위로 분할
WHILE (조건) {
  UPDATE account SET status = 'inactive' 
  WHERE last_login < '2024-01-01' 
  LIMIT 1000;  -- 1000건씩
  
  COMMIT;
  -- 잠깐 대기
}
```

## Lock 모니터링

### MySQL

```sql
-- 현재 Lock 상황 조회
SELECT * FROM performance_schema.data_locks;

-- Lock 대기 상황
SELECT * FROM performance_schema.data_lock_waits;

-- 트랜잭션 상태
SELECT * FROM information_schema.innodb_trx;
```

### Lock 관련 지표

| 지표 | 의미 | 임계값 |
|------|------|--------|
| **Lock Wait Time** | Lock 대기 시간 | > 1초 주의 |
| **DeadLock 발생 빈도** | DeadLock 횟수 | > 10회/시간 주의 |
| **Lock Timeout** | 타임아웃 횟수 | > 5회/시간 주의 |

## 낙관적 Lock vs 비관적 Lock

| 구분 | 낙관적 Lock | 비관적 Lock |
|------|-----------|------------|
| **전제** | 충돌이 드물다 | 충돌이 자주 발생 |
| **Lock 시점** | 커밋 시점 (버전 체크) | 읽기 시점 (FOR UPDATE) |
| **성능** | 충돌 적을 때 유리 | 충돌 많을 때 유리 |
| **구현** | Version 컬럼 사용 | DB Lock 사용 |
| **롤백** | 애플리케이션 레벨 | DB 레벨 |

### 낙관적 Lock 예시

```sql
-- 1. 읽기 (버전 확인)
SELECT id, balance, version FROM account WHERE id = 1;
-- balance = 1000, version = 5

-- 2. 수정 (버전 체크)
UPDATE account 
SET balance = 900, version = 6
WHERE id = 1 AND version = 5;

-- 다른 트랜잭션이 먼저 수정했다면 UPDATE 실패
```

### 비관적 Lock 예시

```sql
-- 읽기 시점에 Lock
SELECT * FROM account WHERE id = 1 FOR UPDATE;

-- Lock이 걸린 상태에서 수정
UPDATE account SET balance = 900 WHERE id = 1;

COMMIT;  -- Lock 해제
```

### 선택 기준

| 상황 | 권장 방식 |
|------|----------|
| 읽기가 대부분, 수정 드뭄 | 낙관적 Lock |
| 수정 충돌이 빈번 | 비관적 Lock |
| 응답 속도 중요 | 낙관적 Lock |
| 데이터 정합성 최우선 | 비관적 Lock |

## 핵심 정리

1. **Lock은 동시성 제어의 핵심**: 데이터 정합성 보장 위해 필수
2. **S-Lock vs X-Lock**: 읽기는 공유, 쓰기는 배타 Lock
3. **DeadLock 주의**: 접근 순서 통일, 트랜잭션 시간 최소화
4. **MVCC 활용**: 읽기와 쓰기 블로킹 최소화, 높은 동시성
5. **Lock 최소화**: 범위, 시간, 순서 최적화로 성능 향상
6. **상황별 선택**: 낙관적 Lock vs 비관적 Lock 적절히 선택
7. **모니터링 필수**: Lock Wait, DeadLock 지표 지속 관찰