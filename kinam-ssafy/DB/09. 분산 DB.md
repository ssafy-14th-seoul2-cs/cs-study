# 분산 DB

## 들어가기 전 알아야 할 개념

| 개념 | 설명 |
|------|------|
| **ACID** | 트랜잭션의 4가지 속성 (원자성, 일관성, 격리성, 지속성) |
| **트랜잭션** | 논리적 작업 단위, 모두 성공하거나 모두 실패함 |
| **노드** | 분산 시스템을 구성하는 각각의 서버/머신 |
| **네트워크 파티션** | 네트워크 장애로 노드 간 통신이 끊기는 현상 |

---

## 1. 분산 DB란?

**정의**: 물리적으로 분리된 여러 컴퓨터에 데이터를 저장하고 관리하는 데이터베이스 시스템

**등장 배경**:
- 단일 DB의 용량/성능 한계
- 고가용성 필요
- 지리적 분산 요구

---

## 2. 분산 DB의 핵심 기술

### 2.1 파티셔닝 (Partitioning)

**정의**: 큰 테이블을 작은 단위로 분할하여 저장

| 구분 | 수평 파티셔닝 (Horizontal) | 수직 파티셔닝 (Vertical) |
|------|---------------------------|-------------------------|
| **분할 기준** | 행(Row) 단위 | 열(Column) 단위 |
| **방법** | 특정 조건으로 행을 나눔 | 테이블을 컬럼 그룹으로 나눔 |
| **예시** | 2020년 데이터 / 2021년 데이터 | 사용자 기본정보 / 사용자 상세정보 |
| **목적** | 데이터 분산, 성능 향상 | 자주 쓰는 컬럼만 빠르게 조회 |

```
수평 파티셔닝 예시:
User 테이블 → User_2020, User_2021, User_2022

수직 파티셔닝 예시:
User(id, name, email, address, phone, hobby, ...)
→ UserBasic(id, name, email)
→ UserDetail(id, address, phone, hobby, ...)
```

---

### 2.2 샤딩 (Sharding)

**정의**: 수평 파티셔닝을 물리적으로 다른 DB 서버에 분산 저장하는 기법

**샤딩 전략**:

| 전략 | 설명 | 장점 | 단점 |
|------|------|------|------|
| **Range 샤딩** | 특정 범위로 분할 (1-1000, 1001-2000) | 구현 간단, 범위 쿼리 효율적 | 데이터 편중 가능 |
| **Hash 샤딩** | 해시 함수로 분배 (id % N) | 데이터 균등 분배 | 범위 쿼리 비효율, 샤드 추가 시 재배치 |
| **Directory 샤딩** | 별도 조회 테이블 사용 | 유연한 분배 전략 | 조회 테이블이 병목/단일장애점 |
| **Composite 샤딩** | 여러 전략 조합 | 각 전략의 장점 활용 | 복잡도 증가 |

```
Hash 샤딩 예시:
user_id = 15 → hash(15) % 3 = 0 → Shard 0
user_id = 27 → hash(27) % 3 = 1 → Shard 1
user_id = 33 → hash(33) % 3 = 2 → Shard 2
```

---

### 2.3 레플리케이션 (Replication)

**정의**: 동일한 데이터를 여러 노드에 복제하여 저장

**목적**:
- 고가용성 (장애 대응)
- 읽기 성능 향상
- 지리적 분산

| 구분 | Master-Slave | Multi-Master |
|------|--------------|--------------|
| **쓰기** | Master만 가능 | 모든 노드 가능 |
| **읽기** | Master + Slave | 모든 노드 가능 |
| **장점** | 구현 단순, 일관성 유지 쉬움 | 쓰기 성능 향상, 가용성 높음 |
| **단점** | Master 장애 시 쓰기 불가 | 충돌 해결 복잡, 일관성 문제 |
| **사용 사례** | MySQL, PostgreSQL 기본 설정 | Cassandra, DynamoDB |

---

## 3. CAP 이론

**정의**: 분산 시스템에서 3가지 속성 중 2가지만 동시에 만족 가능함을 증명한 정리

| 속성 | 설명 |
|------|------|
| **C (Consistency)** | 모든 노드가 같은 시간에 같은 데이터를 봄 |
| **A (Availability)** | 모든 요청이 항상 응답을 받음 (성공/실패 무관) |
| **P (Partition Tolerance)** | 네트워크 장애가 발생해도 시스템이 동작함 |

```
CAP 트레이드오프:

네트워크 정상 상태 → CA 가능
네트워크 파티션 발생 → CP 또는 AP 선택 필수

CP 시스템: 일관성 우선 (일부 노드 응답 불가)
AP 시스템: 가용성 우선 (일시적 불일치 허용)
```

**주요 DB의 CAP 분류**:

| 분류 | 시스템 | 특징 |
|------|--------|------|
| **CP** | MongoDB, HBase, Redis | 일관성 우선, 파티션 발생 시 일부 노드 사용 불가 |
| **AP** | Cassandra, DynamoDB, CouchDB | 가용성 우선, 최종 일관성(Eventually Consistent) |
| **CA** | PostgreSQL, MySQL (단일 노드) | 분산 환경에서는 사실상 불가능 |

---

## 4. 일관성 모델

| 모델 | 설명 | 특징 |
|------|------|------|
| **강한 일관성** (Strong) | 쓰기 후 즉시 모든 노드에서 최신 데이터 읽기 보장 | 성능↓, 가용성↓ |
| **최종 일관성** (Eventual) | 일정 시간 후 모든 노드가 일치함 (즉시는 아님) | 성능↑, 가용성↑ |
| **인과 일관성** (Causal) | 인과관계 있는 쓰기만 순서 보장 | 중간 수준의 보장 |
| **읽기-본인-쓰기 일관성** | 자신이 쓴 데이터는 즉시 읽기 가능 | 사용자 경험 개선 |

```
최종 일관성 예시:
시간 0: Node1에 데이터 쓰기 (value = 100)
시간 1: Node2 읽기 (value = 50, 아직 미반영)
시간 2: Node3 읽기 (value = 50, 아직 미반영)
시간 3: 복제 완료
시간 4: Node2, Node3 읽기 (value = 100, 반영됨)
```

---

## 5. 분산 트랜잭션

### 2단계 커밋 (2PC, Two-Phase Commit)

**목적**: 분산 환경에서 원자성 보장

**동작 과정**:

| 단계 | 이름 | 동작 |
|------|------|------|
| **1단계** | Prepare (준비) | 코디네이터가 모든 참여자에게 커밋 가능 여부 질의 |
| **2단계** | Commit/Rollback (실행) | 모두 가능하면 커밋, 하나라도 불가면 롤백 |

```
2PC 흐름:

Coordinator → Participants: "커밋 가능?"
Participants → Coordinator: "가능" or "불가"

모두 "가능" → Coordinator: "커밋 실행"
하나라도 "불가" → Coordinator: "롤백 실행"
```

**문제점**:
- 코디네이터 장애 시 블로킹 발생
- 네트워크 지연 시 성능 저하

### 3단계 커밋 (3PC)

**개선점**: 2PC의 블로킹 문제 해결 위해 준비 단계를 2개로 분리

| 단계 | 동작 |
|------|------|
| 1단계 | CanCommit: 커밋 가능 여부 확인 |
| 2단계 | PreCommit: 커밋 준비 (아직 실행X) |
| 3단계 | DoCommit: 실제 커밋 실행 |

---

## 6. 분산 DB vs 단일 DB

| 구분 | 단일 DB | 분산 DB |
|------|---------|---------|
| **확장성** | 수직 확장만 가능 (Scale-Up) | 수평 확장 가능 (Scale-Out) |
| **비용** | 고성능 서버 필요 시 비용↑ | 저렴한 서버 여러 대로 확장 |
| **가용성** | 단일 장애점 존재 (SPOF) | 일부 노드 장애 시에도 서비스 가능 |
| **일관성** | 강한 일관성 보장 용이 | 일관성 유지 어려움 (트레이드오프) |
| **복잡도** | 단순함 | 설계/운영 복잡 |
| **트랜잭션** | ACID 완벽 지원 | 제한적 (2PC, 3PC 필요) |

---

## 7. 핵심 정리

```
분산 DB 설계 시 고려사항:

1. 데이터 분산 전략: 파티셔닝 vs 샤딩 vs 레플리케이션
2. CAP 선택: 일관성 vs 가용성 (둘 다는 불가능)
3. 일관성 수준: 강한 일관성 vs 최종 일관성
4. 트랜잭션: 2PC/3PC 필요 여부
5. 샤딩 키 선택: 데이터 균등 분배 & 쿼리 패턴 고려
```

---

## 면접 질문

### Q1. CAP 이론에서 왜 3가지를 동시에 만족할 수 없는가?

**핵심 답변**:
네트워크 파티션(P)이 발생하면 일관성(C)과 가용성(A) 중 하나를 포기해야 함.

- **CP 선택**: 일관성 보장 위해 일부 노드의 응답을 차단 → 가용성 포기
- **AP 선택**: 모든 노드가 응답 → 노드 간 데이터 불일치 발생 → 일관성 포기

실제로는 파티션 발생이 불가피하므로, CP와 AP 중 선택이 핵심.

---

### Q2. 샤딩과 레플리케이션의 차이는?

| 구분 | 샤딩 | 레플리케이션 |
|------|------|--------------|
| **데이터** | 다른 데이터를 각 노드에 저장 | 같은 데이터를 여러 노드에 복제 |
| **목적** | 데이터 분산, 저장 용량 확장 | 고가용성, 읽기 성능 향상 |
| **쓰기** | 특정 샤드에만 쓰기 | 모든 복제본에 쓰기 필요 |
| **읽기** | 특정 샤드에서만 읽기 | 모든 복제본에서 읽기 가능 |
| **조회 복잡도** | 여러 샤드 조회 시 복잡 | 단일 노드 조회로 충분 |

**헷갈리기 쉬운 포인트**: 
- 샤딩 = 데이터를 **나눔** (분할)
- 레플리케이션 = 데이터를 **복사함** (복제)
- 실무에서는 둘을 함께 사용 (샤딩으로 분산 + 각 샤드를 레플리케이션)