# NoSQL

## 들어가기 전 알아야 할 개념

| 개념 | 설명 |
|------|------|
| **RDBMS** | 관계형 데이터베이스, 테이블 간 관계로 데이터 구조화 |
| **스키마** | 데이터 구조와 제약 조건을 정의한 설계도 |
| **정규화** | 중복 제거를 위해 테이블을 분리하는 과정 |
| **조인** | 여러 테이블의 데이터를 연결하여 조회 |

---

## 1. NoSQL이란?

**정의**: Not Only SQL, 관계형 모델을 사용하지 않는 데이터베이스의 총칭

**등장 배경**:
- 빅데이터 시대 도래 (방대한 데이터 처리 필요)
- 수평 확장의 필요성 (저렴한 서버 추가로 확장)
- 유연한 스키마 요구 (빠른 개발, 구조 변경)
- 높은 읽기/쓰기 성능 필요

**핵심 특징**:
- 스키마 없음 또는 유연한 스키마
- 수평 확장 용이
- 최종 일관성 지향
- 분산 처리에 최적화

---

## 2. RDBMS vs NoSQL

| 구분 | RDBMS | NoSQL |
|------|-------|-------|
| **데이터 모델** | 테이블 (행, 열) | Key-Value, Document, Column, Graph 등 |
| **스키마** | 고정된 스키마 필수 | 스키마 없음 또는 동적 스키마 |
| **확장 방식** | 수직 확장 (Scale-Up) | 수평 확장 (Scale-Out) |
| **일관성** | 강한 일관성 (ACID) | 최종 일관성 (BASE) |
| **조인** | 복잡한 조인 지원 | 조인 없음 또는 제한적 |
| **트랜잭션** | 완벽한 ACID 보장 | 제한적 또는 단일 문서/행 수준 |
| **데이터 중복** | 정규화로 중복 최소화 | 반정규화, 중복 허용 |
| **사용 사례** | 복잡한 쿼리, 트랜잭션 중요 | 대용량, 빠른 읽기/쓰기, 유연성 |

```
RDBMS 예시:
User 테이블: id, name, email
Order 테이블: id, user_id, product, price
→ 조인으로 "사용자의 주문" 조회

NoSQL 예시:
User 문서: {
  id: 1,
  name: "김철수",
  email: "kim@example.com",
  orders: [
    {product: "노트북", price: 1000000},
    {product: "마우스", price: 30000}
  ]
}
→ 한 번의 조회로 모든 데이터 획득
```

---

## 3. BASE 속성

**정의**: NoSQL이 지향하는 특성 (ACID의 대안)

| 속성 | 설명 |
|------|------|
| **BA (Basically Available)** | 기본적으로 항상 사용 가능함 (가용성 우선) |
| **S (Soft state)** | 일시적으로 일관되지 않은 상태 허용 |
| **E (Eventually consistent)** | 최종적으로는 일관된 상태에 도달 |

```
BASE 동작 예시:

시간 0: Node1에 "좋아요 +1" 쓰기 (count = 101)
시간 1: Node2 읽기 (count = 100, 아직 미반영) ← Soft state
시간 2: Node2에 복제 완료 (count = 101) ← Eventually consistent

→ 일시적 불일치를 허용하되, 결국 모든 노드가 일치
```

**ACID vs BASE**:

| 비교 | ACID | BASE |
|------|------|------|
| **우선순위** | 일관성 > 가용성 | 가용성 > 일관성 |
| **적용** | RDBMS | NoSQL |
| **응답 시간** | 느릴 수 있음 (일관성 확인) | 빠름 (즉시 응답) |
| **복잡도** | 단순 (DB가 보장) | 복잡 (애플리케이션에서 처리) |

---

## 4. NoSQL 유형

### 4.1 Key-Value Store

**구조**: 단순한 키-값 쌍으로 데이터 저장

| 특징 | 설명 |
|------|------|
| **장점** | 매우 빠름, 단순함, 수평 확장 용이 |
| **단점** | 복잡한 쿼리 불가, 값 내부 검색 불가 |
| **사용 사례** | 캐싱, 세션 저장, 장바구니 |
| **대표 DB** | Redis, Memcached, DynamoDB |

```
Key-Value 예시:

Key                    Value
-------------------------------------------
user:1001:session  →  "a8f9d2e1b3c4..."
cart:2045          →  ["item1", "item2", "item3"]
cache:product:500  →  "{name: '노트북', price: 1000000}"

조회: GET user:1001:session
저장: SET cart:2045 ["item1", "item2"]
```

---

### 4.2 Document Store

**구조**: JSON, XML 등의 문서 형태로 데이터 저장

| 특징 | 설명 |
|------|------|
| **장점** | 유연한 스키마, 복잡한 구조 표현 가능 |
| **단점** | 문서 간 조인 비효율적 |
| **사용 사례** | 콘텐츠 관리, 사용자 프로필, 제품 카탈로그 |
| **대표 DB** | MongoDB, CouchDB, Firestore |

```
Document 예시:

{
  "_id": "user_1001",
  "name": "김철수",
  "email": "kim@example.com",
  "address": {
    "city": "서울",
    "district": "강남구"
  },
  "orders": [
    {
      "order_id": "ord_001",
      "date": "2024-11-15",
      "items": ["노트북", "마우스"]
    }
  ],
  "tags": ["VIP", "단골"]
}

→ 중첩 구조 가능, 스키마 자유로움
→ 문서마다 다른 필드 보유 가능
```

---

### 4.3 Column-Family Store

**구조**: 행이 아닌 열 단위로 데이터 저장

| 특징 | 설명 |
|------|------|
| **장점** | 대용량 쓰기에 최적화, 압축 효율 높음 |
| **단점** | 복잡한 쿼리 어려움, 학습 곡선 높음 |
| **사용 사례** | 시계열 데이터, 로그 분석, IoT 데이터 |
| **대표 DB** | Cassandra, HBase, ScyllaDB |

```
Column-Family 구조:

Row Key: user_1001
├─ info:name        → "김철수"
├─ info:email       → "kim@example.com"
├─ activity:login   → "2024-11-17 09:00:00"
└─ activity:logout  → "2024-11-17 18:00:00"

Row Key: user_1002
├─ info:name        → "이영희"
├─ info:phone       → "010-1234-5678"  ← 다른 컬럼 보유 가능
└─ activity:login   → "2024-11-17 10:00:00"

→ 각 행마다 다른 컬럼 집합 가능
→ 컬럼을 그룹(Column Family)으로 관리
```

**RDBMS vs Column-Family 저장 방식**:

| 방식 | 저장 구조 |
|------|-----------|
| **RDBMS (Row-based)** | 행 단위로 저장: [1, "김철수", "kim@..."] → [2, "이영희", "lee@..."] |
| **Column-Family** | 열 단위로 저장: [1, 2, 3, ...] → ["김철수", "이영희", ...] → ["kim@...", "lee@...", ...] |

---

### 4.4 Graph Store

**구조**: 노드(개체)와 엣지(관계)로 데이터 표현

| 특징 | 설명 |
|------|------|
| **장점** | 관계 탐색에 최적화, 복잡한 연결 쿼리 효율적 |
| **단점** | 수평 확장 어려움, 그래프 외 쿼리 비효율적 |
| **사용 사례** | 소셜 네트워크, 추천 시스템, 지식 그래프 |
| **대표 DB** | Neo4j, ArangoDB, JanusGraph |

```
Graph 예시:

(김철수)-[친구]→(이영희)
(김철수)-[근무]→(A회사)
(이영희)-[근무]→(B회사)
(이영희)-[좋아함]→(축구)
(박민수)-[친구]→(이영희)
(박민수)-[좋아함]→(축구)

쿼리: "김철수의 친구의 친구 중 축구를 좋아하는 사람"
→ 김철수 → 이영희 → 박민수 (축구 좋아함)

→ 관계 기반 쿼리에 매우 효율적
```

---

## 5. NoSQL 유형 비교

| 유형 | 데이터 구조 | 강점 | 약점 | 주요 사용처 |
|------|------------|------|------|------------|
| **Key-Value** | 키 → 값 | 속도, 단순성 | 복잡 쿼리 불가 | 캐싱, 세션 |
| **Document** | 문서 (JSON 등) | 유연성, 중첩 구조 | 조인 비효율 | CMS, 프로필 |
| **Column-Family** | 행키 → 컬럼패밀리 | 대용량 쓰기, 압축 | 복잡 쿼리 어려움 | 로그, 시계열 |
| **Graph** | 노드 + 엣지 | 관계 탐색 | 확장 어려움 | 소셜, 추천 |

---

## 6. 데이터 모델링 차이

### RDBMS 모델링

```
정규화 중심:

User 테이블
id | name    | email
1  | 김철수  | kim@example.com
2  | 이영희  | lee@example.com

Order 테이블
id | user_id | product  | price
1  | 1       | 노트북   | 1000000
2  | 1       | 마우스   | 30000
3  | 2       | 키보드   | 50000

→ 중복 제거, 조인으로 조회
```

### NoSQL 모델링

```
반정규화 중심:

User 문서 (Document)
{
  id: 1,
  name: "김철수",
  email: "kim@example.com",
  orders: [
    {product: "노트북", price: 1000000},
    {product: "마우스", price: 30000}
  ]
}

→ 중복 허용, 한 번의 조회로 완결
→ "읽기 패턴"에 최적화된 구조 설계
```

**모델링 원칙 차이**:

| 구분 | RDBMS | NoSQL |
|------|-------|-------|
| **설계 기준** | 데이터 구조 (정규화) | 쿼리 패턴 (어떻게 읽을 것인가) |
| **중복** | 최소화 | 허용 (성능 위해) |
| **관계** | 외래키, 조인 | 임베딩, 중복 저장 |
| **변경** | 스키마 변경 어려움 | 유연하게 변경 가능 |

---

## 7. NoSQL 선택 기준

### NoSQL을 사용해야 할 때

| 상황 | 이유 |
|------|------|
| **대용량 데이터** | 수평 확장 용이 |
| **빠른 읽기/쓰기** | 조인 없이 단순 조회 |
| **유연한 스키마** | 자주 변경되는 데이터 구조 |
| **높은 가용성** | 분산 시스템, 최종 일관성 |
| **단순한 쿼리** | Key 기반 조회, 집계 |

### RDBMS를 사용해야 할 때

| 상황 | 이유 |
|------|------|
| **복잡한 쿼리** | 조인, 서브쿼리 필요 |
| **강한 일관성** | 금융, 결제 등 ACID 필수 |
| **트랜잭션** | 여러 테이블 간 원자성 보장 |
| **정형화된 데이터** | 고정된 스키마 |
| **데이터 무결성** | 외래키, 제약 조건 필요 |

---

## 8. 핵심 정리

```
NoSQL 선택 시 고려사항:

1. 데이터 모델: Key-Value / Document / Column / Graph 중 선택
2. CAP 특성: 대부분 AP 시스템 (가용성 + 파티션 허용)
3. 일관성: BASE 속성, 최종 일관성 허용 가능 여부
4. 쿼리 패턴: 조인 없이 단순 조회로 해결 가능한지
5. 확장성: 수평 확장 필요 여부
```

---

## 면접 질문

### Q1. NoSQL이 RDBMS보다 빠른 이유는?

**핵심 답변**:

| 이유 | 설명 |
|------|------|
| **조인 없음** | 데이터를 미리 중복 저장하여 한 번의 조회로 완결 |
| **인덱스 단순** | 복잡한 인덱스 구조 불필요, Key 기반 직접 접근 |
| **스키마 검증 생략** | 고정 스키마 검증 과정 없음 |
| **수평 확장** | 여러 노드에 분산하여 병렬 처리 |
| **메모리 최적화** | Key-Value는 전체를 메모리에 올려 사용 가능 |

**주의**: 모든 경우에 빠른 것이 아님. 복잡한 집계나 조인이 필요하면 오히려 느릴 수 있음.

---

### Q2. 4가지 NoSQL 유형 중 어떤 것을 선택해야 하는가?

| 상황 | 선택 | 이유 |
|------|------|------|
| **간단한 캐싱, 세션 관리** | Key-Value | 가장 빠르고 단순함 |
| **유연한 JSON 데이터, 중첩 구조** | Document | 스키마 유연성, 복잡한 문서 표현 |
| **대규모 시계열, 로그 데이터** | Column-Family | 쓰기 최적화, 시간 기반 쿼리 효율적 |
| **소셜 관계, 추천 시스템** | Graph | 관계 탐색 최적화 |

**헷갈리기 쉬운 포인트**:
- **Document vs Key-Value**: 값 내부를 쿼리해야 하면 Document (예: "나이가 30 이상인 사용자"), 단순 조회면 Key-Value
- **Column-Family vs Document**: 쓰기가 매우 많고 시간 기반 조회가 주요하면 Column-Family, 유연한 구조와 복잡한 쿼리가 필요하면 Document

```
실무 선택 예시:

실시간 채팅 앱:
- 메시지 저장: Document (MongoDB) - 복잡한 메시지 구조
- 온라인 상태: Key-Value (Redis) - 빠른 조회
- 친구 관계: Graph (Neo4j) - 관계 탐색

IoT 센서 데이터:
- 센서 로그: Column-Family (Cassandra) - 대량 시계열 쓰기
```