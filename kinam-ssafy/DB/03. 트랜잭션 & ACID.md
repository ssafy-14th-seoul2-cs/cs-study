# 트랜잭션과 ACID

## 들어가기 앞서

트랜잭션을 이해하기 위해 먼저 알아야 할 개념:
- **데이터베이스 연산**: INSERT, UPDATE, DELETE 등의 데이터 조작 작업
- **Commit**: 변경사항을 영구적으로 저장하는 것
- **Rollback**: 변경사항을 취소하고 이전 상태로 되돌리는 것
- **동시성(Concurrency)**: 여러 작업이 동시에 실행되는 것

---

## 트랜잭션이란?

**논리적인 작업 단위 (a single logical unit of work)**

여러 SQL문들을 단일 작업으로 묶어서 나누어질 수 없도록 만든 것.

### 트랜잭션의 핵심 특징

**ALL OR NOTHING**
- 트랜잭션 내 SQL문들은 **모두 성공**하는 경우 commit됨
- **하나라도 실패**하는 경우에는 전체가 rollback됨
- 일부만 성공해서 DB에 반영되는 일은 절대 일어나지 않음

---

## 트랜잭션 예시

### 계좌 이체 시나리오

```sql
-- 트랜잭션 시작
START TRANSACTION;

-- 1. A 계좌에서 10만원 출금
UPDATE 계좌 SET 잔액 = 잔액 - 100000 WHERE 계좌번호 = 'A';

-- 2. B 계좌에 10만원 입금
UPDATE 계좌 SET 잔액 = 잔액 + 100000 WHERE 계좌번호 = 'B';

-- 모두 성공하면 커밋
COMMIT;
```

**문제 상황**
- 만약 1번은 성공하고 2번에서 오류가 발생하면?
- A 계좌에서는 돈이 빠져나갔는데 B 계좌에는 입금되지 않음
- **10만원이 증발하는 문제 발생!**

**트랜잭션 해결**
- 트랜잭션으로 묶으면 2번이 실패할 경우 1번도 자동으로 rollback됨
- A 계좌는 원래대로 돌아가고, 돈이 증발하지 않음

---

## ACID란?

**트랜잭션이 안전하게 수행되기 위해 반드시 보장해야 하는 4가지 속성**

- **A**tomicity (원자성)
- **C**onsistency (일관성)
- **I**solation (격리성)
- **D**urability (지속성)

각 속성의 앞글자를 따서 ACID라고 함.

---

## 1. 원자성 (Atomicity)

### 개념

**ALL OR NOTHING**

트랜잭션은 **모두 실행**하거나 **모두 실행하지 않음**의 두 가지 상태만 존재함.

### 핵심 원리

**트랜잭션은 논리적으로 쪼개질 수 없는 작업 단위**
- 내부의 SQL문들이 모두 성공하거나
- 중간에 어떤 하나의 SQL문이라도 실패하면, 지금까지 작업을 모두 취소하고 이전 상태로 rollback
- **일부만 성공하는 상태는 존재해서는 안 됨**

### 책임 소재

**DBMS의 역할**
- 성공 시 commit했을 때 DB에 영구적으로 저장
- 실패 시 rollback했을 때 이전 상태로 되돌림

**개발자의 역할**
- 언제 commit하고 언제 rollback할지에 대한 기준을 세우고 코드 작성

### 예시

```sql
START TRANSACTION;

-- SQL 1: 재고 감소
UPDATE 재고 SET 수량 = 수량 - 1 WHERE 상품ID = 100;

-- SQL 2: 주문 생성
INSERT INTO 주문 (고객ID, 상품ID) VALUES (1, 100);

-- SQL 3: 배송 정보 생성
INSERT INTO 배송 (주문ID, 주소) VALUES (LAST_INSERT_ID(), '서울시...');

COMMIT;  -- 모두 성공하면 커밋
```

만약 SQL 3에서 오류 발생 시, SQL 1과 SQL 2도 모두 rollback되어 재고는 원래대로, 주문도 생성되지 않음.

---

## 2. 일관성 (Consistency)

### 개념

**트랜잭션 이전과 이후에 데이터베이스는 항상 consistent한 상태여야 함**

트랜잭션은 DB 상태를 consistent 상태에서 또 다른 consistent 상태로 변경해야 함.

### Consistent 상태란?

**DB에 정의된 모든 규칙을 만족하는 상태**
- Constraints (제약조건): NOT NULL, UNIQUE, CHECK 등
- Trigger (트리거): 특정 이벤트 발생 시 자동 실행되는 규칙
- Domain Integrity (도메인 무결성): 데이터 타입, 범위 등

### 규칙 위반 시 처리

만약 constraints, trigger 등을 통해서 DB에 정의된 규칙을 트랜잭션이 위반했다면 **rollback**해야 함.

### 예시

**제약조건 위반**
```sql
START TRANSACTION;

-- 계좌 잔액 업데이트
UPDATE 계좌 SET 잔액 = 잔액 - 50000 WHERE 계좌번호 = 'A';

-- 만약 잔액이 -10000이 되었다면?
-- CHECK 제약조건: 잔액 >= 0
-- → 규칙 위반! 자동으로 ROLLBACK
```

**비즈니스 로직 위반**
```sql
START TRANSACTION;

-- 주문 생성
INSERT INTO 주문 (상품ID, 수량) VALUES (100, 5);

-- 재고 확인 시 재고가 3개밖에 없음
-- 비즈니스 규칙 위반 → 개발자가 명시적으로 ROLLBACK 필요
ROLLBACK;
```

### 책임 소재

**DBMS의 역할**
- 트랜잭션이 DB에 정의된 규칙을 위반했는지 커밋 전에 확인하고 알려줌

**개발자의 역할**
- DBMS를 맹신하지 말고, 애플리케이션 관점에서 트랜잭션이 consistent하게 동작하는지 챙겨야 함
- 비즈니스 로직 수준의 일관성은 개발자가 보장해야 함

---

## 3. 격리성 (Isolation)

### 개념

**여러 트랜잭션이 동시에 실행될 때에도, 혼자 실행되는 것처럼 동작하게 만들어야 함**

동시에 실행되는 여러 트랜잭션은 서로 영향을 주지 않고 독립적으로 실행되는 것처럼 보여야 함.

### 왜 중요한가?

**동시성 문제**
여러 트랜잭션이 동시에 실행되면 결과가 이상해지는 문제가 발생할 수 있음.

### 격리성 문제 예시

**Dirty Read 문제**
```
시간   트랜잭션 A                트랜잭션 B
1      잔액 조회: 10000
2                                잔액 = 잔액 - 5000 (5000)
3      잔액 조회: 5000 (Dirty Read!)
4                                ROLLBACK (다시 10000으로)
5      잔액이 5000이라고 착각
```

트랜잭션 A가 B의 커밋되지 않은 데이터를 읽어버림.

**Lost Update 문제**
```
시간   트랜잭션 A                트랜잭션 B
1      잔액 조회: 10000         잔액 조회: 10000
2      잔액 = 10000 - 3000
3                                잔액 = 10000 - 2000
4      UPDATE 잔액 = 7000
5                                UPDATE 잔액 = 8000 (덮어씀!)
```

트랜잭션 A의 변경사항이 사라짐.

### Isolation Level

**DBMS는 여러 종류의 isolation level을 제공함**
1. READ UNCOMMITTED (가장 낮은 격리)
2. READ COMMITTED
3. REPEATABLE READ
4. SERIALIZABLE (가장 높은 격리)

격리 수준이 높을수록 동시성은 낮아지지만 데이터 정합성은 높아짐.

### Concurrency Control

**Concurrency Control의 목표는 Isolation임**
- 락(Lock) 기법
- 타임스탬프 기법
- 다중 버전 동시성 제어(MVCC)

### 책임 소재

**DBMS의 역할**
- 다양한 isolation level 제공
- Locking, MVCC 등의 메커니즘 제공

**개발자의 역할**
- 상황에 맞는 적절한 isolation level 설정
- 데드락 등의 동시성 문제 고려

---

## 4. 지속성 (Durability)

### 개념

**커밋된 트랜잭션의 결과는 데이터베이스에 영구적으로 저장되어야 함**

### 영구적 저장의 의미

**비휘발성 메모리(HDD, SSD 등)에 저장**
- RAM이 아닌 디스크에 저장됨을 의미
- 전원이 꺼져도 데이터가 사라지지 않음

### 장애 상황에서도 보장

**DB System에 문제가 생겨도 커밋된 결과는 계속 남아있어야 함**
- 전원이 꺼지는 경우
- 시스템이 크래시되는 경우
- 디스크가 고장나는 경우 (복제/백업을 통해 대응)

### 구현 방법

**WAL (Write-Ahead Logging)**
- 데이터를 변경하기 전에 먼저 로그를 기록
- 장애 발생 시 로그를 이용해 복구

**체크포인트**
- 주기적으로 메모리의 변경사항을 디스크에 기록

**리두 로그 (Redo Log)**
- 커밋된 트랜잭션의 변경사항을 재실행할 수 있는 로그

### 책임 소재

**DBMS의 역할**
- Durability는 거의 전적으로 DBMS가 보장
- 개발자는 DBMS를 믿고 사용

**개발자의 역할**
- 백업 정책 수립
- 복제(Replication) 설정
- 재해 복구 계획 수립

---

## ACID 특성 요약 비교

| 특성 | 의미 | 주요 책임자 | 키워드 |
|------|------|-------------|---------|
| 원자성 | 모두 성공 or 모두 실패 | DBMS + 개발자 | All or Nothing, Commit/Rollback |
| 일관성 | 규칙을 항상 만족 | 개발자 + DBMS | Constraints, Trigger, 비즈니스 로직 |
| 격리성 | 동시 실행 시 독립성 유지 | DBMS + 개발자 | Isolation Level, Lock, MVCC |
| 지속성 | 영구적 저장 보장 | DBMS | WAL, Redo Log, Backup |

---

## 트랜잭션 사용 예시

### 기본 트랜잭션 제어

```sql
-- 자동 커밋 비활성화
SET autocommit = 0;

-- 트랜잭션 시작
START TRANSACTION;

-- 작업 수행
UPDATE 계좌 SET 잔액 = 잔액 - 10000 WHERE 계좌번호 = 'A';
UPDATE 계좌 SET 잔액 = 잔액 + 10000 WHERE 계좌번호 = 'B';

-- 성공 시
COMMIT;

-- 실패 시
ROLLBACK;
```

### 애플리케이션 코드 예시 (Java)

```java
Connection conn = null;
try {
    conn = dataSource.getConnection();
    conn.setAutoCommit(false);  // 자동 커밋 비활성화
    
    // SQL 실행
    accountDao.withdraw("A", 10000);
    accountDao.deposit("B", 10000);
    
    conn.commit();  // 성공 시 커밋
} catch (Exception e) {
    if (conn != null) {
        conn.rollback();  // 실패 시 롤백
    }
} finally {
    if (conn != null) {
        conn.close();
    }
}
```

---

## 핵심 정리

**트랜잭션**
- 논리적인 작업 단위로, 여러 SQL문을 하나로 묶은 것
- All or Nothing: 모두 성공하거나 모두 실패함

**ACID 4가지 속성**
1. **원자성**: 트랜잭션은 분할 불가능한 최소 단위
2. **일관성**: DB 규칙을 항상 만족해야 함
3. **격리성**: 동시 실행되는 트랜잭션들은 서로 독립적
4. **지속성**: 커밋된 내용은 영구적으로 저장됨

**왜 중요한가?**
- 데이터 무결성 보장
- 동시성 제어
- 장애 복구
- 안정적인 시스템 구축의 기초

**개발자가 해야 할 일**
- 적절한 트랜잭션 범위 설정
- 비즈니스 로직 수준의 일관성 보장
- 적절한 isolation level 선택
- 예외 상황 처리 (rollback 조건)