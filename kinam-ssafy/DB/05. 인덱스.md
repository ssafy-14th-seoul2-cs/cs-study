# 인덱스 (Index)

## 들어가기 앞서

**선행 개념**
- 테이블: 데이터가 저장되는 기본 단위
- 쿼리 성능: SELECT 문의 실행 속도
- 디스크 I/O: 데이터를 저장장치에서 읽고 쓰는 작업

## 인덱스란?

데이터를 빠르게 검색하기 위한 자료구조. 책의 색인과 동일한 개념

**인덱스 없이 검색**: Full Table Scan (모든 행을 순차 탐색)
**인덱스 사용**: 특정 자료구조를 통해 빠른 탐색

## 인덱스의 장단점

| 장점 | 단점 |
|------|------|
| 검색 속도 향상 (O(log n)) | 추가 저장 공간 필요 (테이블 크기의 10%) |
| ORDER BY, GROUP BY 성능 향상 | INSERT/UPDATE/DELETE 성능 저하 |
| WHERE 절 필터링 최적화 | 인덱스 관리 오버헤드 |

## 인덱스 자료구조

### 1. B-Tree (Balanced Tree)
가장 일반적으로 사용되는 인덱스 구조

```
         [50]
        /    \
    [20,35]  [70,90]
    /  |  \   /  |  \
  [...][...][...][...]
```

**특징**
- 균형 잡힌 트리 구조
- 모든 리프 노드가 같은 깊이
- 범위 검색에 효율적
- 시간 복잡도: O(log n)

| 연산 | 시간 복잡도 |
|------|------------|
| 검색 | O(log n) |
| 삽입 | O(log n) |
| 삭제 | O(log n) |

### 2. Hash Index
해시 함수를 이용한 인덱스

```
Hash(key) → Bucket → Data
```

| 요소 | 설명 |
|------|------|
| **Hash 함수** | 입력값 → 고정된 숫자(주소)로 변환 |
| **Bucket** | 데이터가 저장되는 저장소 |
| **직접 접근** | 계산된 주소로 **한 번에** 이동 |

**특징**
- 등호(=) 검색에 매우 빠름: O(1)
- 범위 검색 불가능
- ORDER BY 사용 불가
- 주로 메모리 기반 DB에서 사용



| 검색 타입 | B-Tree | Hash |
|----------|--------|------|
| = | O(log n) | O(1) |
| >, <, BETWEEN | O(log n) | ❌ 불가 |
| LIKE | 조건부 | ❌ 불가 |

### 3. Bitmap Index
비트맵을 사용한 인덱스

**적합한 경우**
- 카디널리티가 낮은 컬럼 (성별, 지역 등)
- 읽기 작업이 많고 쓰기 작업이 적은 경우


| 개념 | 설명 |
|------|------|
| **카디널리티** | 컬럼에서 **중복을 제거한 고유한 값의 개수** |
| **높은 카디널리티** | 고유 값이 많음 (주민번호, 이메일 등) |
| **낮은 카디널리티** | 고유 값이 적음 (성별, 지역, Y/N 등) |


### 카디널리티 비교
| 컬럼 | 전체 데이터 | 고유 값 개수 | 카디널리티 |
|------|----------|------------|----------|
| **주민번호** | 1,000,000명 | 1,000,000개 | **매우 높음** |
| **이메일** | 1,000,000명 | 950,000개 | **높음** |
| **나이** | 1,000,000명 | 100개 | 중간 |
| **지역** | 1,000,000명 | 17개 | **낮음** |
| **성별** | 1,000,000명 | 2개 | **매우 낮음** |


#### 예시: 100만 명의 성별 데이터

#### B-Tree Index (일반 인덱스)
```
성별 인덱스 저장:
M → [1, 3, 5, 6, 8, 10, 11, 13, ...]  ← ID 리스트
F → [2, 4, 7, 9, 12, 14, 15, ...]     ← ID 리스트

100만 건 × 4byte(ID) = 4MB
```

#### Bitmap Index
```
M: [101101011010...]  ← 비트로 표현
F: [010010100101...]  ← 비트로 표현

100만 건 × 1bit = 125KB
압축률: 약 32배 절약
```

### 다중 조건 검색에 매우 빠름

#### 쿼리 예시
```sql
SELECT * FROM users 
WHERE gender = 'M' 
  AND region = '서울'
  AND status = 'active';
```

#### Bitmap 연산 (비트 AND 연산)
```
gender='M':     [1,0,1,0,1,1,0,1,0,1]
region='서울':  [1,1,0,0,1,0,0,1,1,0]
status='active':[1,0,1,1,1,0,1,1,0,1]
───────────────────────────────────── AND 연산
결과:           [1,0,0,0,1,0,0,1,0,0]
                ↑        ↑     ↑
               id1      id5   id8 찾음!
```


## 인덱스 종류

### 기본 분류

| 종류 | 설명 | 특징 |
|------|------|------|
| **클러스터드 인덱스** | 테이블 데이터 자체가 정렬됨 | 테이블당 1개만 가능, PK 자동 생성 |
| **논클러스터드 인덱스** | 별도의 인덱스 구조 유지 | 테이블당 여러 개 가능 |
| **복합 인덱스** | 여러 컬럼을 조합한 인덱스 | 컬럼 순서가 중요 |
| **커버링 인덱스** | 인덱스만으로 쿼리 처리 | 테이블 접근 없이 결과 반환 |

### 클러스터드 vs 논클러스터드

```
[클러스터드 인덱스]
인덱스 = 실제 데이터
(1) → [id:1, name:A]
(2) → [id:2, name:B]
(3) → [id:3, name:C]

[논클러스터드 인덱스]
인덱스 → 포인터 → 실제 데이터
(A) → ptr1 → [id:2, name:A]
(B) → ptr2 → [id:1, name:B]
```

### 클러스터드 Index (포인터 없음)
```
인덱스 = 실제 데이터 위치

[B-Tree 구조]
    [50]
   /    \
[25]    [75]
 ↓       ↓
실제 데이터 저장 위치
(디스크의 물리적 위치)
```

### 논클러스터드 Index (포인터 있음)
```
인덱스 → 포인터 → 실제 데이터

[B-Tree 구조]         [포인터]      [실제 데이터]
    [name:B]     →    0x1A2B  →   [id:1, name:B, age:25]
       /\
[name:A][name:C] →    0x3C4D  →   [id:3, name:C, age:30]
```


## 포인터의 장점

### 1. 여러 개 생성 가능

#### 클러스터드 (테이블당 1개만)
```
users 테이블의 물리적 정렬:
id 순서로만 정렬됨 (변경 불가)

[1, 홍길동, 25]
[2, 김영희, 30]
[3, 박철수, 22]
↑ id 기준으로 물리적 정렬
```

#### 논클러스터드 (여러 개 가능)
```
users 테이블 (id 순서 유지):
[1, 홍길동, 25]  ← 0x1000 주소
[2, 김영희, 30]  ← 0x2000 주소
[3, 박철수, 22]  ← 0x3000 주소

name 인덱스 (별도):          age 인덱스 (별도):
[김영희] → 0x2000           [22] → 0x3000
[박철수] → 0x3000           [25] → 0x1000
[홍길동] → 0x1000           [30] → 0x2000

→ 원본 테이블은 그대로, 인덱스만 각자 정렬!
```

| 특징 | 클러스터드 | 논클러스터드 |
|------|-----------|-------------|
| 개수 제한 | 1개만 | **여러 개** |
| 테이블 변경 | 물리적 재정렬 | **변경 없음** |
| 생성 영향 | 큼 | 작음 |






## 복합 인덱스와 순서

인덱스 생성 순서가 성능에 큰 영향을 미침

```sql
CREATE INDEX idx_name_age ON user(name, age);
```

| 쿼리 | 인덱스 사용 여부 |
|------|-----------------|
| WHERE name = 'Kim' | ✅ 사용 |
| WHERE name = 'Kim' AND age = 20 | ✅ 사용 |
| WHERE age = 20 | ❌ 미사용 |
| WHERE age = 20 AND name = 'Kim' | ✅ 사용 |

**원칙**: 선두 컬럼이 WHERE 절에 있어야 인덱스 사용 가능

## 인덱스 사용 시 주의사항

### 인덱스가 사용되지 않는 경우

| 상황 | 예시 | 이유 |
|------|------|------|
| 함수 사용 | WHERE YEAR(date) = 2024 | 컬럼 값이 변형됨 |
| 타입 불일치 | WHERE age = '20' (age는 INT) | 암묵적 형변환 발생 |
| NOT, <> 사용 | WHERE status <> 'A' | 범위가 너무 넓음 |
| LIKE '%...%' | WHERE name LIKE '%kim%' | 선두 문자 불확실 |
| OR 연산 | WHERE a = 1 OR b = 2 | 각 조건마다 풀스캔 |

### 인덱스 생성 기준

| 생성하면 좋은 경우 | 생성하지 말아야 할 경우 |
|-------------------|----------------------|
| WHERE, JOIN 절에 자주 사용되는 컬럼 | 카디널리티가 낮은 컬럼 (성별 등) |
| 카디널리티가 높은 컬럼 | INSERT/UPDATE/DELETE가 빈번한 테이블 |
| 데이터가 많은 테이블 | 테이블 크기가 작은 경우 |
| NULL 값이 적은 컬럼 | 사용 빈도가 낮은 컬럼 |

## 실행 계획 확인

```sql
EXPLAIN SELECT * FROM user WHERE name = 'Kim';
```

| 항목 | 의미 |
|------|------|
| **type** | 조인 타입 (ALL=풀스캔, ref=인덱스 사용) |
| **key** | 실제 사용된 인덱스 |
| **rows** | 검사할 예상 행 수 |
| **Extra** | 추가 정보 (Using index = 커버링 인덱스) |

## 핵심 정리

1. **인덱스는 검색 성능 향상**: B-Tree 구조로 O(log n) 탐색
2. **쓰기 성능 희생**: INSERT/UPDATE/DELETE 시 인덱스도 갱신 필요
3. **복합 인덱스는 순서가 중요**: 선두 컬럼이 WHERE 절에 있어야 함
4. **무분별한 생성 금지**: 필요한 곳에만 생성, 주기적으로 사용률 점검
5. **실행 계획 확인**: EXPLAIN으로 인덱스 사용 여부 확인