# 인덱스 (Index)

## 들어가기 앞서

**선행 개념**
- 테이블: 데이터가 저장되는 기본 단위
- 쿼리 성능: SELECT 문의 실행 속도
- 디스크 I/O: 데이터를 저장장치에서 읽고 쓰는 작업

## 인덱스란?

데이터를 빠르게 검색하기 위한 자료구조. 책의 색인과 동일한 개념

**인덱스 없이 검색**: Full Table Scan (모든 행을 순차 탐색)
**인덱스 사용**: 특정 자료구조를 통해 빠른 탐색

## 인덱스의 장단점

| 장점 | 단점 |
|------|------|
| 검색 속도 향상 (O(log n)) | 추가 저장 공간 필요 (테이블 크기의 10%) |
| ORDER BY, GROUP BY 성능 향상 | INSERT/UPDATE/DELETE 성능 저하 |
| WHERE 절 필터링 최적화 | 인덱스 관리 오버헤드 |

## 인덱스 자료구조

### 1. B-Tree (Balanced Tree)
가장 일반적으로 사용되는 인덱스 구조

```
         [50]
        /    \
    [20,35]  [70,90]
    /  |  \   /  |  \
  [...][...][...][...]
```

**특징**
- 균형 잡힌 트리 구조
- 모든 리프 노드가 같은 깊이
- 범위 검색에 효율적
- 시간 복잡도: O(log n)

| 연산 | 시간 복잡도 |
|------|------------|
| 검색 | O(log n) |
| 삽입 | O(log n) |
| 삭제 | O(log n) |

### 2. Hash Index
해시 함수를 이용한 인덱스

```
Hash(key) → Bucket → Data
```

**특징**
- 등호(=) 검색에 매우 빠름: O(1)
- 범위 검색 불가능
- ORDER BY 사용 불가
- 주로 메모리 기반 DB에서 사용

| 검색 타입 | B-Tree | Hash |
|----------|--------|------|
| = | O(log n) | O(1) |
| >, <, BETWEEN | O(log n) | ❌ 불가 |
| LIKE | 조건부 | ❌ 불가 |

### 3. Bitmap Index
비트맵을 사용한 인덱스

**적합한 경우**
- 카디널리티가 낮은 컬럼 (성별, 지역 등)
- 읽기 작업이 많고 쓰기 작업이 적은 경우

## 인덱스 종류

### 기본 분류

| 종류 | 설명 | 특징 |
|------|------|------|
| **클러스터드 인덱스** | 테이블 데이터 자체가 정렬됨 | 테이블당 1개만 가능, PK 자동 생성 |
| **논클러스터드 인덱스** | 별도의 인덱스 구조 유지 | 테이블당 여러 개 가능 |
| **복합 인덱스** | 여러 컬럼을 조합한 인덱스 | 컬럼 순서가 중요 |
| **커버링 인덱스** | 인덱스만으로 쿼리 처리 | 테이블 접근 없이 결과 반환 |

### 클러스터드 vs 논클러스터드

```
[클러스터드 인덱스]
인덱스 = 실제 데이터
(1) → [id:1, name:A]
(2) → [id:2, name:B]
(3) → [id:3, name:C]

[논클러스터드 인덱스]
인덱스 → 포인터 → 실제 데이터
(A) → ptr1 → [id:2, name:A]
(B) → ptr2 → [id:1, name:B]
```

## 복합 인덱스와 순서

인덱스 생성 순서가 성능에 큰 영향을 미침

```sql
CREATE INDEX idx_name_age ON user(name, age);
```

| 쿼리 | 인덱스 사용 여부 |
|------|-----------------|
| WHERE name = 'Kim' | ✅ 사용 |
| WHERE name = 'Kim' AND age = 20 | ✅ 사용 |
| WHERE age = 20 | ❌ 미사용 |
| WHERE age = 20 AND name = 'Kim' | ✅ 사용 |

**원칙**: 선두 컬럼이 WHERE 절에 있어야 인덱스 사용 가능

## 인덱스 사용 시 주의사항

### 인덱스가 사용되지 않는 경우

| 상황 | 예시 | 이유 |
|------|------|------|
| 함수 사용 | WHERE YEAR(date) = 2024 | 컬럼 값이 변형됨 |
| 타입 불일치 | WHERE age = '20' (age는 INT) | 암묵적 형변환 발생 |
| NOT, <> 사용 | WHERE status <> 'A' | 범위가 너무 넓음 |
| LIKE '%...%' | WHERE name LIKE '%kim%' | 선두 문자 불확실 |
| OR 연산 | WHERE a = 1 OR b = 2 | 각 조건마다 풀스캔 |

### 인덱스 생성 기준

| 생성하면 좋은 경우 | 생성하지 말아야 할 경우 |
|-------------------|----------------------|
| WHERE, JOIN 절에 자주 사용되는 컬럼 | 카디널리티가 낮은 컬럼 (성별 등) |
| 카디널리티가 높은 컬럼 | INSERT/UPDATE/DELETE가 빈번한 테이블 |
| 데이터가 많은 테이블 | 테이블 크기가 작은 경우 |
| NULL 값이 적은 컬럼 | 사용 빈도가 낮은 컬럼 |

## 실행 계획 확인

```sql
EXPLAIN SELECT * FROM user WHERE name = 'Kim';
```

| 항목 | 의미 |
|------|------|
| **type** | 조인 타입 (ALL=풀스캔, ref=인덱스 사용) |
| **key** | 실제 사용된 인덱스 |
| **rows** | 검사할 예상 행 수 |
| **Extra** | 추가 정보 (Using index = 커버링 인덱스) |

## 핵심 정리

1. **인덱스는 검색 성능 향상**: B-Tree 구조로 O(log n) 탐색
2. **쓰기 성능 희생**: INSERT/UPDATE/DELETE 시 인덱스도 갱신 필요
3. **복합 인덱스는 순서가 중요**: 선두 컬럼이 WHERE 절에 있어야 함
4. **무분별한 생성 금지**: 필요한 곳에만 생성, 주기적으로 사용률 점검
5. **실행 계획 확인**: EXPLAIN으로 인덱스 사용 여부 확인