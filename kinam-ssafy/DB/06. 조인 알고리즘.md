# 조인 알고리즘 (Join Algorithm)

## 들어가기 앞서

**선행 개념**
- 조인(Join): 두 개 이상의 테이블을 연결하여 데이터를 조회
- 드라이빙 테이블: 조인 시 먼저 읽는 테이블 (Outer Table)
- 드리븐 테이블: 나중에 읽는 테이블 (Inner Table)
- 인덱스: 데이터 검색을 빠르게 하는 자료구조

## 조인이란?

여러 테이블의 데이터를 결합하여 하나의 결과 집합을 만드는 연산

```sql
SELECT *
FROM user u
JOIN order o ON u.id = o.user_id;
```

## 3가지 주요 조인 알고리즘

### 성능 비교표

| 알고리즘 | 시간 복잡도 | 메모리 사용 | 적합한 상황 |
|----------|------------|------------|------------|
| **Nested Loop Join** | O(N × M) | 적음 | 작은 테이블, 인덱스 있음 |
| **Hash Join** | O(N + M) | 많음 | 큰 테이블, 인덱스 없음, 등호 조인 |
| **Sort Merge Join** | O(N log N + M log M) | 중간 | 이미 정렬된 데이터, 범위 조인 |

## 1. Nested Loop Join (중첩 루프 조인)

가장 기본적인 조인 방식. 이중 for문과 동일한 구조

### 동작 방식
```
for each row in Table A (드라이빙 테이블):
    for each row in Table B (드리븐 테이블):
        if join condition matches:
            return row
```

### 예시
```sql
SELECT *
FROM user u          -- 10건
JOIN order o         -- 1000건
ON u.id = o.user_id;
```

**실행 과정**
1. user 테이블에서 첫 번째 행 읽기
2. order 테이블 전체를 스캔하며 매칭되는 행 찾기
3. user 테이블의 다음 행으로 이동하여 반복

### 특징

| 장점 | 단점 |
|------|------|
| 구조가 단순함 | 대용량 테이블에서 느림 |
| 메모리 사용량 적음 | O(N × M) 복잡도 |
| 인덱스 활용 시 매우 빠름 | 드리븐 테이블을 반복 스캔 |
| 작은 결과 집합에 유리 | 인덱스 없으면 비효율적 |

### 최적화 포인트
```
✅ 드라이빙 테이블: 작은 테이블 선택
✅ 드리븐 테이블: 조인 컬럼에 인덱스 생성
✅ 조건: WHERE 절로 드라이빙 테이블 크기 최소화
```

**성능 개선 예시**

| 조건 | 비교 횟수 |
|------|----------|
| 인덱스 없음 | 10 × 1000 = 10,000번 |
| 인덱스 있음 | 10 × log(1000) ≈ 100번 |

## 2. Hash Join (해시 조인)

해시 테이블을 이용한 조인. 대용량 테이블에 효율적

### 동작 방식
```
[Build Phase]
작은 테이블로 해시 테이블 생성
user.id → Hash → Bucket

[Probe Phase]
큰 테이블의 각 행에 대해 해시 테이블에서 매칭 검색
```

### 실행 과정

**1단계: Build (해시 테이블 생성)**
```
user 테이블 (작은 테이블)
id=1 → Hash(1) → Bucket[5]
id=2 → Hash(2) → Bucket[7]
id=3 → Hash(3) → Bucket[2]
```

**2단계: Probe (매칭 검색)**
```
order 테이블 각 행에 대해
user_id=1 → Hash(1) → Bucket[5] 검색 → 매칭
user_id=2 → Hash(2) → Bucket[7] 검색 → 매칭
```

### 특징

| 장점 | 단점 |
|------|------|
| O(N + M) 시간 복잡도 | 메모리 사용량 많음 (해시 테이블) |
| 대용량 테이블에 효율적 | 등호(=) 조인만 가능 |
| 인덱스 불필요 | 해시 테이블이 메모리 초과 시 디스크 사용 |
| 정렬 불필요 | 범위 조인(>, <) 불가능 |

### 적합한 경우
- 큰 테이블끼리 조인
- 조인 컬럼에 인덱스 없음
- 등호(=) 조인
- 충분한 메모리 확보

## 3. Sort Merge Join (정렬 병합 조인)

두 테이블을 정렬한 후 병합하는 방식

### 동작 방식
```
[Sort Phase]
Table A 정렬: 1, 2, 3, 4, 5
Table B 정렬: 1, 2, 3, 6, 7

[Merge Phase]
포인터를 이용해 매칭되는 행 병합
```

### 실행 과정

**1단계: Sort (정렬)**
```
user:  [3, 1, 2] → 정렬 → [1, 2, 3]
order: [2, 3, 1] → 정렬 → [1, 2, 3]
```

**2단계: Merge (병합)**
```
user:  [1, 2, 3]
        ↓  ↓  ↓
order: [1, 2, 3]

순차적으로 비교하며 매칭
```

### 특징

| 장점 | 단점 |
|------|------|
| 이미 정렬된 데이터에 유리 | 정렬 비용 발생 O(N log N) |
| 범위 조인 가능 (>, <, BETWEEN) | 메모리 사용량 중간 |
| 인덱스 불필요 | Hash Join보다 느린 경우 많음 |
| 대용량 데이터 처리 가능 | 정렬 공간 필요 |

### 적합한 경우
- 조인 컬럼이 이미 정렬됨 (인덱스 존재)
- 범위 조인 필요
- 등호/비등호 조인 모두 가능

## 조인 알고리즘 선택 기준

### 데이터 크기별

| 드라이빙 테이블 | 드리븐 테이블 | 추천 알고리즘 |
|----------------|--------------|--------------|
| 작음 | 작음 | Nested Loop |
| 작음 | 큼 (인덱스 O) | Nested Loop |
| 작음 | 큼 (인덱스 X) | Hash Join |
| 큼 | 큼 | Hash Join |

### 조건별

| 조인 조건 | 추천 알고리즘 |
|----------|--------------|
| = (등호) | Hash Join 또는 Nested Loop |
| >, <, BETWEEN (범위) | Sort Merge Join |
| 복잡한 조건 | Nested Loop |

### 리소스별

| 고려사항 | 선택 |
|----------|------|
| 메모리 충분 | Hash Join |
| 메모리 부족 | Nested Loop 또는 Sort Merge |
| 인덱스 존재 | Nested Loop |
| 인덱스 없음 | Hash Join |

## 실행 계획에서 확인

```sql
EXPLAIN
SELECT *
FROM user u
JOIN order o ON u.id = o.user_id;
```

### MySQL

| Extra 컬럼 | 의미 |
|-----------|------|
| Using join buffer (hash join) | Hash Join 사용 |
| Using index | 인덱스만 사용 (Nested Loop) |
| Using filesort | Sort Merge Join 가능성 |

### Oracle

| 항목 | 의미 |
|------|------|
| NESTED LOOPS | Nested Loop Join |
| HASH JOIN | Hash Join |
| MERGE JOIN | Sort Merge Join |

## 조인 최적화 팁

### 1. 드라이빙 테이블 선택
```
작은 테이블을 드라이빙 테이블로 선택
WHERE 절로 필터링 후 작아진 테이블 우선
```

### 2. 인덱스 활용
```
조인 컬럼에 인덱스 생성
복합 인덱스 활용 (조인 컬럼 + WHERE 컬럼)
```

### 3. 조인 순서 최적화
```sql
-- 나쁨: 큰 테이블끼리 먼저 조인
FROM big_table1
JOIN big_table2
JOIN small_table

-- 좋음: 작은 테이블로 먼저 필터링
FROM small_table
JOIN big_table1
JOIN big_table2
```

## 핵심 정리

1. **Nested Loop**: 작은 테이블 + 인덱스 있을 때 최적
2. **Hash Join**: 큰 테이블 + 등호 조인 + 인덱스 없을 때 사용
3. **Sort Merge**: 정렬된 데이터 + 범위 조인에 적합
4. **옵티마이저가 자동 선택**: 통계 정보 기반으로 최적 알고리즘 선택
5. **실행 계획 확인 필수**: EXPLAIN으로 실제 사용된 알고리즘 점검