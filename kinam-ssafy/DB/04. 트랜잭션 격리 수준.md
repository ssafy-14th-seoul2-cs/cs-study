# 트랜잭션 격리 수준(Transaction Isolation Level)

## 들어가기 전에

### 트랜잭션 ACID 속성
| 속성 | 설명 |
|------|------|
| **Atomicity (원자성)** | 트랜잭션의 모든 연산이 성공하거나 모두 실패함 |
| **Consistency (일관성)** | 트랜잭션 처리 후에도 데이터 상태가 일관되어야 함 |
| **Isolation (격리성)** | 트랜잭션 수행 시 다른 트랜잭션의 연산이 끼어들지 못하도록 보장 |
| **Durability (지속성)** | 성공한 트랜잭션은 영원히 반영되며, 로그를 통해 복구 가능 |

### 격리성의 필요성
- 완전한 격리: 데이터 정확성 보장, but 처리 속도 저하
- 완화된 격리: 처리 속도 향상, but 데이터 부정합 가능
- **트레이드 오프**: 속도 vs 정확성을 고려한 격리 수준 설정 필요

---

## 격리 수준 4단계

| 격리 수준 | 특징 | Dirty Read | Non-Repeatable Read | Phantom Read |
|----------|------|------------|---------------------|--------------|
| **READ UNCOMMITTED** | 커밋 안된 데이터도 읽기 가능 | 발생 | 발생 | 발생 |
| **READ COMMITTED** | 커밋된 데이터만 읽기 가능 | 없음 | 발생 | 발생 |
| **REPEATABLE READ** | 트랜잭션 내 동일 결과 보장 | 없음 | 없음 | 발생(MySQL 거의 없음) |
| **SERIALIZABLE** | 트랜잭션 순차 처리 | 없음 | 없음 | 없음 |

### DBMS별 기본 격리 수준
| DBMS | 기본 격리 수준 |
|------|-------------|
| MySQL (InnoDB) | REPEATABLE READ |
| Oracle | READ COMMITTED |

---

## 1. READ UNCOMMITTED

### 특징
- 가장 낮은 격리 수준
- 커밋되지 않은 데이터도 접근 가능
- 일반적으로 사용하지 않음
- Oracle은 지원하지 않음

### Dirty Read 발생
| 시점 | 트랜잭션 A | 트랜잭션 B |
|------|----------|----------|
| 1 | INSERT id=51 | - |
| 2 | (커밋 전) | SELECT → id=51 조회됨 |
| 3 | ROLLBACK | - |
| 4 | - | SELECT → id=51 사라짐 |

### 문제점
- 데이터가 조회되었다가 사라지는 현상
- 시스템에 심각한 버그 초래
- RDBMS 표준에서 인정하지 않는 수준

---

## 2. READ COMMITTED

### 특징
- 커밋된 데이터만 조회 가능
- **Undo 영역** 활용: 커밋 전 데이터는 Undo에서 읽음
- Dirty Read 방지
- 오라클 기본 격리 수준

### Undo 영역 동작
| 영역 | 역할 |
|------|------|
| **Redo Log** | 커밋된 트랜잭션 정보 (복구용) |
| **Undo Log** | 변경 전 데이터 + PK (롤백용) |

### Non-Repeatable Read 발생
| 시점 | 트랜잭션 A | 트랜잭션 B |
|------|----------|----------|
| 1 | - | SELECT name='Minkyu' → 0건 |
| 2 | UPDATE name='Minkyu' | - |
| 3 | COMMIT | - |
| 4 | - | SELECT name='Minkyu' → 1건 |

### 문제 상황
- 동일 트랜잭션 내에서 같은 쿼리의 결과가 달라짐
- 금전 처리 등에서 심각한 문제 발생 가능
- 예: 입금 총합 계산 중 다른 트랜잭션이 계속 입금 커밋

---

## 3. REPEATABLE READ

### 특징
- MySQL(InnoDB) 기본 격리 수준
- 트랜잭션 내 동일한 결과 보장
- **MVCC**(Multi-Version Concurrency Control) 활용
- 자신보다 낮은 트랜잭션 번호의 커밋 데이터만 읽음

### MVCC 동작 원리
| 요소 | 설명 |
|------|------|
| 트랜잭션 번호 | 순차 증가하는 고유 번호 |
| Undo 영역 | 변경 전 데이터를 트랜잭션 번호와 함께 백업 |
| 스냅샷 | 트랜잭션 시작 시점의 데이터 버전 유지 |

### Non-Repeatable Read 해결
| 시점 | 트랜잭션 10 (B) | 트랜잭션 12 (A) |
|------|---------------|---------------|
| 1 | SELECT id=50 → '박기영' | - |
| 2 | - | UPDATE id=50 → '박경' |
| 3 | - | COMMIT |
| 4 | SELECT id=50 → '박기영' | - |

- 트랜잭션 10은 12보다 먼저 시작
- Undo 영역에서 트랜잭션 10 시작 시점의 데이터 읽음
- 동일한 결과 보장

### Phantom Read

#### 일반 RDBMS에서 발생
| 시점 | 트랜잭션 A | 트랜잭션 B |
|------|----------|----------|
| 1 | - | SELECT FOR UPDATE → 1건 |
| 2 | INSERT id=51 | - |
| 3 | COMMIT | - |
| 4 | - | SELECT FOR UPDATE → 2건 |

#### MySQL은 Phantom Read 거의 없음
- **Next Key Lock** (= Record Lock + Gap Lock) 사용
- SELECT FOR UPDATE 시 범위에 Gap Lock 설정
- INSERT 작업 차단



```
Record Lock (레코드 락)
특정 레코드(행)에 거는 잠금 -> 해당 레코드의 수정/삭제(UPDATE, DELETE) 방지

새로운 레코드 삽입은 막지 못함
```

```
Gap Lock (갭 락)

레코드 사이의 빈 공간에 거는 잠금

Gap: 레코드와 레코드 사이의 빈 공간 -> 아직 존재하지 않지만 삽입될 수 있는 범위

해당 범위에 새 레코드 삽입(INSERT) 방지 -> Phantom Read 방지
```

```
    [10]───(10~20)───[20]───(20~30)───[30]───(30~∞)
     ●      Gap       ●      Gap       ●      Gap
  Record             Record           Record
```

### MySQL Phantom Read 예외 케이스
| 시점 | 트랜잭션 A | 트랜잭션 B |
|------|----------|----------|
| 1 | - | SELECT (잠금 없음) → 1건 |
| 2 | INSERT id=51 | - |
| 3 | COMMIT | - |
| 4 | - | SELECT FOR UPDATE → 2건 |

#### MySQL 케이스별 정리
| 케이스 | Phantom Read |
|--------|--------------|
| SELECT FOR UPDATE → SELECT | X (Gap Lock) |
| SELECT FOR UPDATE → SELECT FOR UPDATE | X (Gap Lock) |
| SELECT → SELECT | X (MVCC) |
| **SELECT → SELECT FOR UPDATE** | **O** |
---

| SELECT 종류 | 읽는 위치 | 트랜잭션 번호 확인 |   
|------|----------|----------|
| SELECT (잠금 없음) | Undo 영역 | O (MVCC 적용) |   
| SELECT FOR UPDATE | 실제 테이블 | X (최신 데이터)  

```
SELECT (잠금 없음)
목적: 데이터 조회만
방식: Undo 영역에서 내 트랜잭션 번호에 맞는 버전 읽기
특징: 다른 트랜잭션에 영향 안 줌


SELECT FOR UPDATE (잠금 있음)
목적: 데이터 조회 + 수정 예정
방식: 실제 테이블에서 직접 읽고 잠금 걸기
특징: 다른 트랜잭션 차단
```


---



## 4. SERIALIZABLE

### 특징
- 가장 높은 격리 수준
- 트랜잭션 순차 처리
- 모든 부정합 문제 방지
- 동시 처리 성능 매우 저하

### Lock 메커니즘
| 작업 | Lock 종류 | 효과 |
|------|----------|------|
| SELECT | Shared Lock (읽기 잠금) | 다른 트랜잭션 읽기 가능, 쓰기 불가 |
| INSERT/UPDATE/DELETE | Exclusive Lock (쓰기 잠금) | 다른 트랜잭션 읽기/쓰기 모두 불가 |

### Shared Lock
- SELECT 시 자동으로 읽기 잠금
- 다른 트랜잭션의 Exclusive Lock 차단
- 트랜잭션이 순차적으로 처리됨

### 사용 권장
- 극단적으로 안전한 작업이 필요한 경우에만 사용
- 일반적인 상황에서는 사용하지 않음

---

## Lock 종류

### Exclusive Lock (배타적 잠금)
| 특징 | 설명 |
|------|------|
| 구문 | SELECT ... FOR UPDATE |
| 효과 | 다른 트랜잭션의 읽기/쓰기 차단 |
| 범위 | 조회된 레코드에만 적용 |
| 한계 | INSERT는 차단 못함 (조회되지 않은 레코드) |

### Next Key Lock (MySQL)
| 구성 | 설명 |
|------|------|
| Record Lock | 조회된 레코드 잠금 |
| Gap Lock | 쿼리 범위에 대한 간격 잠금 |
| 추가 Gap | 마지막 레코드 ~ 다음 레코드까지 |



---

## 핵심 정리

### 격리 수준 선택 기준
| 격리 수준 | 권장 사용 |
|----------|----------|
| READ UNCOMMITTED | 사용 금지 (부정합 심각) |
| READ COMMITTED | 오라클 환경 또는 빠른 응답 필요 시 |
| **REPEATABLE READ** | **MySQL 일반 사용 (기본값)** |
| SERIALIZABLE | 극단적 안전성 필요 시만 |

### 성능 영향
- SERIALIZABLE 제외하면 성능 차이 크지 않음
- Undo 로그 참조 과정은 거의 동일
- MySQL은 REPEATABLE READ 기본 사용 이유:
  - Gap Lock으로 Phantom Read 거의 방지
  - READ COMMITTED보다 높은 정합성
  - 성능 저하 미미

### 트랜잭션 내/외 SELECT 차이
| 격리 수준 | 트랜잭션 내 SELECT | 트랜잭션 외 SELECT |
|----------|-----------------|-----------------|
| READ UNCOMMITTED | 차이 없음 | 차이 없음 |
| READ COMMITTED | 차이 거의 없음 | 차이 거의 없음 |
| **REPEATABLE READ** | **일관된 스냅샷** | **부정합 가능** |
| SERIALIZABLE | 일관된 스냅샷 | 일관된 스냅샷 |