## 📖 조인  알고리즘

### 조인 (Join)

- 관계형 데이터베이스에서 두 개 이상의 테이블을 연결해 하나의 결과 집합으로 반환하는 연산
- DBMS는 내부적으로 여러 가지 조인 알고리즘을 통해 이를 수행함

<br>

### 조인 알고리즘 개념

- 두 테이블 간의 연관된 행을 조인 조건(on 절)에 따라 결합
- 모든 RDBMS(MySQL, PostgreSQL, Oracle 등)에 존재
- DB 엔진이 자동으로 가장 효율적인 방법을 선택 (**옵티마이저 역할**)

<br>

## 📖 주요 조인 알고리즘 종류

### Nested Loop Join (중첩 루프 조인)

: 기본적이고 가장 단순한 조인 알고리즘

#### 동작 방식

1. **외부 테이블(outer table)** 의 각 행을 하나씩 읽음
2. 그 행과 매칭되는 데이터를 **내부 테이블(inner table)** 에서 탐색
3. 조건을 만족하면 결과에 포함
4. 외부 테이블의 다음 행으로 이동하며 반복

```sql
for each row in A:
    for each row in B:
        if A.key = B.key:
            output(A, B)
```

#### 특징

- 인덱스가 존재하면 매우 빠름 (Index Nested Loop Join)
- 인덱스가 없으면 느림 — 내부 테이블을 반복 스캔해야 함
- 작은 테이블과 큰 테이블을 조인할 때 효율적
- 부분 결과를 바로 반환 가능 → 실시간 서비스(이커머스, 검색)에서 자주 사용

#### 성능 요약

| 항목 | 설명 |
| --- | --- |
| 복잡도 | O(M × N) (인덱스 없을 시) |
| 적합한 경우 | 한쪽 테이블이 매우 작고, 인덱스가 있을 때 |
| 단점 | 전체 테이블 스캔 발생 시 비용 큼 |

<br>

### Hash Join (해시 조인)

: 해시 함수를 이용해 빠르게 매칭시키는 조인

#### 동작 방식

1. 두 테이블 중 **작은 테이블을 기준**으로 해시 테이블 생성
    - 키 컬럼을 해시 함수에 넣어 버킷 생성
2. 큰 테이블의 각 행을 읽으며, 같은 해시 값(버킷)에 속한 행과 비교하여 조인 수행

```sql
build hash_table from small_table on key;
for each row in large_table:
    match = hash_table.lookup(row.key)
```

#### 특징

- 등호(=) 비교에 최적화 (`ON A.id = B.id`)
- 해시 테이블 생성 시 초기 비용 발생
- 정렬 과정이 필요 없어 대용량 조인에 유리
- MySQL에서는 주로 `Block Nested Loop Join`이 쓰이고, PostgreSQL/Oracle에서 Hash Join이 적극 사용됨

#### 성능 요약

| 항목 | 설명 |
| --- | --- |
| 복잡도 | O(M + N) |
| 적합한 경우 | 대용량, 인덱스 없는 컬럼 조인 |
| 단점 | 초기 해시 생성 비용, 메모리 사용량 높음 |

<br>

### Soft-Merge Join (정렬 병합 조인)

#### 동작 방식

1. 조인에 사용되는 두 테이블을 조인 키 기준으로 정렬
2. 정렬된 두 테이블을 병합하면서 조인 수행
    - 포인터를 각각 한 칸씩 옮기며 키 비교

```sql
sort A on key;
sort B on key;
merge A and B while A.key = B.key;

```

#### 특징 

- 이미 정렬된 데이터(예: 인덱스 존재) 라면 매우 빠름
- 정렬 과정이 필요한 경우 초기 오버헤드 존재
- `>` `<` 같은 비등호 비교 연산에도 사용 가능
- 대규모 데이터 정렬 및 병합 작업에 적합 (DW, 배치성 처리)

#### 성능 요약

| 항목 | 설명 |
| --- | --- |
| 복잡도 | O(M log M + N log N) |
| 적합한 경우 | 두 테이블 모두 정렬되어 있거나 대용량 배치 작업 |
| 단점 | 정렬 비용 발생, 실시간 처리에는 비효율적 |

<br>

## 📖 옵티마이저의 조인 선택 기준

: DBMS의 옵티마이저(Optimizer)가 통계 정보를 바탕으로 자동으로 가장 효율적인 조인 알고리즘을 선택함

### 고려 요소

- 테이블 크기 (row 수)
- 조인 키의 인덱스 존재 여부
- 조인 조건 (`=` / `<` / `>`)
- 정렬 여부, 메모리 크기, CPU 부하
- 통계 정보 (Cardinality, Selectivity 등)

<br>

### 옵티마이저 힌트

- 개발자가 직접 “이 조인 방식을 써라”고 명령하는 것

```sql
/*+ USE_NL(emp dept) */        -- Nested Loop Join 사용
/*+ USE_HASH(emp dept) */      -- Hash Join 강제
/*+ USE_MERGE(emp dept) */     -- Sort-Merge Join 강제
```

- 하지만 힌트는 옵티마이저의 자율 최적화 능력을 제한하므로, 유지보수 시 주의 필요
- (DB 구조나 통계가 바뀌면 비효율 초래 가능)

<br>

## 💭 조인 알고리즘 Summary

| 구분 | 동작 방식 | 장점 | 단점 | 적합한 상황 |
| --- | --- | --- | --- | --- |
| **Nested Loop Join** | 외부→내부 순차 루프 | 인덱스 활용 가능, 실시간 응답 빠름 | 인덱스 없으면 매우 느림 | 작은 테이블 + 인덱스 |
| **Hash Join** | 해시 버킷 매칭 | 대용량 데이터, `=` 연산 최적 | 해시 생성 비용, 메모리 부담 | 대용량, 인덱스 없음 |
| **Sort-Merge Join** | 정렬 후 병합 | 이미 정렬된 경우 빠름, 비등호 비교 가능 | 정렬 비용 높음 | 대규모 배치 처리 |