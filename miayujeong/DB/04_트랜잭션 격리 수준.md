## 📖 트랜잭션 격리 수준 (Transaction Isolation Level)

- 여러 트랜잭션이 동시에 실행될 때 데이터 일관성을 얼마나 엄격하게 보장할지를 정하는 기준
- 정확성과 성능 간의 트레이드오프 존재

<br>

### 기본 개념

- 트랜잭션이 다른 트랜잭션의 데이터 변경을 어느 시점까지 허용할지 결정
- DBMS마다 구현 방식 조금씩 다름
    - MySQL 기본: `REPEATABLE READ`
    - Oracle 기본: `READ COMMITTED`
- 높은 격리 수준일수록
    
    → 데이터 일관성 ↑
    
    → 동시 처리 성능 ↓
    
<br>

## 📖 트랜잭션 격리 수준 4단계

### Uncommitted Read (커밋되지 않은 읽기)

- 다른 트랜잭션이 아직 커밋하지 않은 데이터도 읽을 수 있음
- 가장 낮은 격리 수준, 일반적으로 잘 사용하지 않음
- 최신 데이터를 즉시 반영해야 하지만, 일관성은 중요하지 않은 경우에만 사용
    
    (ex. 모니터링, 로그 조회 등)
    

#### 발생 가능한 문제: Dirty Read

- 커밋되지 않은 데이터를 읽는 것
- 해당 트랜잭션이 롤백되면 잘못된 데이터를 읽게 됨

#### 예시

```sql
-- 트랜잭션 T1
UPDATE account SET balance = balance - 500 WHERE id = 1;

-- 트랜잭션 T2
SELECT balance FROM account WHERE id = 1;  -- 아직 커밋 안된 T1의 변경 내용을 읽음
```

- T1이 나중에 롤백하면, T2는 존재하지 않는(“가짜”) 데이터를 읽은 셈이 됨
- → 데이터 부정합 발생

<br>

### Read Committed (커밋된 읽기)

- 오직 커밋 완료된 데이터만 읽을 수 있음
- 대부분의 DBMS에서 기본 격리 수준 (Oracle, SQL Server 등)
- 커밋 전 데이터를 읽을 때는 Undo Log 영역에서 읽음

#### 발생 가능한 문제: Non-repeatable Read

- 같은 쿼리를 두 번 실행했는데 결과가 달라지는 현상
- 다른 트랜잭션이 데이터를 수정하고 커밋한 경우 발생

#### 예시

```sql
-- 트랜잭션 T1
SELECT salary FROM employee WHERE id = 10;  -- salary = 1000

-- 트랜잭션 T2
UPDATE employee SET salary = 1500 WHERE id = 10;
COMMIT;

-- 다시 트랜잭션 T1
SELECT salary FROM employee WHERE id = 10;  -- salary = 1500 (결과 달라짐)
```

- 같은 데이터를 읽었지만 중간에 다른 트랜잭션이 값을 바꾸었기 때문에
    
    **→ 일관성 깨짐**
    
<br>

### Repeatable Read (반복 가능 읽기)

- Non-repeatable Read를 방지
- 트랜잭션 내에서 같은 데이터를 여러 번 읽어도 항상 같은 결과 보장
- 단, 새로운 행이 추가되는 건 막지 못함 (→ 팬텀 리드 가능)

#### 발생 가능한 문제: Phantom read

- 한 트랜잭션 내에서 같은 조건의 SELECT를 여러 번 실행했을 때 결과 레코드 수가 달라지는 것
- 다른 트랜잭션이 새로운 행을 INSERT / DELETE한 경우 발생

#### 예시

```sql
-- 트랜잭션 T1
SELECT * FROM orders WHERE amount > 1000;  
-- → 결과: 5 rows

-- 트랜잭션 T2
INSERT INTO orders VALUES (101, 1500);
COMMIT;

-- 다시 트랜잭션 T1
SELECT * FROM orders WHERE amount > 1000;
-- → 결과: 6 rows (새 행이 생김)
```

- 기존 레코드의 데이터는 동일하지만, 새로운 레코드가 생겨 행 수가 달라짐

<br>

### Serializable (직렬화 가능)

- 가장 높은 수준의 격리
- 모든 트랜잭션이 직렬(순차적)으로 실행되는 것처럼 동작
- Dirty / Non-repeatable / Phantom 문제 모두 방지
- 하지만 성능 저하 큼 (동시성 거의 없음)

<br>

## 💭 Summary

| 문제 유형 | 설명 |
| --- | --- |
| **Dirty Read** | 커밋되지 않은 트랜잭션의 데이터를 읽음 |
| **Non-repeatable Read** | 같은 데이터를 두 번 읽었을 때 값이 달라짐 |
| **Phantom Read** | 다른 트랜잭션이 새 데이터를 삽입/삭제해서 조회 결과가 달라짐 |

<br>

| 격리 수준 | Dirty Read | Non-repeatable Read | Phantom Read | 설명 |
| --- | --- | --- | --- | --- |
| **Read Uncommitted** | ✅ 발생 | ✅ 발생 | ✅ 발생 | 커밋되지 않은 데이터 읽기 가능 |
| **Read Committed** | ❌ 방지 | ✅ 발생 | ✅ 발생 | 커밋된 데이터만 읽음 |
| **Repeatable Read** | ❌ 방지 | ❌ 방지 | ✅ 발생 | 같은 데이터는 동일하지만, 새 행은 반영됨 |
| **Serializable** | ❌ 방지 | ❌ 방지 | ❌ 방지 | 완전한 순차 실행, 성능 저하 |