## 📖 인덱스 (Index) 개요

### 개념

- 테이블 내 특정 컬럼(또는 컬럼 조합)의 값과, 해당 값이 저장된 레코드의 위치를 함께 저장한 검색용 자료구조
- 책의 목차(색인)과 같은 역할; 원하는 페이지를 빠르게 찾아감
- 핵심 효과: `WHERE`, `ORDER BY`, `GROUP BY`, `JOIN`에 대한 처리 속도 향상

<br>

### Full scan vs. Index scan

- 검색 방식
- Full Table Scan: 테이블 전체를 처음부터 끝까지 읽음
- Index Scan: 인덱스 구조에서 필요한 키를 찾아 레코드 위치로 바로 이동

<br>

## 📖 인덱스 장단점

### 장점

- 검색 대상 범위를 줄여 조회 속도 향상
- `UNIQUE` 인덱스로 중복 방지 / 유일성 보장
- `ORDER BY`, `GROUP BY` 시 이미 정렬된 구조를 활용해 정렬 비용 감소
- 조인 시 매칭 성능 향상

<br>

### 단점

- 인덱스 생성에 따른 추가 저장공간 필요 (일반적으로 테이블 크기의 10~20%)
- `INSERT`, `UPDATE`, `DELETE` 시 인덱스도 함께 수정해야 하므로 쓰기 성능 저하
- 병행성(Concurrency) 감소 — 특정 페이지에 락이 걸림
- 너무 많은 인덱스는 오히려 성능 저하 + 관리 부담

⇒ Read가 많은 시스템에는 유리하지만, Write가 잦은 시스템에서는 신중하게 사용할 필요 

<br>

## 📖 인덱스 사용

### 인덱스의 동작과 관리

- 인덱스는 항상 정렬된 상태 유지해야 함
- → 삽입/삭제/갱신 시마다 추가적인 연산 발생

| 연산 | 인덱스의 동작 |
| --- | --- |
| **INSERT** | 새로운 키를 트리에 삽입 |
| **DELETE** | 해당 키 삭제 및 트리 재정렬 |
| **UPDATE** | 기존 키 삭제 → 새로운 키 삽입 |

<br>

### 인덱스 사용이 효과적인 경우

|  |  |
| --- | --- |
| **대용량 데이터 검색** | 전체 스캔보다 인덱스 탐색이 훨씬 빠름 |
| **정렬된 결과 출력** | 이미 정렬되어 있어 정렬 과정 생략 |
| **JOIN 연산** | 조인 대상 키를 빠르게 탐색 가능 |
| **자주 조회되는 컬럼** | 반복적인 쿼리의 성능 향상 |
| **유니크한 값 탐색** | 특정 키(예: 주민번호, 사번 등)에 즉시 접근 가능 |

<br>

## 📖 인덱스 종류

### 역할 기준

|  |  |
| --- | --- |
| **클러스터형 인덱스 (Clustered Index)** | 데이터 자체가 인덱스 순서대로 물리적으로 정렬되어 저장됨. 테이블당 1개만 가능. (ex. PK) |
| **비클러스터형 인덱스 (Non-clustered Index)** | 인덱스는 별도 공간에 저장되며, 인덱스가 실제 데이터의 위치를 가리킴. 여러 개 생성 가능. |

<br>

### 구조 기준

#### 해시 테이블 (Hash table) Index

- Key를 해시 함수로 변환 → 해시 버킷에 직접 접근 (O(1))
- **등호(=)** 조건 검색에 매우 빠름
    
    예: `WHERE user_id = 1001`
    
- **범위 검색(>, <, BETWEEN)**에 비효율적
- 해시 충돌 해결 필요 (chaining 등)

#### B-Tree Index

- 가장 일반적인 인덱스 구조
- 트리가 항상 균형(balanced) 상태 유지 → 탐색 O(log N)
- 각 노드는 여러 키를 가질 수 있고, 키와 데이터가 함께 저장됨
- 루트 → 내부 노드 → 리프 노드 순으로 탐색

#### B+Tree Index

- 대부분의 RDBMS(MySQL, PostgreSQL 등)이 사용하는 구조
- B-Tree의 확장 버전:
    - 데이터는 리프 노드에만 저장
    - 내부 노드는 검색용 키 값만 저장
    - 리프 노드들은 연결 리스트로 연결되어 순차 탐색 가능
- **범위 검색 (`BETWEEN`, `>`, `<`)** 에 효율적
- ORDER BY, GROUP BY, Range Query 에 최적화됨

<br>

## 📖 인덱스 설계 시 고려사항

|  |  |  |
| --- | --- | --- |
| **조건절 사용 빈도** | WHERE 절에 자주 등장하는 컬럼 | 자주 조회될수록 좋음 |
| **비교 연산자 형태** | '`=`' 연산을 자주 사용하는 컬럼 | 인덱스 효율적 |
| **카디널리티 (Cardinality)** | 값의 중복도 | 중복이 적을수록 좋음 |
| **선택도 (Selectivity)** | 특정 값을 선택할 확률 | 선택도가 높을수록 효율적 |
| **활용도** | 쿼리에서의 등장 빈도 | 높을수록 인덱스 후보 |
| **다중 컬럼 인덱스 순서** | 복합 인덱스의 순서 중요 | WHERE 절 조건 순서 고려 필요 |

⇒ 다음과 같은 조건들을 만족할수록 good…:

- `WHERE`, `JOIN`, `ORDER BY` 에 자주 쓰이는 컬럼일수록
- 값의 중복도가 낮을수록 (고유한 값 많을수록)
- 데이터 변경(`INSERT`, `UPDATE`, `DELETE`) 자주 일어나지 않을수록
- 다중 컬럼 인덱스라면 조건절 순서와 일치할수록