## 싱글톤 & 팩토리

### 디자인 패턴(Design Pattern)

**개념**

- 객체 지향 프로그래밍(OOP)에서 자주 등장하는 문제에 대한 일반적인 해결방법(설계구조)
- 구조나 설계 방식을 **재활용**

<br>

**필요성**

- 중복 설계 최소화 : 이미 검증된 패턴 구조 적용
- 유지보수, 확장성 : 패턴들은 유연한 구조(추상화, 인터페이스, 의존성 주입)를 사용 → 수정, 기능 추가 쉬움
- 협업에서 공통 언어 역할 : 이름(ex. 싱글톤, 팩토리, 옵저버)만 말해도 팀원들끼리 어떤 구조인지 즉시 이해

<br>

**분류**

- 생성(Creational)
    - 객체 생성 책임을 분리
    - 객체 생성 방식을 효율적으로 설계 목적
    - ex. Singleton, Factory, Builder, Prototype, Abstract Factory
- 구조(Structural)
    - 클래스 간 관계와 조합 관리
    - 클래스나 객체 간의 구조적 관계 설계
    - ex. Adapter, Decorator, Composite, Proxy, Facade, Bridge
- 행위(Behavioral)
    - 객체 간 메시지 흐름 제어
    - 객체 간의 행동과 협력 방식 설계
    - ex. Observer, Strategy, Command, State, Template Method, Iterator

### 싱글톤 패턴(Singleton Pattern)

**개념**

- 프로그램 전체에서 하나의 객체만 존재하도록 보장하는 디자인 패턴
- 전역적으로 공유되는 인스턴스 생성, 여러 곳에서 동일 객체 사용
- DB 연결 객체, 로그 관리자, 설정(config) 객체, 캐시 객체 등에 자주 사용

<br>

**장단점**

- 장점
    - 전역 상태 쉽게 관리
    - 객체 생성 비용 절약
- 단점
    - 의존성 ↑, 테스트 어려움
    - 멀티스레드 환경에서는 동기화(synchronization) 주의 필요
    - 

<br>

**동작 방식**

- 클래스 내부에 자기 자신을 가리키는 static 변수 둠
- 생성자를 `private`으로 막아 외부에서 `new`로 생성하지 못하게 함
- `getInstance()` 같은 정적 메서드를 통해 단 하나의 인스턴스 제공

```cpp
#include<iostream>

class Singleton {
private:
    // Singleton 클래스의 생성자, private: 밖에서 객체 만들 수 없음
	Singleton() {}
    // 복사 생성자, 복사 대입 연산자도 private으로 막음
	Singleton(const Singleton& ref) {}
	Singleton& operator=(const Singleton& ref) {}
	~Singleton() {}
public:
    // Singleton의 핵심 코드
	static Singleton& getIncetance() {
		static Singleton s; // 함수 내부의 static은 프로그램 전체에서 딱 한번 생성
		return s;
	}
};

int main(void) {
	Singleton& s = Singleton::getIncetance();
	return 0;
}
```

### 팩토리 패턴(Factory Pattern)

**개념**

- 객체 생성 과정을 캡슐화하여, 객체를 생성하는 로직을 한 곳에서 관리하는 패턴
- 객체를 직접 new로 만들지 않고, 팩토리를 통해 생성하는 구조
- 클라이언트가 구체적인 클래스 이름을 몰라도 객체 생성 가능
- 코드 변경 없이 새로운 객체 타입 쉽게 추가 가능

<br>

**팩토리 메서드 패턴(Factory Method Pattern)**

- 객체 생성 코드를 서브클래스에 위임하는 패턴
- `new` 연산자 직접 사용 X
- 팩토리 메서드라는 가상 함수를 두고 구체적인 객체 생성을 하위 클래스가 오버라이드하게 함
- 장점
    - 객체 생성 코드 분리 → 결합도 낮음
    - 새로운 클래스 추가되어도 기존 코드 수정 없이 확장 가능
- 단점
    - 클래스 수 많아짐
    - 구조 복잡

```cpp
// 팩토리 메서드 패턴 (Factory Method Pattern)

// Parent 클래스 (제품)
class Parent {
public:
    virtual ~Parent() = default;
    virtual void print() const = 0;
};

// Child 클래스들 (구체적인 제품)
class ChildA : public Parent {
public:
    void print() const override {
        std::cout << "ChildA\n";
    }
};

class ChildB : public Parent {
public:
    void print() const override {
        std::cout << "ChildB\n";
    }
};

// Factory 클래스 (생성자)
class Factory {
public:
    virtual ~Factory() = default;
    virtual std::unique_ptr<Parent> create() const = 0;
};

// 구체적인 Factory 클래스들
class FactoryA : public Factory {
public:
    std::unique_ptr<Parent> create() const override {
        return std::make_unique<ChildA>();
    }
};

class FactoryB : public Factory {
public:
    std::unique_ptr<Parent> create() const override {
        return std::make_unique<ChildB>();
    }
};
```

<br>

**추상 팩토리 패턴(Abstract Factory Pattern)**

- 서로 관련 있는 객체들을 한 번에 생성하는 패턴
- 제품군(Family) 전체를 생성하는 인터페이스 제공
- 여러 객체(제품)가 함께 동작해야 하는 경우, 각각의 생성 코드 분리하지 않고 한 팩토리에서 모두 관리
- 팩토리의 교체만으로 전체 제품군 교체 가능
- 장점
    - 제품군 교체 쉬움
    - 객체 생성의 일관성, 확장성 높음
- 단점
    - 구조 복잡
    - 새로운 제품 종류 추가 어려움

```cpp
// 2. 추상 팩토리 패턴 (Abstract Factory Pattern)

// Parent1 클래스 (제품군 1)
class Parent1 {
public:
    virtual ~Parent1() = default;
    virtual void print() const = 0;
};

class Child1A : public Parent1 {
public:
    void print() const override {
        std::cout << "Child1A\n";
    }
};

class Child1B : public Parent1 {
public:
    void print() const override {
        std::cout << "Child1B\n";
    }
};

// Parent2 클래스 (제품군 2)
class Parent2 {
public:
    virtual ~Parent2() = default;
    virtual void print() const = 0;
};

class Child2A : public Parent2 {
public:
    void print() const override {
        std::cout << "Child2A\n";
    }
};

class Child2B : public Parent2 {
public:
    void print() const override {
        std::cout << "Child2B\n";
    }
};

// 추상 팩토리 (제품군 전체를 생성하는 인터페이스)
class AbstractFactory {
public:
    virtual ~AbstractFactory() = default;
    virtual std::unique_ptr<Parent1> createParent1() const = 0;
    virtual std::unique_ptr<Parent2> createParent2() const = 0;
};

// 구체적인 팩토리들
class ConcreteFactoryA : public AbstractFactory {
public:
    std::unique_ptr<Parent1> createParent1() const override {
        return std::make_unique<Child1A>();
    }
    std::unique_ptr<Parent2> createParent2() const override {
        return std::make_unique<Child2A>();
    }
};

class ConcreteFactoryB : public AbstractFactory {
public:
    std::unique_ptr<Parent1> createParent1() const override {
        return std::make_unique<Child1B>();
    }
    std::unique_ptr<Parent2> createParent2() const override {
        return std::make_unique<Child2B>();
    }
};
```