# 빌더 & 커맨드

## 1. 빌더 패턴(Builder Pattern)

**개념**

- 복잡한 객체 생성 과정을 단계별로 분리해서 같은 생성 과정으로 다른 표현의 객체를 만들 수 있게 하는 패턴
- 객체 생성 시 필수 값 + 선택 값이 많고, 생성 과정이 복잡한 경우에 사용
- 점층적 생성자 패턴(Telescoping Constructor Pattern)의 문제 해결을 위해 생성자(Constructor) 대신 빌더 사용

**구조**

- Product : 만들어지는 객체
- Builder : 객체를 단계별로 만들 메서드 제공
- ConcreteBuilder : 실제 빌드 로직 구현, 실제 조립 과정을 구현하고 부품을 모으는 역할
- Director(optional) : 빌드 순서 조립
- ex. 피자 만들기 : 도우 → 토핑 → 치즈 → 굽기

```cpp
class Pizza {
public:
    string dough, cheese, topping;
};

class PizzaBuilder {
    Pizza p;
public:
    PizzaBuilder& setDough(string d) { p.dough = d; return *this; }
    PizzaBuilder& setCheese(string c) { p.cheese = c; return *this; }
    PizzaBuilder& setTopping(string t) { p.topping = t; return *this; }
    Pizza build() { return p; }
};

// 체이닝 방식
Pizza pizza = PizzaBuilder()
                .setDough("thin")
                .setCheese("mozzarella")
                .setTopping("pepperoni")
                .build(); // 이 시점에 완성된 객체 반환

```

**장단점**

- 장점
    - 생성 과정 단계별 분리로 유연함 높음
    - 복잡한 객체 생성 과정 캡슐화
    - 가독성 증가
- 단점
    - 클래스 수 증가 → 구조 복잡
    - 단순한 객체 생성에는 오버엔지니어링


## 2. 커맨드 패턴(Command Pattern)

**개념**

- 요청을 객체로 캡슐화하여 서로 다른 요청을 매개변수화 하거나 요청 취소(Undo) 기능을 제공하는 패턴
- 명령 자체를 객체로 만들어 저장하는 구조

**사용 예시**

- 요청을 나중에 실행하고 싶은 경우
- 되돌리기(Undo)/재실행(Redo) 기능 필요한 경우
- 요청의 발신자(Invoker)와 수신자(Receiver)를 강하게 결합시키고 싶지 않은 경우 (Decoupliing)

**구조**

- Command Interface : 모든 명령의 인터페이스, 주로 `execute()` 메서드 하나 가짐
- ConcreteCommand : 실제 명령 구현체, Receiver 가지고 있으며 `execute()` 호출 시 Receiver의 메서드 실행
- Receiver : 실제 기능 수행하는 객체 (ex. TV, 전등)
- Invoker : 커맨드를 실행하는 주체 (ex. 리모컨 버튼)
- Client : 커맨드 객체 생성

```cpp
// Receiver
class Light {
public:
    void on() { cout << "Light ON\n"; }
    void off() { cout << "Light OFF\n"; }
};

// Command interface
class Command {
public:
    virtual void execute() = 0;
};

// ConcreteCommand
class LightOnCommand : public Command {
    Light& light;
public:
    LightOnCommand(Light& l) : light(l) {}
    void execute() override { light.on(); }
};

// Invoker(리모컨)
class RemoteControl {
    Command* command;
public:
    void setCommand(Command* c) { command = c; }
    void pressButton() { command->execute(); } // 구체적인 내용은 모름
};

// Client
Light light;
LightOnCommand onCmd(light);
RemoteControl remote;

remote.setCommand(&onCmd);
remote.pressButton();  // Light ON

```

**장단점**

- 장점
    - 실행/취소/재실행 간단 : 명령이 객체로 저장되므로 스택에 쌓아 undo 기능 구현 쉬움
    - 요청을 큐나 로그로 저장 가능
    - Invoker - Receiver 결합도 감소
    - 확장성 높음 : 새 명령이 추가되어도 버튼 클래스 수정 필요 X
- 단점
    - 커맨드 클래스 수 증가 (요청마다 하나씩 필요)

## 3. 빌더 vs 커맨드 비교

| **특징** | **빌더 패턴 (Builder)** | **커맨드 패턴 (Command)** |
| --- | --- | --- |
| **목적** | **복잡한 객체 생성** 과정을 단순화 | **요청(행위)**을 객체로 만들어 캡슐화 |
| **유형** | 생성 패턴 (Creational) | 행위 패턴 (Behavioral) |
| **핵심 키워드** | 가독성, 불변 객체, 단계적 생성 | Undo/Redo, Decoupling(분리), 큐(Queue) |
| **실생활 예시** | 서브웨이 샌드위치 주문 (빵 선택 -> 야채 선택 -> 소스 선택) | 리모컨 버튼 (TV 켜기, 볼륨 조절 등을 버튼에 할당) |