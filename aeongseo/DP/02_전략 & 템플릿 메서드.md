## 전략 & 템플릿 메서드

### 전략 패턴(Strategy Pattern)

**개념**

- = 정책 패턴(Policy Pattern)
- 알고리즘을 캡슐화하여 상황에 따라 수정할 수 있게 만드는 패턴
- 알고리즘을 캡슐화하고, 실행 중에도 쉽게 바꾸는 것이 목적

**구조**

- Context : 전략을 사용하는 객체(클라이언트가 조작)
- Strategy(Interface) : 알고리즘의 공통 인터페이스
- Concrete Strategy : 실제 알고리즘들(교체 가능)

```cpp
#include <iostream>
#include <memory>
using namespace std;

// ================================
// Strategy (알고리즘 인터페이스)
// ================================
class AttackStrategy {
public:
    virtual ~AttackStrategy() = default;
    virtual void attack() = 0;
};

// ================================
// Concrete Strategy 1
// ================================
class MeleeAttack : public AttackStrategy {
public:
    void attack() override {
        cout << "검으로 근접 공격!\n";
    }
};

// ================================
// Concrete Strategy 2
// ================================
class MagicAttack : public AttackStrategy {
public:
    void attack() override {
        cout << "마법으로 원거리 공격!\n";
    }
};

// ================================
// Concrete Strategy 3
// ================================
class BowAttack : public AttackStrategy {
public:
    void attack() override {
        cout << "활로 원거리 공격!\n";
    }
};

// ================================
// Context (전략을 사용하는 쪽)
// ================================
class Character {
private:
    unique_ptr<AttackStrategy> strategy;

public:
    Character(unique_ptr<AttackStrategy> s)
        : strategy(move(s)) {}

    void setStrategy(unique_ptr<AttackStrategy> s) {
        strategy = move(s);
    }

    void attack() {
        strategy->attack();
    }
};

```

**장단점**

- 장점
    - 알고리즘 쉽게 교체 가능
    - 조건문 제거 → 코드 깔끔
    - Open-Closed 원칙 준수(새 전략 추가 쉬움)
- 단점
    - 클래스 수 증가
    - 전략 객체를 외부에서 관리해야 함

---

### 템플릿 메서드 패턴(Template Method Pattern)

**개념**

- 상위 클래스에서 알고리즘의 골격(template)을 정해두고, 세부 단계는 하위 클래스가 구현하게 하는 패턴
- 변하지 않는 기능을 상위 클래스에 생성, 자주 변경되어 확장할 기능을 하위 클래스에 생성
- 상속 극대화, 알고리즘 뼈대 맞추는 것에 초점

**구조**

- Abstract Class
    - 전체 알고리즘 흐름(템플릿 메서드) 정의
    - 일부 메서드는 추상 메서드로 남김 → 하위 클래스에 위임
- Concrete Class
    - 추상 메서드 구현하여 구체 기능 채움

```cpp
#include <iostream>
#include <string>
using namespace std;

// =================================
// Abstract Class (템플릿 메서드 보유)
// =================================
class FileProcessor {
public:
    virtual ~FileProcessor() = default;

    // Template Method (전체 흐름을 고정)
    void process(const string& filename) {
        openFile(filename);
        readData();
        parseData();     // <-- 하위 클래스에서 구현
        closeFile();
    }

protected:
    void openFile(const string& filename) {
        cout << filename << " 파일 열기\n";
    }

    void readData() {
        cout << "파일 데이터 읽기\n";
    }

    // Concrete Class가 반드시 구현해야 하는 단계
    virtual void parseData() = 0;

    void closeFile() {
        cout << "파일 닫기\n";
    }
};

// =================================
// Concrete Class 1
// =================================
class CSVFileProcessor : public FileProcessor {
protected:
    void parseData() override {
        cout << "CSV 형식으로 데이터 파싱\n";
    }
};

// =================================
// Concrete Class 2
// =================================
class JSONFileProcessor : public FileProcessor {
protected:
    void parseData() override {
        cout << "JSON 형식으로 데이터 파싱\n";
    }
};

```

**장단점**

- 장점
    - 공통 흐름을 부모가 제공 → 중복 제거
    - 하위 클래스는 차이 나는 부분만 작성
    - 알고리즘의 큰 흐름이 안정적으로 유지됨
- 단점
    - 상속 사용하므로 구조 강하게 묶임
    - 알고리즘의 단계 변경 쉽지 않음(하위 클래스가 아닌 부모 수정 필요)
    - 클래스 수 증가

---

### 전략 패턴 vs 템플릿 메서드 패턴 차이

| 차이 | 전략 패턴 | 템플릿 메서드 |
| --- | --- | --- |
| 공통 구조 | 일부 알고리즘을 바꿀 수 있음 | 전체 알고리즘은 고정, 일부 단계만 변경 |
| 중심 | **Context가 중심** (조립으로 전략 사용) | **추상 부모 클래스가 중심** (상속으로 흐름 고정) |
| 구성 방식 | **Composition (객체 끼워 넣기)** | **Inheritance (상속)** |
| 교체 시점 | **런타임에 자유로운 교체** | 하위 클래스 교체 필요 → **컴파일 시점** |