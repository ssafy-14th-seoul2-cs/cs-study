## 옵저버 & 퍼블리셔-서브스크라이버

### 옵저버 패턴(Observer Pattern)

**개념**

- 객체 1개(Subject)의 상태 변화가 있을 때 여러 객체(Observer)에게 자동으로 알리는 패턴
- 객체 간 1:N의 직접적 의존 관계

**구조**

- Subject : Observer 목록 들고 있음, 상태 변화 시 모든 Observer의 update() 실행
- Observer : Subject로부터 알림 받아 update() 실행

**동작 흐름**

- Observer가 Subject에 등록(register)
- Subject의 데이터나 상태 변함
- Subject가 직접 Observer 호출하여 update() 실행
- Observer는 그 알림 기반으로 행동
- ex. 유튜버(Subject)가 영상 업로드 → 구독자들(Observer)에게 즉시 알림

```cpp
class Observer {
public:
    virtual void update(int data) = 0;
};

class Subject {
    vector<Observer*> observers;
    int state;

public:
    void addObserver(Observer* obs) { observers.push_back(obs); }

    void setState(int s) {
        state = s;
        notify();
    }

    void notify() {
        for (auto obs : observers) {
            obs->update(state);
        }
    }
};

```

**장단점**

- 장점
    - 객체 간 자동 업데이트
    - 런타임에 Observer 동적으로 추가/제거 가능
    - 코드 구조 단순
- 단점
    - Subject와 Observer가 서로 강하게 결함 → 객체 간 의존성
    - 확장성 낮음
    - 순환 호출 위험

---

### 퍼블리셔-서브스크라이버 패턴(Publisher-Subscriber, Pun/Sub)

**개념**

- 추상 메시지 채널(Message Broker)를 통해 Publisher와 Subscriber가 서로 모른 채 통신하는 비동기 메시징 패턴
- Publisher와 Subscriber 간 완전히 느슨한 결합(Decoupling)

**구조**

- Publisher : 메시지를 특정 Topic에 발행
- Subscriber : 관심 있는 Topic을 구독
- Broker/Event Bus : 둘 사이에서 메시지 중개
- ex. 우편 시스템
    - Publisher : 주소만 적어서 우편함에 넣음
    - Subscriber : 자기 우편함에서 필요한 우편만 가져감
    - 발신자와 수신자 서로 존재 모름

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>
#include <functional>

using namespace std;

// ------------------------
// MessageBroker (Event Bus)
// ------------------------
class MessageBroker {
private:
    unordered_map<string, vector<function<void(const string&)>>> subscribers;

public:
    // subscriber 등록
    void subscribe(const string& topic, function<void(const string&)> callback) {
        subscribers[topic].push_back(callback);
    }

    // publisher가 메시지 발행
    void publish(const string& topic, const string& message) {
        if (subscribers.find(topic) == subscribers.end()) return;

        for (auto& callback : subscribers[topic]) {
            callback(message);   // 구독자 콜백 실행
        }
    }
};

// ------------------------
// Subscriber
// ------------------------
class Subscriber {
private:
    string name;

public:
    Subscriber(const string& name) : name(name) {}

    void onMessage(const string& message) {
        cout << "[" << name << "] received: " << message << endl;
    }
};

// ------------------------
// Publisher
// ------------------------
class Publisher {
private:
    MessageBroker& broker;

public:
    Publisher(MessageBroker& broker) : broker(broker) {}

    void publish(const string& topic, const string& msg) {
        broker.publish(topic, msg);
    }
};
```

**장단점**

- 장점
    - 극도로 낮은 결합도(Decoupling)
    - 비동기 처리 가능 → 높은 확장성
    - 여러 구독자가 하나의 메시지를 다양한 방식으로 처리 가능
    - 장애 격리
- 단점
    - 중간에 Broker가 필요해 인프라 복잡도 증가
    - Debugging 어려움
    - 즉시성(동기성) 보장 어려움
    - 메시지 순서/중복 문제 해결 필요

---

### Observer vs Pub/Sub 차이

| 구분 | 옵저버 패턴 | 퍼블리셔-서브스크라이버 |
| --- | --- | --- |
| 의존성 | Subject가 Observer를 직접 알고 있음 (강한 결합) | Publisher와 Subscriber가 서로 모름 (완전히 느슨한 결합) |
| 중개자(Broker) | 없음 | 있음 (Message Broker) |
| 통신 방식 | 보통 동기식 (즉시 호출) | 비동기 메시징 |
| 목적 | 객체 간 상태 변화 전달 | 시스템 간 데이터/이벤트 전달 |
| 규모 | 보통 소규모, 단일 프로세스 | 대규모, 분산 시스템에서 사용 |