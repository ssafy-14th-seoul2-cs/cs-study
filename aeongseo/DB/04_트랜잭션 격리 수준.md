## 트랜잭션 격리 수준(Isolation Level)

1. **정의**

- 동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 격리되어 있는가에 대한 수준

2. **격리성(Isolation)**

- 트랜잭션 수행 시 다른 트랜잭션이 끼어들지 못하도록 보장하는 것
- 격리성 강화시키면 다른 트랜잭션이 끼어들지 못하게 보장 가능 → 데이터 정확성 보장, 처리 속도 느림
- 약화시키면 다른 트랜잭션도 중간에 끼어들 수 있음
- 준수한 처리 속도 위해서는 트랜잭션의 완화된 수준의 격리 필요
- 트랜잭션의 격리 수준 : 속도와 데이터 정확성에 대한 트레이드 오프를 고려하여 트랜잭션의 격리 수준 나눈 것

3. **각 수준의 내부 동작 원리**

- READ UNCOMMITTED
    - Shared Lock 사용 안함
    - 가장 빠르지만 불안정, Dirty Read 가능
- READ COMMITTED
    - 읽을 때 Shared Lock 획득 → 즉시 해제
    - 항상 커밋된 최신 데이터 읽음
- REPEATABLE READ
    - 트랜잭션 동안 읽은 행에 Shared Lock 유지
    - 동일 행은 일관성 유지, 새로운 행 삽입은 감지 못함
- SERIALIZABLE
    - 읽기/쓰기 모두 Lock 또는 MVCC 버전 제어
    - 트랜잭션 간 완전한 순차 실행 보장, 성능 저하 큼

4. **DBMS별 기본 격리 수준**
    
    
    | DBMS | 기본 격리 수준 | 동시성 제어 방식 |
    | --- | --- | --- |
    | **Oracle** | READ COMMITTED | MVCC (다중 버전) |
    | **MySQL (InnoDB)** | REPEATABLE READ | MVCC + Gap Lock |
    | **PostgreSQL** | READ COMMITTED | MVCC |
    | **SQL Server** | READ COMMITTED | Lock 기반 |

5. **동시성 제어 시 발생 가능한 이상현상 (Anomalies)**

- Dirty Read
    - 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 경우
    - ex. T1이 값 변경 후 아직 커밋 전인데 T2가 그 값을 읽음
- Non-Repeatable Read
    - 같은 데이터를 두 번 읽을 때 값이 달라짐
    - ex. T1이 읽은 후 T2가 수정하고 커밋
- Phantom Read
    - 조건 검색 결과의 행 개수가 달라짐
    - ex. T1이 “age>30”을 조회 후 T2가 새 행 삽입

6. **ANSI/ISO SQL 표준 격리 수준 4단계**
    
    | 수준 | Dirty Read | Non-Repeatable Read | Phantom Read | 설명 |
    | --- | --- | --- | --- | --- |
    | 1. READ UNCOMMITTED | 발생 가능 | 발생 가능 | 발생 가능 | 커밋되지 않은 데이터도 읽음 |
    | 2. READ COMMITTED | 방지 | 발생 가능 | 발생 가능 | 커밋된 데이터만 읽음 (Oracle 기본) |
    | 3. REPEATABLE READ | 방지 | 방지 | 발생 가능 | 동일 행은 일관성 있게 유지 (MySQL 기본) |
    | 4. SERIALIZABLE | 방지 | 방지 | 방지 | 완전 직렬화, 가장 높은 일관성 |