# 정규화 & 반정규화 (Normalization & Denormalization)

## 정규화란?

**정규화**는 데이터베이스의 테이블을 **효율적으로 정리하는 과정**입니다.

## 왜 정규화가 필요한가?

### 정규화하지 않은 나쁜 예

**학생_수강_테이블**

| 학번 | 이름 | 학과 | 학과전화번호 | 수강과목 | 담당교수 | 교수연락처 |
|------|------|------|------------|---------|---------|----------|
| 2021001 | 김철수 | 컴퓨터공학 | 02-123-4567 | 데이터베이스 | 박교수 | 010-1111-2222 |
| 2021001 | 김철수 | 컴퓨터공학 | 02-123-4567 | 알고리즘 | 이교수 | 010-3333-4444 |
| 2021002 | 이영희 | 컴퓨터공학 | 02-123-4567 | 데이터베이스 | 박교수 | 010-1111-2222 |

### 문제점

**1. 중복 데이터 (Data Redundancy)**
- 김철수의 정보가 2번 중복
- 컴퓨터공학과 전화번호가 3번 중복
- 저장 공간 낭비

**2. 수정 이상 (Update Anomaly)**
- 학과 전화번호가 바뀌면?
- 3개 행을 모두 수정해야 함
- 하나라도 빠뜨리면 데이터 불일치

**3. 삽입 이상 (Insertion Anomaly)**
- 신설 학과를 등록하려면?
- 학생이 없어도 학과 정보는 저장해야 하는데
- NULL 값이 많이 생김

**4. 삭제 이상 (Deletion Anomaly)**
- 김철수가 모든 수강을 취소하면?
- 학생 정보를 삭제하면 학과 정보도 사라짐
- 의도하지 않은 정보 손실

## 정규화의 목표

1. **데이터 중복 최소화**
2. **데이터 무결성 보장** (정확하고 일관된 데이터)
3. **이상 현상 방지**
4. **효율적인 데이터 저장**

---

## 정규화 단계

정규화는 **1차 정규화부터 5차 정규화**까지 있지만, 실무에서는 보통 **3차 정규화**까지만 진행한다.

### 제1정규형 (1NF: First Normal Form)

**규칙: 모든 속성은 원자값을 가져야 한다**

"원자값"이란 **더 이상 쪼갤 수 없는 값**을 의미

#### 1NF 위반 예시

| 학번 | 이름 | 수강과목 |
|------|------|---------|
| 2021001 | 김철수 | 데이터베이스, 알고리즘, 운영체제 |
| 2021002 | 이영희 | 자료구조, 네트워크 |

**문제점:**
- 수강과목이 여러 개가 한 셀에 있음
- "데이터베이스"만 검색하기 어려움
- 특정 과목을 수정/삭제하기 복잡

#### 1NF 적용 후

| 학번 | 이름 | 수강과목 |
|------|------|---------|
| 2021001 | 김철수 | 데이터베이스 |
| 2021001 | 김철수 | 알고리즘 |
| 2021001 | 김철수 | 운영체제 |
| 2021002 | 이영희 | 자료구조 |
| 2021002 | 이영희 | 네트워크 |

**개선:**
- 각 셀에 하나의 값만
- 검색과 관리가 쉬워짐

하지만 여전히 "김철수"가 중복된다. 2차 정규화가 필요

---

### 제2정규형 (2NF: Second Normal Form)

**규칙: 1NF를 만족하고, 부분 함수 종속을 제거**

**부분 함수 종속**이란?
- 기본키가 여러 개일 때 (복합키)
- 기본키의 일부분만으로도 다른 속성을 결정할 수 있는 경우

#### 2NF 위반 예시

**수강 테이블** (기본키: 학번 + 과목코드)

| 학번 | 과목코드 | 학생이름 | 학과 | 과목명 | 담당교수 |
|------|---------|---------|------|--------|---------|
| 2021001 | CS101 | 김철수 | 컴퓨터공학 | 데이터베이스 | 박교수 |
| 2021001 | CS102 | 김철수 | 컴퓨터공학 | 알고리즘 | 이교수 |
| 2021002 | CS101 | 이영희 | 전자공학 | 데이터베이스 | 박교수 |

**문제점:**
- 학생이름, 학과는 **학번만으로** 결정됨
- 과목명, 담당교수는 **과목코드만으로** 결정됨
- 기본키 전체(학번+과목코드)가 필요 없음

#### 2NF 적용 후

**학생 테이블** (기본키: 학번)
| 학번 | 학생이름 | 학과 |
|------|---------|------|
| 2021001 | 김철수 | 컴퓨터공학 |
| 2021002 | 이영희 | 전자공학 |

**과목 테이블** (기본키: 과목코드)
| 과목코드 | 과목명 | 담당교수 |
|---------|--------|---------|
| CS101 | 데이터베이스 | 박교수 |
| CS102 | 알고리즘 | 이교수 |

**수강 테이블** (기본키: 학번 + 과목코드)
| 학번 | 과목코드 |
|------|---------|
| 2021001 | CS101 |
| 2021001 | CS102 |
| 2021002 | CS101 |

**개선:**
- 중복 데이터 제거
- 학생 정보와 과목 정보 분리

하지만 아직 문제가 남아있다. 3차 정규화가 필요

---

### 제3정규형 (3NF: Third Normal Form)

**규칙: 2NF를 만족하고, 이행적 함수 종속을 제거**

**이행적 함수 종속**이란?
- A → B, B → C이면 A → C인 관계
- 기본키가 아닌 속성이 다른 속성을 결정하는 경우

#### 3NF 위반 예시

**학생 테이블** (기본키: 학번)

| 학번 | 학생이름 | 학과코드 | 학과명 | 학과전화번호 |
|------|---------|---------|--------|------------|
| 2021001 | 김철수 | CS | 컴퓨터공학 | 02-123-4567 |
| 2021002 | 이영희 | CS | 컴퓨터공학 | 02-123-4567 |
| 2021003 | 박민수 | EE | 전자공학 | 02-234-5678 |

**문제점:**
- 학번 → 학과코드 (OK)
- 학과코드 → 학과명, 학과전화번호
- 즉, 학번 → 학과코드 → 학과명 (이행적 종속)
- 학과 정보가 중복됨

#### 3NF 적용 후

**학생 테이블** (기본키: 학번)
| 학번 | 학생이름 | 학과코드 |
|------|---------|---------|
| 2021001 | 김철수 | CS |
| 2021002 | 이영희 | CS |
| 2021003 | 박민수 | EE |

**학과 테이블** (기본키: 학과코드)
| 학과코드 | 학과명 | 학과전화번호 |
|---------|--------|------------|
| CS | 컴퓨터공학 | 02-123-4567 |
| EE | 전자공학 | 02-234-5678 |

**개선:**
- 학과 정보 중복 제거
- 학과 정보 변경 시 한 곳만 수정
- 데이터 일관성 보장

---

### 정규화 단계 요약

| 정규형 | 조건 | 제거 대상 |
|-------|------|----------|
| **1NF** | 원자값만 저장 | 다중값 속성 |
| **2NF** | 1NF + 부분 종속 제거 | 복합키의 일부에만 종속 |
| **3NF** | 2NF + 이행 종속 제거 | 일반 속성 간 종속 |
| **BCNF** | 3NF + 모든 결정자가 후보키 | 특수한 종속 관계 |
| **4NF** | BCNF + 다치 종속 제거 | 독립적인 다대다 관계 |
| **5NF** | 4NF + 조인 종속 제거 | 복잡한 종속 관계 |

실무에서는 보통 **3NF까지만 진행**

---

## 정규화의 장단점

### 장점

**1. 데이터 중복 최소화**
```
저장 공간 절약
100GB → 60GB (40% 절약 가능)
```

**2. 데이터 일관성 보장**
```
학과 전화번호 변경 시:
정규화 전: 1,000개 행 수정
정규화 후: 1개 행 수정
```

**3. 이상 현상 방지**
- 수정 이상: 한 곳만 수정하면 됨
- 삽입 이상: 독립적으로 데이터 추가 가능
- 삭제 이상: 필요한 데이터만 삭제

**4. 유지보수 용이**
- 테이블 구조가 명확
- 변경 사항 적용이 쉬움

### 단점

**1. 조인 연산 증가**

**2. 조회 성능 저하**
- 여러 테이블을 조인해야 함
- 복잡한 쿼리
- 느린 응답 속도

**3. 쿼리 복잡도 증가**
- 간단한 조회도 여러 테이블 참조
- 개발 난이도 상승

---

## 반정규화 (Denormalization)

**반정규화**는 **의도적으로 정규화를 풀어서** 조회 성능을 높이는 기법

### 왜 반정규화가 필요한가?

**상황:** 쇼핑몰 주문 조회 화면

```sql
-- 정규화된 데이터베이스
SELECT 
    o.order_id,
    u.user_name,
    u.email,
    p.product_name,
    p.price,
    d.address
FROM orders o
JOIN users u ON o.user_id = u.user_id
JOIN order_items oi ON o.order_id = oi.order_id
JOIN products p ON oi.product_id = p.product_id
JOIN delivery d ON o.order_id = d.order_id;

-- 실행 시간: 2초 (5개 테이블 조인)
```

하루에 100만 번 조회된다면:
- 2초 × 1,000,000 = 2,000,000초
- 약 555시간의 DB 작업 시간

**이런 경우 반정규화를 고려**

---

## 정규화 vs 반정규화 선택 가이드

### 정규화를 선택해야 할 때

**1. 쓰기 작업이 많은 경우**
- 회원 정보 관리
- 상품 정보 관리
- 재고 관리 시스템

**2. 데이터 정합성이 중요한 경우**
- 금융 시스템
- 결제 시스템
- 회계 시스템

**3. 저장 공간이 제한적인 경우**
- 중복 최소화 필요
- 저장 비용 절감

**4. 복잡한 비즈니스 규칙이 있는 경우**
- 데이터 일관성 유지 필요
- 여러 곳의 동시 수정 방지

### 반정규화를 선택해야 할 때

**1. 읽기 작업이 압도적으로 많은 경우**
- 통계 조회 화면
- 리포트 생성
- 대시보드

**2. 조회 성능이 매우 중요한 경우**
- 실시간 검색
- 메인 페이지
- 자주 조회되는 데이터

**3. 조인이 너무 많아지는 경우**
- 5개 이상 테이블 조인
- 복잡한 쿼리로 인한 성능 저하

**4. 이력 데이터인 경우**
- 주문 이력
- 결제 이력
- 수정이 거의 없는 데이터

### 선택 기준표

| 기준 | 정규화 | 반정규화 |
|-----|-------|---------|
| **읽기:쓰기 비율** | 1:1 또는 쓰기 많음 | 읽기가 압도적 (100:1) |
| **데이터 정합성** | 매우 중요 | 약간의 불일치 허용 |
| **저장 공간** | 제한적 | 충분함 |
| **조회 성능** | 보통 허용 | 매우 중요 |
| **유지보수** | 쉬워야 함 | 복잡해도 됨 |
| **데이터 변경 빈도** | 자주 변경 | 거의 변경 없음 |

---
