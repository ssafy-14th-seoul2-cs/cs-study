# 조인 알고리즘 (Join Algorithm)

## 조인(Join)이란?

두 개 이상의 테이블을 연결해서 데이터를 가져오는 것

## 왜 조인 알고리즘이 중요한가?

같은 조인 쿼리라도 **어떤 방식으로 연결하느냐**에 따라 성능이 천차만별

데이터베이스는 상황에 맞는 최적의 조인 알고리즘을 자동으로 선택한다.

## 조인 알고리즘의 종류

데이터베이스에서 사용하는 주요 조인 알고리즘은 3가지

1. **Nested Loop Join** (중첩 루프 조인)
2. **Hash Join** (해시 조인)
3. **Sort Merge Join** (정렬 병합 조인)

---

## 1. Nested Loop Join (중첩 루프 조인)

### 작동 방식

**이중 반복문**처럼 동작한다.

```
외부 테이블의 각 행에 대해:
    내부 테이블의 모든 행을 확인:
        조건이 맞으면 결과에 추가
```

### 구체적인 예시

**Outer Table (외부 테이블) - users**
| user_id | name |
|---------|------|
| 1 | 김철수 |
| 2 | 이영희 |

**Inner Table (내부 테이블) - orders**
| order_id | user_id | product |
|----------|---------|---------|
| 101 | 1 | 노트북 |
| 102 | 2 | 마우스 |
| 103 | 1 | 키보드 |
| 104 | 3 | 모니터 |

**실행 과정:**

1. 첫 번째 유저(김철수, id=1)를 선택
   - orders 테이블 전체 확인
   - user_id=1인 주문 찾음: 노트북, 키보드

2. 두 번째 유저(이영희, id=2)를 선택
   - orders 테이블 전체 확인
   - user_id=2인 주문 찾음: 마우스

**비교 횟수:** 2명 × 4개 주문 = 8번 비교

### 장점

- **간단하고 직관적**
- **인덱스가 있으면 매우 빠름**
- 메모리를 적게 사용
- 작은 결과를 빠르게 반환 (First Row Fast)

### 단점

- **인덱스가 없으면 매우 느림**
- 외부 테이블이 크면 성능 저하
- 최악의 경우: O(N × M) 시간 복잡도

### 언제 사용하나?

- **한쪽 테이블이 작을 때**
- **조인 컬럼에 인덱스가 있을 때**
- 결과를 빠르게 일부만 보고 싶을 때

---

## 2. Hash Join (해시 조인)

### 작동 방식

**해시 테이블**을 만들어서 빠르게 매칭한다.

```
1단계: 작은 테이블로 해시 테이블 생성
2단계: 큰 테이블을 읽으면서 해시 테이블에서 매칭되는 데이터 찾기
```

### 구체적인 예시

**1단계: Build Phase (해시 테이블 생성)**

users 테이블로 해시 테이블 생성:

```
해시 테이블 {
    1: {user_id: 1, name: "김철수"}
    2: {user_id: 2, name: "이영희"}
    3: {user_id: 3, name: "박민수"}
}
```

**2단계: Probe Phase (탐색)**

orders 테이블을 읽으면서 해시 테이블에서 찾기:

```
주문 101: user_id=1 → 해시 테이블[1] 찾기 → "김철수" 매칭
주문 102: user_id=2 → 해시 테이블[2] 찾기 → "이영희" 매칭
주문 103: user_id=1 → 해시 테이블[1] 찾기 → "김철수" 매칭
```

**비교 횟수:** 각 주문당 1번의 해시 조회 = 매우 빠름

### 해시 조인의 핵심: 해시 함수

**해시 함수**는 값을 받아서 고유한 위치(주소)를 계산한다.

```
해시 함수(1) → 위치 A
해시 함수(2) → 위치 B
해시 함수(3) → 위치 C
```

### 장점

- **대용량 데이터 조인에 효과적**
- **인덱스가 없어도 빠름**
- 시간 복잡도: O(N + M) - 선형 시간
- 등호 조인(=)에 최적화

### 단점

- **메모리를 많이 사용** (해시 테이블 생성)
- 메모리가 부족하면 디스크를 사용 (느려짐)
- 등호 조인(=)만 가능 (부등호 불가)
- 결과를 한 번에 처리

### 언제 사용하나?

- **두 테이블 모두 클 때**
- **인덱스가 없을 때**
- 등호 조건 조인(=)일 때
- 충분한 메모리가 있을 때

---

## 3. Sort Merge Join (정렬 병합 조인)

### 작동 방식

**두 테이블을 정렬한 후 병합**한다.

```
1단계: 두 테이블을 조인 컬럼 기준으로 정렬
2단계: 정렬된 두 테이블을 동시에 스캔하며 매칭
```

### 구체적인 예시

**1단계: Sort (정렬)**

users 테이블 정렬:
| user_id | name |
|---------|------|
| 1 | 김철수 |
| 2 | 이영희 |
| 3 | 박민수 |

orders 테이블 정렬:
| order_id | user_id | product |
|----------|---------|---------|
| 101 | 1 | 노트북 |
| 103 | 1 | 키보드 |
| 102 | 2 | 마우스 |
| 104 | 3 | 모니터 |

**2단계: Merge (병합)**

두 테이블을 동시에 읽으면서 매칭:

```
users 포인터 → user_id=1
orders 포인터 → order_id=101, user_id=1
→ 매칭! (김철수-노트북)

orders 포인터 이동 → order_id=103, user_id=1
→ 매칭! (김철수-키보드)

orders 포인터 이동 → order_id=102, user_id=2
users 포인터 이동 → user_id=2
→ 매칭! (이영희-마우스)
```

### 병합이 빠른 이유

정렬되어 있으므로:
- 각 테이블을 **한 번씩만** 읽음
- 되돌아갈 필요가 없음
- 이미 지나간 데이터는 다시 안 봄

### 장점

- **이미 정렬된 데이터라면 매우 빠름**
- 메모리 사용량이 적음
- 등호, 부등호 모두 가능 (>, <, >=, <=)
- 대용량 데이터 처리 가능

### 단점

- **정렬 비용이 큼**
- 정렬되지 않은 데이터라면 느림
- 등호 조인이 아닐 때는 비효율적

### 언제 사용하나?

- **데이터가 이미 정렬되어 있을 때**
- 조인 컬럼에 인덱스가 있을 때 (B-Tree는 정렬됨)
- ORDER BY가 필요한 경우
- 부등호 조인이 필요할 때

---

## 조인 알고리즘 비교

### 성능 비교표

| 구분 | Nested Loop | Hash Join | Sort Merge |
|-----|------------|-----------|------------|
| **시간 복잡도** | O(N × M) | O(N + M) | O(N log N + M log M) |
| **메모리 사용** | 적음 | 많음 | 중간 |
| **인덱스 필요** | 권장 | 불필요 | 선택적 |
| **소량 데이터** | 최고 | 보통 | 보통 |
| **대량 데이터** | 느림 | 빠름 | 빠름 |
| **부등호 조인** | 가능 | 불가 | 가능 |

### 언제 어떤 알고리즘을 사용할까?

**Nested Loop Join**
- 한쪽 테이블이 작음 (수백~수천 건)
- 조인 컬럼에 인덱스 존재
- 결과를 빠르게 일부만 필요
- 예: 특정 사용자의 주문 조회

**Hash Join**
- 두 테이블 모두 큼 (수만 건 이상)
- 인덱스 없음
- 등호 조인 (=)
- 메모리 충분
- 예: 전체 사용자-주문 통계

**Sort Merge Join**
- 데이터가 이미 정렬됨
- 부등호 조인 필요
- ORDER BY 필요
- 예: 날짜 범위 조인

---
