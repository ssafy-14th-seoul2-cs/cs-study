## 분산 DB란?

데이터를 여러 물리적 위치에 나눠서 저장하는 데이터베이스 시스템
- 네트워크로 연결된 여러 컴퓨터에 데이터가 분산되어 있음
- 사용자 입장에서는 하나의 DB처럼 보임 (투명성)

## 왜 쓰는가?

### 장점
- **확장성**: 서버 추가로 성능 향상 가능
- **가용성**: 한 노드 죽어도 다른 노드에서 서비스 가능
- **성능**: 데이터를 지리적으로 가까운 곳에 두면 빠름
- **부하 분산**: 트래픽을 여러 서버로 분산

### 단점
- 복잡함 (설계, 운영, 디버깅 모두)
- 네트워크 지연 문제
- 데이터 일관성 유지 어려움
- 비용 증가

## 핵심 개념들

### 1. 파티셔닝 (Partitioning)

데이터를 나누는 방법

#### 수평 파티셔닝 (Horizontal / Sharding)
- 행 단위로 나눔
- 예: user_id 1~1000은 서버A, 1001~2000은 서버B
- 종류:
  - **Range-based**: 범위로 나눔 (1~100, 101~200...)
  - **Hash-based**: 해시 함수로 분배 (user_id % 3)
  - **List-based**: 특정 값 기준 (지역별로 분리)

#### 수직 파티셔닝 (Vertical)
- 열 단위로 나눔
- 예: User 테이블을 기본정보/상세정보로 분리
- 테이블을 기능별로 분리할 때 유용

### 2. 복제 (Replication)

같은 데이터를 여러 곳에 복사

#### Master-Slave (Primary-Replica)
- Master: 쓰기 전담
- Slave: 읽기 전담 (Master 데이터 복제)
- 읽기 부하 분산에 좋음
- Master 죽으면 문제 (Slave를 Master로 승격시켜야 함)

#### Multi-Master
- 여러 노드에서 쓰기 가능
- 충돌 해결이 복잡함
- 쓰기 부하도 분산 가능

#### 동기 vs 비동기 복제
- **동기**: Master 쓰기 후 Slave 복제 완료까지 대기 (느리지만 일관성 보장)
- **비동기**: Master만 쓰고 바로 응답 (빠르지만 Slave 지연 있음)

### 3. CAP 정리

분산 시스템에서 3가지 중 2개만 동시에 만족 가능

- **C (Consistency)**: 모든 노드가 같은 데이터를 봄
- **A (Availability)**: 모든 요청이 응답을 받음
- **P (Partition Tolerance)**: 네트워크 장애 시에도 동작

현실적으로 P는 필수라서 C와 A 중 선택
- **CP 시스템**: 일관성 우선 (HBase, MongoDB)
- **AP 시스템**: 가용성 우선 (Cassandra, DynamoDB)

### 4. 일관성 모델

#### Strong Consistency
- 쓰기 후 즉시 모든 노드에서 최신 데이터 읽기 가능
- 느리지만 정확함

#### Eventual Consistency
- 쓰기 후 "언젠가"는 모든 노드가 같아짐
- 빠르지만 잠시 다른 데이터 읽을 수 있음

#### Causal Consistency
- 인과관계가 있는 연산은 순서 보장
- 관계 없는 건 순서 상관없음

### 5. 분산 트랜잭션

여러 노드에 걸친 트랜잭션 처리

#### 2PC (Two-Phase Commit)
1. Prepare Phase: 모든 노드에게 커밋 가능한지 물어봄
2. Commit Phase: 모두 OK면 커밋, 하나라도 NO면 롤백

문제: Coordinator 죽으면 블로킹

#### 3PC (Three-Phase Commit)
2PC 개선 버전, 타임아웃 추가

#### Saga Pattern
긴 트랜잭션을 여러 작은 트랜잭션으로 나눔
- 각 단계마다 보상 트랜잭션(Compensating Transaction) 정의
- 실패 시 이전 단계들 롤백

### 6. 분산 합의 알고리즘

여러 노드가 하나의 값에 합의하는 방법

#### Paxos
- 이론적으로 완벽하지만 이해/구현 어려움
- 3단계: Prepare, Promise, Accept

#### Raft
- Paxos보다 이해하기 쉬움
- Leader Election + Log Replication
- etcd, Consul에서 사용

## 샤딩 전략

### Key-based Sharding
- 샤드 키 선택이 중요 (user_id, order_id 등)
- 고려사항:
  - 데이터가 고르게 분산되는가?
  - 핫스팟 생기지 않는가?
  - 조인 연산이 많지 않은가?

### Range Sharding
- 순서가 있는 데이터에 유용
- 특정 샤드에 부하 몰릴 수 있음

### Hash Sharding
- 데이터 균등 분배
- 범위 쿼리 어려움
- Consistent Hashing으로 샤드 추가/제거 시 재분배 최소화

## 실제 사용 시 고려사항

### 1. 샤드 리밸런싱
- 샤드 추가/제거 시 데이터 이동
- 서비스 중단 없이 어떻게 할 것인가?

### 2. 핫스팟 문제
- 특정 샤드에 트래픽 집중
- 샤드 키 재설계 또는 더 세밀하게 분할

### 3. 분산 조인
- 여러 샤드에 걸친 조인은 매우 느림
- 가능하면 비정규화해서 조인 최소화
- 또는 애플리케이션 레벨에서 처리

### 4. 글로벌 유니크 ID
- 여러 샤드에서 ID 중복 방지
- UUID, Snowflake ID 같은 방식 사용

### 5. 백업과 복구
- 각 샤드별 백업 필요
- 특정 시점으로 전체 복구 어려움

## 주의할 점

1. **처음부터 분산하지 말 것**
   - 단일 DB로 버틸 수 있으면 그게 낫다
   - 복잡도가 급격히 증가함

2. **Read Replica부터 시작**
   - 읽기 부하만 있다면 Master-Slave로 충분

3. **샤딩은 최후의 수단**
   - 캐싱, 인덱스 최적화, 쿼리 튜닝부터

4. **모니터링 필수**
   - 각 노드 상태, 복제 지연, 샤드 불균형 등
   - 장애 발견 및 대응 자동화