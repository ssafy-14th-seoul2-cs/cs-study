# NoSQL 정리

## NoSQL이란?

Not Only SQL의 약자
- SQL(관계형 DB)이 아닌 방식으로 데이터 저장
- 비관계형 데이터베이스
- 테이블/행/열 같은 고정된 구조 없이 자유롭게 저장

## 왜 등장했나?

관계형 DB로는 해결하기 어려운 문제들
- 엄청난 트래픽 감당 어려움 (트위터, 페이스북 같은 서비스)
- 테이블 구조 변경이 너무 번거로움
- 서버 추가해서 확장하기 어려움
- 조인 연산이 느림

NoSQL은 이런 걸 해결하려고 나옴
- 수평 확장 쉽게 (서버 추가로 성능 향상)
- 스키마 자유롭게 변경 가능
- 빠른 읽기/쓰기

## NoSQL 주요 특징

### 1. 유연한 스키마
- 미리 테이블 구조 정의 안 해도 됨
- 데이터마다 다른 필드 가질 수 있음
- 나중에 필드 추가/삭제 자유로움

예: 사용자 데이터
- A 사용자: 이름, 이메일만
- B 사용자: 이름, 이메일, 전화번호, 주소까지
→ 둘 다 같은 저장소에 넣을 수 있음

### 2. 수평 확장 쉬움
- 서버 추가하면 자동으로 데이터 분산
- 샤딩이 기본적으로 내장되어 있음
- 관계형 DB처럼 복잡한 설정 필요 없음

### 3. 빠른 속도
- 조인 없이 한 번에 데이터 가져옴
- 캐싱 기능 내장된 경우 많음
- 분산되어 있어서 병렬 처리

### 4. 높은 가용성
- 데이터를 여러 서버에 자동 복제
- 한 서버 죽어도 다른 곳에서 계속 서비스

### 5. 최종 일관성 (Eventual Consistency)
- 데이터 쓰고 바로 읽으면 옛날 데이터 나올 수 있음
- 시간 지나면 결국 모든 서버가 같은 데이터 갖게 됨
- 속도와 가용성을 위해 일관성 약간 포기

## NoSQL 4가지 타입

### 1. Key-Value Store (키-값 저장소)

가장 단순한 형태, 키로 값을 저장하고 꺼냄

```
user:1 → "홍길동"
user:2 → "김철수"
cart:123 → "상품1, 상품2, 상품3"
```

**특징**
- 엄청 빠름 (거의 즉시 조회)
- 구조가 제일 단순함
- 키로만 검색 가능 (내용으로는 검색 안 됨)

**어디에 쓰나?**
- 로그인 세션 저장
- 캐싱 (자주 쓰는 데이터 임시 저장)
- 장바구니
- 실시간 게임 순위

**대표 제품**
- Redis (제일 유명, 빠름)
- Memcached (캐싱 전문)
- DynamoDB (AWS에서 제공)

### 2. Document Store (문서 저장소)

JSON 형태로 데이터 저장, 중첩 구조 가능

```
{
  "사용자ID": "user123",
  "이름": "홍길동",
  "이메일": "hong@example.com",
  "주문내역": [
    {
      "주문번호": "order1",
      "금액": 50000,
      "상품": ["상품1", "상품2"]
    }
  ],
  "주소": {
    "도시": "서울",
    "우편번호": "12345"
  }
}
```

**특징**
- 관련 데이터를 한 문서에 다 넣을 수 있음
- 조인 없이 한 번에 다 가져옴
- 문서 안에서 특정 필드로 검색 가능
- 스키마 자유로움

**어디에 쓰나?**
- 사용자 프로필
- 상품 정보
- 블로그 글
- 설정 파일

**대표 제품**
- MongoDB (제일 많이 씀)
- CouchDB
- Couchbase

### 3. Column-Family Store (컬럼 패밀리 저장소)

열 기준으로 데이터 저장, 행마다 다른 컬럼 가질 수 있음

```
사용자1:
  기본정보: 이름="홍길동", 이메일="hong@example.com"
  통계: 로그인횟수=100, 마지막로그인="2024-01-15"

사용자2:
  기본정보: 이름="김철수", 전화번호="010-1234-5678"  ← 다른 컬럼
  통계: 로그인횟수=50
```

**특징**
- 각 행마다 가지고 있는 컬럼이 달라도 됨
- 대량 데이터 쓰기에 강함
- 시계열 데이터에 적합

**어디에 쓰나?**
- 로그 저장 (엄청 많은 로그 기록)
- 센서 데이터 (IoT)
- 시계열 데이터 (주식 가격 변화 등)
- 이벤트 추적

**대표 제품**
- Cassandra (대용량 쓰기에 강함)
- HBase (하둡 생태계)
- ScyllaDB

### 4. Graph Database (그래프 데이터베이스)

데이터 간 관계를 그래프(점과 선)로 표현

```
홍길동 --[친구]--> 김철수
홍길동 --[근무]--> 회사A
김철수 --[근무]--> 회사A
홍길동 --[좋아함]--> 영화1
김철수 --[좋아함]--> 영화1
```

**특징**
- 관계를 찾는 게 핵심
- N단계 떨어진 관계도 빠르게 찾음
- 조인 없이 관계 탐색

**어디에 쓰나?**
- 소셜 네트워크 (친구의 친구 찾기)
- 추천 시스템 (비슷한 취향 사람 찾기)
- 사기 탐지 (연관된 계좌 찾기)
- 조직도, 가계도

**대표 제품**
- Neo4j (제일 유명)
- Amazon Neptune (AWS)
- ArangoDB

## NoSQL vs 관계형 DB 비교

| 구분 | 관계형 DB (MySQL, PostgreSQL) | NoSQL |
|------|-------------------------------|-------|
| 데이터 구조 | 테이블 (고정된 행/열) | 자유로움 (JSON, Key-Value 등) |
| 스키마 | 미리 정의 필수 | 정의 안 해도 됨 |
| 확장 | 서버 성능 높이기 (수직) | 서버 추가하기 (수평) |
| 데이터 관계 | 외래키, 조인으로 연결 | 문서 안에 다 넣거나 느슨하게 연결 |
| 트랜잭션 | 강력함 (ACID) | 약함 (BASE) |
| 속도 | 복잡한 쿼리 가능하지만 느릴 수 있음 | 단순 쿼리 매우 빠름 |
| 일관성 | 항상 최신 데이터 | 잠시 옛날 데이터 볼 수 있음 |
| 사용처 | 은행, 회계 등 정확성 필수 | SNS, 로그, 실시간 서비스 |

## ACID vs BASE

### ACID (관계형 DB의 원칙)
관계형 DB가 트랜잭션 처리할 때 지키는 4가지 원칙

- **Atomicity (원자성)**: 전부 성공 아니면 전부 실패
  - 송금 시 A계좌 출금 + B계좌 입금이 둘 다 성공하거나 둘 다 실패
  
- **Consistency (일관성)**: 항상 유효한 상태 유지
  - 잔액이 마이너스 되면 안 됨 같은 규칙 항상 지킴
  
- **Isolation (격리성)**: 동시 실행해도 서로 영향 없음
  - 두 사람이 동시에 송금해도 꼬이지 않음
  
- **Durability (지속성)**: 한번 저장되면 영구 보존
  - 커밋 후 정전 나도 데이터 안 사라짐

### BASE (NoSQL의 원칙)
NoSQL이 속도와 확장성을 위해 선택한 느슨한 원칙

- **Basically Available (기본적 가용성)**: 웬만하면 항상 응답함
  - 완벽한 데이터가 아니어도 일단 응답
  
- **Soft state (유연한 상태)**: 상태가 시간에 따라 변할 수 있음
  - 지금 본 데이터랑 1초 뒤 본 데이터가 다를 수 있음
  
- **Eventual consistency (최종 일관성)**: 결국에는 일치함
  - 지금 당장은 서버마다 다른 값이지만 시간 지나면 같아짐

**쉽게 비유하면**
- ACID: 은행 계좌 (정확해야 함, 느려도 괜찮음)
- BASE: 인스타 좋아요 개수 (대충 맞으면 됨, 빨라야 함)

## 언제 어떤 NoSQL 쓸까?

### Key-Value
- 매우 빠른 조회가 필요할 때
- 데이터 구조가 단순할 때
- 캐싱, 세션 저장
- 예: Redis로 로그인 세션 관리

### Document
- 데이터 구조가 자주 바뀔 때
- 관련된 정보를 한 덩어리로 저장하고 싶을 때
- 조인 없이 데이터 가져오고 싶을 때
- 예: MongoDB로 상품 정보 저장 (이름, 가격, 설명, 리뷰 등 한 문서에)

### Column-Family
- 엄청 많은 데이터를 빠르게 쓸 때
- 시간 순서대로 쌓이는 데이터
- 로그나 센서 데이터
- 예: Cassandra로 웹사이트 접속 로그 저장

### Graph
- 관계가 중요한 데이터
- N단계 연결 찾기
- 추천이나 관계 분석
- 예: Neo4j로 친구 추천 시스템

## NoSQL 단점

### 1. 트랜잭션 약함
- 여러 문서나 레코드에 걸친 작업 보장 어려움
- A계좌 출금하고 B계좌 입금 같은 건 위험
- 최근에는 일부 지원하긴 함 (MongoDB 등)

### 2. 복잡한 쿼리 어려움
- 조인 같은 거 못 함
- "30대 남성 중 서울 거주자이면서 최근 1년간 구매 이력 있는 사람" 같은 복잡한 조건 검색 힘듦
- 애플리케이션에서 직접 처리해야 함

### 3. 일관성 문제
- 방금 저장한 데이터를 바로 못 읽을 수 있음
- 서버마다 다른 값 볼 수 있음
- 금융 같은 곳에서는 치명적

### 4. 표준이 없음
- MongoDB, Cassandra, Redis 전부 사용법 다름
- 배우기도 어렵고 다른 DB로 바꾸기도 어려움
- SQL처럼 표준 쿼리 언어 없음

### 5. 운영 경험 부족
- 관계형 DB만큼 자료나 전문가가 많지 않음
- 문제 생겼을 때 해결하기 어려울 수 있음
