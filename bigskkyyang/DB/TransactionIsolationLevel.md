# 트랜잭션 격리 수준 (Transaction Isolation Level)

## 트랜잭션이란?

데이터베이스에서 **트랜잭션**은 하나의 작업 단위를 의미한다. 

예를 들어, 은행에서 계좌이체를 할 때:
1. A 계좌에서 돈을 빼고
2. B 계좌에 돈을 넣는다

이 두 가지 작업은 함께 성공하거나, 함께 실패해야 한다. 이렇게 **모두 성공하거나 모두 실패해야 하는 작업의 묶음**이 트랜잭션.

## 격리 수준이 왜 필요한가?

데이터베이스는 여러 사용자가 동시에 사용한다. 만약 두 명이 동시에 같은 데이터를 수정하려고 하면?

**예시 상황:**
- 철수와 영희가 동시에 같은 상품의 재고를 확인
- 둘 다 "재고 10개"를 봄
- 철수가 5개 구매
- 영희도 5개 구매
- 결과: 재고는 0개가 되어야 하는데, 각자 계산하다 보니 문제 발생 가능

이런 문제를 방지하기 위해 **격리 수준**이라는 개념이 필요

## 격리 수준의 종류

격리 수준은 **낮은 단계부터 높은 단계까지** 4가지가 있다. 단계가 높을수록 데이터 정합성은 좋아지지만, 성능은 떨어짐

### 1. READ UNCOMMITTED (레벨 0)

**가장 낮은 격리 수준**

- 다른 트랜잭션이 아직 커밋하지 않은 데이터도 읽을 수 있다
- **Dirty Read** 문제가 발생할 수 있다

**Dirty Read란?**
- 철수가 상품 가격을 10,000원에서 20,000원으로 변경 중
- 아직 저장(커밋)은 안 했는데, 영희가 20,000원을 봄
- 철수가 작업을 취소(롤백)함
- 영희는 존재하지 않는 가격 정보를 본 것

**실무에서 거의 사용하지 않음**

### 2. READ COMMITTED (레벨 1)

**가장 많이 사용되는 격리 수준**

- 커밋된 데이터만 읽을 수 있습니다
- Dirty Read 문제는 해결됩니다
- **Non-Repeatable Read** 문제가 발생할 수 있습니다

**Non-Repeatable Read란?**
- 철수가 상품 가격을 조회: 10,000원
- 영희가 상품 가격을 15,000원으로 변경하고 저장
- 철수가 같은 상품 가격을 다시 조회: 15,000원
- 같은 트랜잭션 안에서 같은 데이터를 읽었는데 결과가 다름

**Oracle, PostgreSQL의 기본 설정**

### 3. REPEATABLE READ (레벨 2)

**트랜잭션 내에서 같은 데이터는 항상 같은 결과**

- 트랜잭션이 시작된 시점의 데이터를 계속 보여줍니다
- Non-Repeatable Read 문제는 해결됩니다
- **Phantom Read** 문제가 발생할 수 있습니다

**Phantom Read란?**
- 철수가 "20대 회원" 조회: 5명
- 영희가 20대 회원 1명 추가하고 저장
- 철수가 "20대 회원" 다시 조회: 6명 (새로운 행이 나타남)

**MySQL(InnoDB)의 기본 설정**

참고: MySQL InnoDB는 Next-Key Lock을 사용해서 Phantom Read도 대부분 방지합니다.

### 4. SERIALIZABLE (레벨 3)

**가장 높은 격리 수준**

- 트랜잭션을 순차적으로 실행하는 것과 같은 효과
- 모든 문제(Dirty Read, Non-Repeatable Read, Phantom Read)가 해결됩니다
- **성능이 매우 떨어집니다**

한 트랜잭션이 사용하는 데이터는 다른 트랜잭션이 접근할 수 없습니다. 마치 줄을 서서 한 명씩 사용하는 것과 같습니다.

## 격리 수준 비교표

| 격리 수준 | Dirty Read | Non-Repeatable Read | Phantom Read | 성능 |
|---------|-----------|-------------------|-------------|-----|
| READ UNCOMMITTED | 발생 | 발생 | 발생 | 가장 빠름 |
| READ COMMITTED | 방지 | 발생 | 발생 | 빠름 |
| REPEATABLE READ | 방지 | 방지 | 발생 | 보통 |
| SERIALIZABLE | 방지 | 방지 | 방지 | 느림 |
