# DB Lock & 동시성 제어

## Lock이 필요한 이유

여러 사용자가 동시에 같은 데이터를 수정하려고 하면 문제 발생

**예시 상황: 좌석 예매**
```
시간 순서:
1. 철수가 A좌석 조회 → 빈 좌석
2. 영희가 A좌석 조회 → 빈 좌석
3. 철수가 A좌석 예매
4. 영희가 A좌석 예매
결과: 한 좌석에 두 명이 예매됨 (문제!)
```

이런 문제를 방지하기 위해 Lock이 필요함

## Lock의 기본 개념

**Lock**: 데이터에 대한 접근을 제어하는 메커니즘

- 누군가 데이터를 사용 중이면 다른 사람은 대기
- 마치 화장실 문고리와 같음
- 사용 중이면 잠금, 다 쓰면 해제

## Lock의 종류

### 1. Shared Lock (공유 락, S Lock)

**읽기 작업에 사용**

특징:
- 여러 트랜잭션이 동시에 읽기 가능
- 읽는 동안 다른 사람도 읽을 수 있음
- 단, 쓰기는 불가능 (기다려야 함)

비유: 박물관 작품
- 여러 명이 동시에 구경 가능
- 단, 작품을 옮기려면 관람객이 없을 때만 가능

### 2. Exclusive Lock (배타 락, X Lock)

**쓰기 작업에 사용**

특징:
- 하나의 트랜잭션만 독점적으로 사용
- 다른 사람은 읽기도, 쓰기도 불가
- 작업이 끝나야 다른 사람 접근 가능

비유: 편집 중인 문서
- 한 명만 수정 가능
- 다른 사람은 보기도 못함 (대기)

### Lock 호환성 표

|  | S Lock | X Lock |
|--|--------|--------|
| **S Lock** | O (가능) | X (대기) |
| **X Lock** | X (대기) | X (대기) |

- S Lock + S Lock = 동시 진행 가능
- S Lock + X Lock = 한쪽 대기
- X Lock + X Lock = 한쪽 대기

## Lock의 범위 (Granularity)

### 1. Row-Level Lock (행 단위 락)

**특정 행만 잠금**

장점:
- 동시성이 높음 (다른 행은 접근 가능)
- 여러 트랜잭션이 동시에 다른 행 처리 가능

단점:
- Lock 관리 오버헤드 증가
- 많은 행을 잠그면 비효율적

사용 예시:
- 특정 사용자 정보 수정
- 특정 주문 건 업데이트

### 2. Table-Level Lock (테이블 단위 락)

**테이블 전체 잠금**

장점:
- Lock 관리가 간단
- 오버헤드 적음

단점:
- 동시성 낮음
- 한 명이 작업 중이면 전체 테이블 대기

사용 예시:
- 테이블 구조 변경
- 대량 데이터 작업

### 3. Page-Level Lock (페이지 단위 락)

**데이터 페이지 단위 잠금**

- Row와 Table의 중간
- 여러 행을 포함하는 페이지 단위
- 균형잡힌 접근

### 4. Database-Level Lock

**데이터베이스 전체 잠금**

- 백업, 복구 작업 시 사용
- 일반적인 작업에는 거의 사용 안 함

## 동시성 제어 기법

### 1. Optimistic Locking (낙관적 락)

**"충돌이 거의 없을 것"이라고 가정**

동작 방식:
1. 데이터를 읽을 때 Lock 안 걸음
2. 데이터를 수정할 때만 체크
3. 버전 번호나 타임스탬프로 확인
4. 다른 사람이 수정했으면 에러 발생

장점:
- Lock 오버헤드 없음
- 읽기 성능 좋음
- 동시성 높음

단점:
- 충돌 시 재시도 필요
- 충돌이 많으면 비효율적

적합한 경우:
- 읽기가 많고 쓰기가 적은 경우
- 충돌 가능성이 낮은 경우
- 예: 게시글 조회수, 위키 편집

### 2. Pessimistic Locking (비관적 락)

**"충돌이 발생할 것"이라고 가정**

동작 방식:
1. 데이터를 읽는 순간 Lock 걸음
2. 작업이 끝날 때까지 Lock 유지
3. 다른 사람은 대기
4. 작업 끝나면 Lock 해제

장점:
- 데이터 정합성 보장
- 충돌 발생 안 함
- 예측 가능한 동작

단점:
- Lock 대기 시간 발생
- 동시성 낮음
- 데드락 가능성

적합한 경우:
- 충돌이 자주 발생하는 경우
- 데이터 정합성이 매우 중요한 경우
- 예: 재고 관리, 좌석 예매, 금융 거래

## 데드락 (Deadlock)

### 데드락이란?

**두 개 이상의 트랜잭션이 서로의 Lock을 기다리며 무한 대기**

예시 상황:
```
트랜잭션 A:
1. 계좌 A에 Lock
2. 계좌 B의 Lock 대기 중

트랜잭션 B:
1. 계좌 B에 Lock
2. 계좌 A의 Lock 대기 중

결과: 서로 영원히 대기 (데드락)
```

비유: 좁은 골목에서 마주친 두 차
- 앞으로도 못 가고
- 뒤로도 못 가고
- 한쪽이 양보해야 해결

### 데드락 발생 조건 (4가지 모두 충족 시)

1. **상호 배제**: 자원을 한 번에 한 프로세스만 사용
2. **점유와 대기**: 자원을 가진 채로 다른 자원 대기
3. **비선점**: 다른 프로세스의 자원을 강제로 빼앗을 수 없음
4. **순환 대기**: 대기 관계가 원형으로 연결

### 데드락 해결 방법

**1. 예방 (Prevention)**
- 4가지 조건 중 하나를 원천 차단
- 자원 획득 순서를 정함
- 예: 항상 계좌 번호 순서대로 Lock

**2. 회피 (Avoidance)**
- 안전한 상태를 유지하도록 자원 할당
- 데드락 가능성 있으면 대기

**3. 탐지 및 복구 (Detection & Recovery)**
- 주기적으로 데드락 검사
- 발견 시 하나의 트랜잭션 롤백
- DB가 자동으로 처리하는 경우 많음

**4. 무시**
- 데드락이 거의 안 일어나면 무시
- 발생 시 사용자가 재시도

### 데드락 방지 전략

**자원 획득 순서 정하기**
```
나쁜 예:
트랜잭션 A: X 잠금 → Y 잠금
트랜잭션 B: Y 잠금 → X 잠금

좋은 예:
트랜잭션 A: X 잠금 → Y 잠금
트랜잭션 B: X 잠금 → Y 잠금
(항상 같은 순서)
```

**타임아웃 설정**
- 일정 시간 내에 Lock 못 얻으면 포기
- 자동 롤백 후 재시도

**Lock 범위 최소화**
- 필요한 부분만 Lock
- Lock 유지 시간 줄이기

## 2단계 락킹 프로토콜 (2PL)

### 기본 개념

**트랜잭션을 Growing Phase와 Shrinking Phase로 구분**

**Growing Phase (확장 단계)**
- Lock만 획득 가능
- Lock 해제 불가
- 필요한 모든 Lock 획득

**Shrinking Phase (축소 단계)**
- Lock만 해제 가능
- 새로운 Lock 획득 불가
- 모든 Lock 해제

규칙: Lock을 하나라도 해제하면 더 이상 새로운 Lock 획득 불가

### 2PL의 장점

- 직렬성 보장 (Serializability)
- 데이터 일관성 유지
- 동시성 제어의 기본 프로토콜

### 2PL의 단점

- 데드락 발생 가능
- Lock 대기 시간 증가
- 동시성 저하

### 2PL의 종류

**1. Basic 2PL**
- 기본 2단계 락킹
- 데드락 가능

**2. Conservative 2PL**
- 시작 전에 모든 Lock 획득
- 데드락 없음
- 동시성 낮음

**3. Strict 2PL**
- 트랜잭션 끝날 때까지 X Lock 유지
- 연쇄 롤백 방지
- 가장 많이 사용

**4. Rigorous 2PL**
- 모든 Lock을 끝까지 유지
- 가장 엄격
- 동시성 가장 낮음

## MVCC (Multi-Version Concurrency Control)

### 기본 개념

**데이터의 여러 버전을 유지해서 동시성 향상**

특징:
- 읽기와 쓰기가 서로 블로킹 안 함
- 각 트랜잭션은 자신의 시점 데이터를 봄
- Lock 없이 읽기 가능

### 동작 방식

```
원본 데이터: version 1
트랜잭션 A가 수정 시작 → version 2 생성
트랜잭션 B가 읽기 → version 1 읽음 (블로킹 없음)
트랜잭션 A 커밋 → version 2가 최신이 됨
```

- 각 데이터에 버전 번호나 타임스탬프 저장
- 트랜잭션은 적절한 버전 읽음
- 최신 버전으로 쓰기

### MVCC의 장점

- 읽기 성능 매우 좋음
- Lock 대기 시간 없음
- 높은 동시성

### MVCC의 단점

- 저장 공간 추가 필요 (여러 버전 보관)
- 오래된 버전 정리 필요 (Vacuum)
- 복잡한 구현

### 주요 DB의 MVCC

- PostgreSQL: MVCC 사용
- MySQL InnoDB: MVCC 사용
- Oracle: MVCC 방식 사용

## Lock과 트랜잭션 격리 수준

### READ UNCOMMITTED

- Lock 거의 안 씀
- Dirty Read 발생
- 사용 권장 안 함

### READ COMMITTED

- 읽을 때 S Lock 걸고 읽은 후 바로 해제
- 쓸 때만 X Lock 유지
- 가장 많이 사용

### REPEATABLE READ

- 읽은 데이터에 S Lock을 트랜잭션 끝까지 유지
- 같은 데이터 재조회 시 같은 결과 보장

### SERIALIZABLE

- 모든 Lock을 트랜잭션 끝까지 유지
- 가장 엄격한 Lock
- 성능 저하

## 실무에서의 Lock 관리

### Lock 타임아웃 설정

- 무한 대기 방지
- 일정 시간 후 자동 롤백
- 사용자에게 재시도 안내

### Lock 모니터링

주기적으로 확인해야 할 것들:
- Lock 대기 중인 트랜잭션
- 오래 실행 중인 트랜잭션
- 데드락 발생 빈도
- Lock으로 인한 성능 저하

### Lock 최적화 팁

**1. Lock 범위 최소화**
- 필요한 행만 Lock
- 테이블 전체 Lock 피하기

**2. Lock 시간 최소화**
- 트랜잭션을 짧게 유지
- 오래 걸리는 작업은 트랜잭션 밖에서

**3. 인덱스 활용**
- 인덱스 없으면 전체 테이블 Lock 가능
- 적절한 인덱스로 행 단위 Lock

**4. 일관된 순서**
- 자원 접근 순서 통일
- 데드락 방지

**5. 트랜잭션 분리**
- 긴 작업은 작게 나누기
- 읽기 전용 작업은 별도 처리

## 동시성 문제 사례

### 더블 클릭 문제

상황:
- 사용자가 결제 버튼 더블 클릭
- 두 번 결제 처리됨

해결:
- Optimistic Lock으로 버전 체크
- 애플리케이션 레벨에서 중복 방지
- 프론트엔드에서 버튼 비활성화

### 재고 감소 문제

상황:
- 남은 재고 1개
- 두 명이 동시 주문
- 재고가 -1이 됨

해결:
- Pessimistic Lock으로 재고 선점
- 재고 확인과 감소를 원자적으로 처리
- 분산 락 사용 (Redis)

### 좌석 예매 문제

상황:
- 같은 좌석에 중복 예매

해결:
- 좌석 선택 시 Pessimistic Lock
- 일정 시간 후 자동 해제 (타임아웃)
- 트랜잭션 격리 수준 상향

## 분산 환경에서의 Lock

### 문제점

- 여러 서버가 같은 DB 접근
- DB Lock만으로는 부족한 경우
- 애플리케이션 레벨 동시성 제어 필요

### 해결 방법

**1. Redis 분산 락**
- Redis의 SETNX 명령 활용
- 여러 서버 간 Lock 공유
- 타임아웃 설정 필수

**2. Zookeeper**
- 분산 코디네이션 서비스
- 락 관리 전용 도구

**3. 데이터베이스 행 Lock**
- 특정 행을 Lock용으로 사용
- 간단하지만 DB 부하 증가
