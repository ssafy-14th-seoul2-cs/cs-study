# 옵저버 & 퍼블리셔-서브스크라이버 패턴 정리

## 옵저버 패턴 (Observer Pattern)

### 옵저버란?

한 객체의 상태가 변하면, 그것을 지켜보던(observe) 다른 객체들에게 자동으로 알려주는 패턴
- 주체(Subject): 상태를 가진 객체, 관찰 대상
- 옵저버(Observer): 주체를 관찰하는 객체들
- 주체가 변하면 등록된 모든 옵저버에게 통지

### 왜 필요한가?

**문제 상황**
```
유튜브 채널을 운영한다고 가정

새 영상 올리면:
- 구독자 A에게 알림 보내기
- 구독자 B에게 알림 보내기
- 구독자 C에게 알림 보내기
...

구독자가 늘어날 때마다:
→ 코드 수정해서 새 구독자 추가
→ 구독자가 수백, 수천 명이면?
→ 구독 취소하면 또 코드 수정

if (새영상업로드):
    구독자A.알림()
    구독자B.알림()
    구독자C.알림()
    ... (무한히 계속)

→ 유지보수 지옥
→ 결합도 높음 (채널이 모든 구독자를 알아야 함)
```

**옵저버 패턴 사용하면**
```
채널(Subject):
- 구독자 목록 보관
- 구독자 등록/해제 메서드
- 새 영상 올리면 목록에 있는 모두에게 통지

구독자(Observer):
- 알림 받는 메서드 구현

구독자가 늘어나도 코드 수정 없음
→ 구독자.등록() 호출만 하면 됨
→ 채널은 구체적인 구독자 몰라도 됨
```

### 어디에 쓰나?

1. **이벤트 시스템**
   - 버튼 클릭 → 여러 핸들러 실행
   - GUI 프레임워크 전반

2. **알림 시스템**
   - 유튜브 구독
   - 뉴스레터 구독
   - SNS 팔로우

3. **데이터 바인딩**
   - 모델 변경 → 뷰 자동 업데이트
   - 엑셀에서 셀 값 바꾸면 차트 자동 갱신

4. **주식 시세 변동**
   - 주가 변경 → 여러 화면 동시 업데이트
   - 거래 앱, 차트, 알림 등

5. **채팅 앱**
   - 새 메시지 → 모든 참여자에게 전송
   - 채팅방 참가자들이 옵저버

### 옵저버 패턴 구조

```
상황: 뉴스 구독 시스템

Subject (주체):
- NewsAgency (뉴스 통신사)
- 옵저버 목록 관리
- 메서드:
  - subscribe(observer): 구독자 등록
  - unsubscribe(observer): 구독 취소
  - notifyObservers(): 모든 구독자에게 알림

Observer (옵저버):
- NewsSubscriber (구독자)
- 메서드:
  - update(news): 뉴스 받았을 때 실행

구체적 옵저버들:
- EmailSubscriber: 이메일로 받기
- SMSSubscriber: 문자로 받기
- AppSubscriber: 앱 알림으로 받기

동작:
1. 구독자들이 뉴스 통신사에 구독 등록
2. 뉴스 통신사에 새 뉴스 입력
3. notifyObservers() 호출
4. 모든 등록된 구독자에게 update() 호출
```

### Push vs Pull 방식

**Push 방식 (밀어주기)**
```
주체가 데이터를 옵저버에게 직접 전달
- 통지할 때 변경된 데이터도 함께 보냄
- 옵저버는 받은 데이터 사용

장점: 옵저버가 주체를 몰라도 됨
단점: 필요 없는 데이터도 받을 수 있음

예: notifyObservers(newData)
```

**Pull 방식 (가져가기)**
```
주체는 변경만 알려주고, 옵저버가 필요한 데이터를 가져감
- 통지만 받고 옵저버가 주체에게 데이터 요청

장점: 필요한 데이터만 가져감
단점: 옵저버가 주체를 알아야 함

예: notifyObservers() → 옵저버가 subject.getData() 호출
```

### 옵저버 패턴의 장점

1. **느슨한 결합**
   - 주체는 옵저버의 구체적 타입 몰라도 됨
   - 인터페이스만 알면 됨

2. **동적 관계**
   - 런타임에 옵저버 추가/제거 가능
   - 구독/구독취소 자유로움

3. **개방-폐쇄 원칙**
   - 새 옵저버 추가해도 주체 코드 수정 없음
   - 확장에는 열려있고 수정에는 닫혀있음

4. **브로드캐스트**
   - 한 번에 여러 객체에 알림
   - 일대다 관계

### 옵저버 패턴의 단점

1. **순서 보장 안 됨**
   - 옵저버들에게 알림 가는 순서가 불확실
   - 순서가 중요하면 문제

2. **예상치 못한 업데이트**
   - 옵저버가 많으면 성능 저하
   - 연쇄 업데이트로 복잡해질 수 있음

3. **메모리 누수 위험**
   - 옵저버 등록만 하고 해제 안 하면
   - 가비지 컬렉션 안 될 수 있음

4. **디버깅 어려움**
   - 간접적인 호출이라 흐름 추적 어려움
   - 누가 누구를 업데이트하는지 파악 힘듦

---

## 퍼블리셔-서브스크라이버 패턴 (Pub-Sub Pattern)

### 퍼블리셔-서브스크라이버란?

메시지를 발행(Publish)하는 쪽과 구독(Subscribe)하는 쪽을 완전히 분리한 패턴
- Publisher: 메시지 발행자
- Subscriber: 메시지 구독자
- Message Broker/Event Bus: 중간 매개자
- 발행자와 구독자가 서로를 전혀 모름

### 왜 필요한가?

**옵저버 패턴의 한계**
```
주체가 여전히 옵저버 목록을 직접 관리
→ 주체와 옵저버가 완전히 독립적이지 않음
→ 주체가 옵저버 인터페이스는 알아야 함

만약:
- 주체가 다른 시스템에 있다면?
- 네트워크로 연결된 여러 서버라면?
- 옵저버가 나중에 추가될 수 있다면?

→ 더 강한 분리가 필요
```

**Pub-Sub 패턴 사용하면**
```
중간에 메시지 브로커 추가

Publisher:
- 메시지만 발행
- 누가 받는지 몰라도 됨

Subscriber:
- 관심있는 주제(토픽) 구독
- 누가 발행하는지 몰라도 됨

Message Broker:
- 메시지 받아서 구독자들에게 전달
- Publisher와 Subscriber를 중재

완전한 분리!
```

### 어디에 쓰나?

1. **마이크로서비스**
   - 서비스 간 통신
   - 각 서비스가 독립적

2. **실시간 알림**
   - 푸시 알림 시스템
   - 여러 디바이스에 동시 전송

3. **로깅 시스템**
   - 여러 소스에서 로그 수집
   - 중앙 집중식 로깅

4. **이벤트 기반 아키텍처**
   - 주문 완료 이벤트 발행
   - 결제, 배송, 알림 서비스가 각각 구독

5. **채팅/메시징 앱**
   - 카카오톡, 슬랙
   - 메시지 서버가 브로커 역할

### Pub-Sub 패턴 구조

```
상황: 쇼핑몰 주문 시스템

Publishers (발행자들):
- OrderService: "주문완료" 이벤트 발행
- PaymentService: "결제완료" 이벤트 발행

Message Broker (중개자):
- EventBus / Message Queue
- 토픽별로 메시지 관리
- 토픽:
  - "order.completed"
  - "payment.completed"

Subscribers (구독자들):
- NotificationService: "주문완료" 구독 → 알림 발송
- ShippingService: "결제완료" 구독 → 배송 준비
- AnalyticsService: 모든 이벤트 구독 → 통계 수집

동작:
1. OrderService가 "주문완료" 이벤트 발행
2. EventBus가 "order.completed" 토픽에 메시지 등록
3. 해당 토픽 구독한 모든 서비스에게 전달
4. 각 구독자가 독립적으로 처리
```

### 토픽(Topic) 기반 vs 콘텐츠 기반

**토픽 기반**
```
특정 주제(토픽)를 구독
- "sports" 토픽
- "news" 토픽
- "weather" 토픽

간단하지만 정교한 필터링 어려움
```

**콘텐츠 기반**
```
메시지 내용으로 필터링
- "지역 = 서울 AND 카테고리 = 날씨"
- 더 유연하지만 복잡함
```

### Pub-Sub 패턴의 장점

1. **완전한 분리**
   - 발행자와 구독자가 서로 완전히 독립
   - 추가/제거가 자유로움

2. **확장성**
   - 새 발행자나 구독자 추가 쉬움
   - 기존 코드 수정 없음

3. **비동기 처리**
   - 발행자는 발행만 하고 끝
   - 구독자 처리 기다릴 필요 없음

4. **다대다 통신**
   - 여러 발행자 → 여러 구독자
   - 유연한 통신 구조

5. **시스템 분산**
   - 네트워크로 연결된 시스템 간 통신
   - 마이크로서비스 아키텍처에 적합

### Pub-Sub 패턴의 단점

1. **복잡도 증가**
   - 중간 브로커 필요
   - 인프라 관리 필요

2. **메시지 전달 보장 어려움**
   - 네트워크 문제로 메시지 손실 가능
   - 순서 보장 어려움

3. **디버깅 어려움**
   - 메시지 흐름 추적 복잡
   - 누가 어떤 토픽 구독하는지 파악 힘듦

4. **중개자 의존**
   - 브로커 장애 시 전체 시스템 영향
   - 단일 장애점(SPOF)

5. **지연 시간**
   - 직접 호출보다 느릴 수 있음
   - 브로커 거쳐가는 오버헤드

---

## 옵저버 vs Pub-Sub 비교

### 핵심 차이

| 구분 | 옵저버 패턴 | Pub-Sub 패턴 |
|------|------------|--------------|
| 결합도 | 느슨한 결합 (주체가 옵저버 알고 있음) | 완전 분리 (서로 모름) |
| 중개자 | 없음 (직접 통신) | 있음 (브로커) |
| 동기/비동기 | 보통 동기 | 보통 비동기 |
| 통신 방식 | 주체 → 옵저버 (일대다) | 발행자 → 브로커 → 구독자 (다대다) |
| 범위 | 주로 같은 프로세스 내 | 분산 시스템 가능 |
| 복잡도 | 낮음 | 높음 (브로커 관리) |
| 확장성 | 제한적 | 매우 높음 |

### 구조 차이

**옵저버 패턴**
```
Subject (주체)
  ↓ (직접 통지)
  ↓
Observer1, Observer2, Observer3

- 주체가 옵저버 목록 관리
- 직접 notify() 호출
```

**Pub-Sub 패턴**
```
Publisher1, Publisher2
  ↓
  ↓ (메시지 발행)
  ↓
Message Broker (중개자)
  ↓
  ↓ (메시지 전달)
  ↓
Subscriber1, Subscriber2, Subscriber3

- 브로커가 중재
- 발행자와 구독자 분리
```

### 선택 기준

**옵저버 패턴을 쓸 때**
- 같은 애플리케이션 내부
- 단순한 이벤트 처리
- 실시간 동기 업데이트 필요
- 인프라 추가 부담 없이 간단하게

예: GUI 이벤트, 데이터 바인딩, 게임 이벤트

**Pub-Sub 패턴을 쓸 때**
- 마이크로서비스 간 통신
- 시스템이 분산되어 있음
- 비동기 처리 필요
- 발행자와 구독자 완전 분리 필요
- 확장성 중요

예: 이벤트 기반 아키텍처, 메시징 시스템, 로깅

## 주의할 점

### 공통
- 너무 많은 이벤트는 성능 저하
- 디버깅 어려워질 수 있음
- 명확한 문서화 필요

### 옵저버 특화
- 같은 프로세스 내에서만 효율적
- 분산 시스템에는 부적합

### Pub-Sub 특화
- 인프라 비용과 복잡도
- 간단한 경우 오버킬
- 네트워크 신뢰성 고려
