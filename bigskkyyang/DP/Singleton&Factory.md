# 싱글톤 & 팩토리 패턴 정리

## 디자인 패턴이란?

프로그래밍할 때 자주 발생하는 문제들의 해결책을 정리해둔 것
- 바퀴를 다시 발명하지 말자
- 검증된 방법 사용하기
- 다른 개발자들과 소통할 때 공통 언어

## 싱글톤 패턴 (Singleton Pattern)

### 싱글톤이란?

클래스의 인스턴스가 **딱 하나만** 존재하도록 보장하는 패턴
- 프로그램 전체에서 단 하나의 객체만 만들어짐
- 어디서든 그 하나의 객체를 공유해서 사용

### 왜 필요한가?

**예시 상황**
```
설정 관리자 객체가 있다고 가정

개발자 A: Config config1 = new Config()
개발자 B: Config config2 = new Config()
개발자 C: Config config3 = new Config()

→ 같은 설정인데 객체가 3개나 만들어짐
→ 메모리 낭비
→ 설정 변경 시 3개 다 바꿔야 함
```

**싱글톤 사용하면**
```
개발자 A: Config config = Config.getInstance()
개발자 B: Config config = Config.getInstance()
개발자 C: Config config = Config.getInstance()

→ 셋 다 같은 객체를 가리킴
→ 하나만 만들어짐
```

### 어디에 쓰나?

1. **설정 관리**
   - 앱 전체 설정은 하나만 있으면 됨
   - DB 연결 정보, API 키 등

2. **로거(Logger)**
   - 로그 기록하는 객체는 하나면 충분
   - 여러 개 만들 필요 없음

3. **캐시**
   - 메모리 캐시는 하나만 있어야 함
   - 여러 개면 데이터 꼬임

4. **DB 커넥션 풀**
   - DB 연결을 관리하는 객체
   - 하나로 모든 연결 관리

5. **스레드 풀**
   - 스레드 관리하는 객체
   - 하나로 통합 관리

**핵심**
- 생성자를 통제해서 하나만 만들어지게 함
- 이미 만들어졌으면 기존 객체 반환

### 싱글톤의 장점

1. **메모리 절약**
   - 객체 하나만 만들어짐
   - 불필요한 객체 생성 방지

2. **전역 접근**
   - 어디서든 같은 객체 사용 가능
   - 데이터 공유 쉬움

3. **일관성 유지**
   - 모두가 같은 객체 보니까 데이터 일치
   - 설정 변경하면 전체에 적용

### 싱글톤의 단점

1. **테스트 어려움**
   - 항상 같은 객체라 독립적인 테스트 힘듦
   - 테스트 간 상태가 공유됨

2. **전역 상태 (안티패턴)**
   - 전역 변수처럼 작동
   - 어디서든 접근 가능해서 코드 추적 어려움
   - 의존성 숨김

3. **멀티스레드 문제**
   - 여러 스레드가 동시에 생성하려고 하면 문제
   - 동기화 처리 필요

4. **결합도 증가**
   - 싱글톤에 의존하는 코드가 많아지면 수정 어려움

**Double-Checked Locking**
- 먼저 인스턴스 체크 (빠름)
- 없으면 락 걸고 다시 체크
- 성능과 안전성 둘 다 확보

### 싱글톤 대안

요즘은 싱글톤보다 이런 걸 더 선호함
- **의존성 주입 (Dependency Injection)**
- **컨테이너가 객체 생명주기 관리**
- 테스트하기 쉽고 결합도 낮음

---

## 팩토리 패턴 (Factory Pattern)

### 팩토리란?

객체 생성을 전담하는 클래스나 메서드
- 직접 `new` 하지 않고 팩토리에게 "만들어줘" 하고 요청
- 팩토리가 적절한 객체를 만들어서 줌

### 왜 필요한가?

**문제 상황**
```
사용자가 "강아지" 클릭
→ Dog dog = new Dog()

사용자가 "고양이" 클릭
→ Cat cat = new Cat()

사용자가 "새" 클릭
→ Bird bird = new Bird()

이런 식으로 if-else가 여기저기 흩어짐
새로운 동물 추가하면 모든 곳 수정해야 함
```

**팩토리 사용하면**
```
사용자 입력 받음
→ Animal animal = AnimalFactory.create(userChoice)

팩토리 한 곳에서만 객체 생성 관리
새 동물 추가해도 팩토리만 수정
```

### 어디에 쓰나?

1. **객체 생성 로직이 복잡할 때**
   - 생성 조건이 많음
   - 초기화 과정이 복잡함

2. **생성할 객체 타입이 런타임에 결정될 때**
   - 사용자 선택에 따라 다른 객체
   - 설정 파일 읽어서 결정

3. **객체 생성 코드를 한 곳에 모으고 싶을 때**
   - 유지보수 편함
   - 생성 로직 재사용

4. **실제 사용 예시**
   - 로그인 방식 선택 (이메일, 소셜, 전화번호)
   - 결제 수단 선택 (카드, 계좌이체, 간편결제)
   - 파일 타입별 파서 (JSON, XML, CSV)

### 팩토리 패턴 종류

#### 1. 심플 팩토리 (Simple Factory)

가장 기본적인 형태, 하나의 메서드로 객체 생성

**특징**
- 가장 단순함
- 하나의 팩토리가 여러 타입 생성
- 타입 추가 시 팩토리 코드 수정 필요

#### 2. 팩토리 메서드 (Factory Method)

생성 메서드를 서브클래스에서 오버라이드

**특징**
- 각 타입마다 팩토리 클래스 따로
- 새 타입 추가해도 기존 코드 수정 안 해도 됨
- 확장에는 열려있고 수정에는 닫혀있음 (개방-폐쇄 원칙)

#### 3. 추상 팩토리 (Abstract Factory)

관련된 객체들을 묶어서 생성

**특징**
- 관련된 객체들을 세트로 생성
- 일관성 있는 객체 조합 보장
- 예: 강아지 + 강아지 사료 (고양이 사료 X)

### 팩토리 패턴의 장점

1. **결합도 감소**
   - 클라이언트 코드가 구체적인 클래스 몰라도 됨
   - `Dog`, `Cat` 같은 구체 클래스와 분리

2. **유지보수 쉬움**
   - 생성 로직이 한 곳에 모여있음
   - 수정할 곳이 명확함

3. **확장 용이**
   - 새로운 타입 추가 쉬움
   - 기존 코드 거의 수정 안 해도 됨

4. **단일 책임 원칙**
   - 객체 생성은 팩토리가 담당
   - 비즈니스 로직과 분리

### 팩토리 패턴의 단점

1. **코드 복잡도 증가**
   - 클래스가 많아짐
   - 간단한 경우에는 오버 엔지니어링

2. **추상화 레벨 증가**
   - 코드 흐름 따라가기 어려울 수 있음
   - 디버깅 시 여러 클래스 거쳐야 함

## 싱글톤 vs 팩토리 비교

| 구분 | 싱글톤 | 팩토리 |
|------|--------|--------|
| 목적 | 객체 하나만 보장 | 객체 생성 캡슐화 |
| 인스턴스 개수 | 무조건 1개 | 필요한 만큼 |
| 사용 시기 | 전역 공유 필요 | 생성 로직 복잡 |
| 주요 특징 | 같은 객체 재사용 | 적절한 타입 생성 |
| 예시 | 설정, 로거 | 결제수단, 파서 |

## 언제 사용할까?

### 싱글톤 사용하면 좋을 때
- 프로그램 전체에서 하나만 있어야 하는 객체
- 설정, 로거, 캐시, 커넥션 풀
- 상태를 공유해야 할 때

### 싱글톤 피해야 할 때
- 테스트 중요한 코드
- 상태가 자주 바뀌는 객체
- 멀티스레드 환경에서 복잡해질 때

### 팩토리 사용하면 좋을 때
- 생성할 객체 타입이 실행 중에 결정
- 생성 로직이 복잡하거나 조건이 많음
- 비슷한 객체들을 여러 곳에서 생성
- 새로운 타입 추가가 잦을 때

### 팩토리 피해야 할 때
- 객체 생성이 매우 단순할 때
- 타입이 고정되어 있을 때
- 한두 개 클래스만 있을 때

## 주의할 점

### 싱글톤
1. **멀티스레드 안전성** 꼭 고려
2. **전역 상태** 남용하지 말기
3. **테스트** 어려워진다는 거 인지하고 사용
4. 요즘은 의존성 주입으로 대체하는 추세

### 팩토리
1. **과도한 추상화** 주의 (간단한 경우 그냥 new)
2. **클래스 폭발** 조심 (너무 많은 팩토리 클래스)
3. 정말 여러 타입 다뤄야 할 때만 사용
