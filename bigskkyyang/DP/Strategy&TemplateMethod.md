# 전략 & 템플릿 메서드 패턴 정리

## 전략 패턴 (Strategy Pattern)

### 전략 패턴이란?

알고리즘(동작 방식)을 객체로 만들어서 바꿔 끼울 수 있게 하는 패턴
- 같은 목적이지만 방법이 여러 개일 때
- 실행 중에 알고리즘을 바꿀 수 있음
- "전략"을 교체하는 것처럼 동작 방식 변경

### 왜 필요한가?

**문제 상황**
```
네비게이션 앱을 만든다고 가정

길찾기 방법:
- 최단 거리로 가기
- 빠른 시간으로 가기
- 톨게이트 피해서 가기
- 고속도로 우선으로 가기

if (사용자 선택 == "최단거리"):
    // 최단 거리 계산 로직 100줄
elif (사용자 선택 == "빠른시간"):
    // 빠른 시간 계산 로직 100줄
elif (사용자 선택 == "톨게이트피하기"):
    // 톨게이트 회피 로직 100줄
...

→ 하나의 메서드가 너무 길어짐
→ 새로운 방법 추가하려면 이 거대한 if문 수정
→ 특정 알고리즘만 테스트하기 어려움
```

**전략 패턴 사용하면**
```
각 길찾기 방법을 독립적인 클래스로 분리

- ShortestPathStrategy (최단 거리 전략)
- FastestPathStrategy (빠른 시간 전략)
- NoTollStrategy (톨게이트 회피 전략)

네비게이션이 전략 객체를 받아서 사용
→ 전략만 바꿔 끼우면 됨
→ 새 전략 추가해도 기존 코드 수정 안 함
```

### 어디에 쓰나?

1. **정렬 알고리즘 선택**
   - 버블 정렬, 퀵 정렬, 머지 정렬
   - 데이터 특성에 따라 다른 방식 사용

2. **결제 방식**
   - 카드, 계좌이체, 간편결제
   - 선택한 방식으로 결제 처리

3. **압축 방식**
   - ZIP, RAR, 7Z
   - 파일 형식에 따라 다른 압축

4. **할인 정책**
   - 정률 할인, 정액 할인, 쿠폰 할인
   - 상황에 따라 다른 할인 적용

5. **로그인 방식**
   - 이메일, 소셜, 전화번호
   - 사용자가 선택한 방식으로 인증

### 전략 패턴 구조

```
상황: 내비게이션 앱

1. Strategy 인터페이스 (전략 공통 규격)
   - calculateRoute() 메서드 정의

2. 구체적 전략들 (각각의 알고리즘)
   - ShortestPathStrategy
   - FastestPathStrategy
   - NoTollStrategy

3. Context (전략 사용자)
   - Navigation 클래스
   - 전략 객체를 받아서 사용
   - 전략만 바꾸면 동작 방식 변경
```

### 전략 패턴의 장점

1. **유연성**
   - 실행 중에 알고리즘 변경 가능
   - 사용자가 원하는 방식으로 동작

2. **확장성**
   - 새로운 전략 추가 쉬움
   - 기존 코드 수정 없이 확장

3. **테스트 용이**
   - 각 전략을 독립적으로 테스트
   - 특정 전략만 교체해서 테스트

4. **코드 분리**
   - 거대한 if-else 제거
   - 각 알고리즘이 독립적인 클래스

5. **단일 책임**
   - 한 클래스는 한 가지 알고리즘만 담당

### 전략 패턴의 단점

1. **클래스 증가**
   - 전략마다 클래스 만들어야 함
   - 전략이 많으면 클래스 폭발

2. **복잡도 증가**
   - 간단한 로직인데 과하게 설계할 수 있음
   - 전략이 2~3개면 오히려 복잡해질 수 있음

3. **클라이언트가 전략 알아야 함**
   - 어떤 전략이 있는지 알고 선택해야 함
   - 전략 간 차이점 이해 필요

---

## 템플릿 메서드 패턴 (Template Method Pattern)

### 템플릿 메서드란?

알고리즘의 뼈대(순서)는 정해두고, 세부 구현은 서브클래스에서 하는 패턴
- 전체 흐름은 부모가 제어
- 각 단계의 구체적인 내용은 자식이 구현
- "템플릿"처럼 틀만 정해둠

### 왜 필요한가?

**문제 상황**
```
음료를 만드는 과정

커피 만들기:
1. 물 끓이기
2. 커피 우려내기
3. 컵에 붓기
4. 설탕/우유 추가

차 만들기:
1. 물 끓이기
2. 차 우려내기
3. 컵에 붓기
4. 레몬 추가

→ 전체 흐름은 똑같음 (물 끓이고, 우려내고, 붓고, 추가)
→ 세부 내용만 다름 (커피 vs 차, 설탕 vs 레몬)
→ 중복 코드 발생
→ 흐름 바꾸려면 여러 곳 수정
```

**템플릿 메서드 사용하면**
```
음료 만드는 틀(템플릿)을 부모 클래스에 정의

Beverage (부모):
  makeBeverage():  // 전체 흐름 정의
    1. boilWater()  → 구체적 구현 (공통)
    2. brew()  → 추상 메서드 (자식이 구현)
    3. pourInCup()  → 구체적 구현 (공통)
    4. addCondiments()  → 추상 메서드 (자식이 구현)

Coffee (자식):
  brew() → "커피 우려내기" 구현
  addCondiments() → "설탕/우유 추가" 구현

Tea (자식):
  brew() → "차 우려내기" 구현
  addCondiments() → "레몬 추가" 구현
```

### 어디에 쓰나?

1. **데이터 처리 파이프라인**
   - 읽기 → 처리 → 저장
   - 순서는 같지만 각 단계가 다름
   - CSV, JSON, XML 등

2. **게임 초기화**
   - 리소스 로드 → 화면 설정 → 게임 시작
   - 순서는 고정, 게임마다 세부 내용 다름

3. **테스트 프레임워크**
   - 준비 → 실행 → 검증 → 정리
   - 전체 흐름은 동일, 각 테스트마다 내용 다름

4. **HTTP 요청 처리**
   - 요청 받기 → 검증 → 처리 → 응답
   - 순서는 같지만 API마다 처리 다름

5. **문서 생성**
   - 헤더 작성 → 본문 작성 → 푸터 작성
   - 순서 고정, 문서 종류마다 내용 다름

### 템플릿 메서드 패턴 구조

```
상황: 문서 생성기

1. 부모 클래스 (AbstractDocument)
   generateDocument():  // 템플릿 메서드
     printHeader()  → 추상 메서드
     printBody()  → 추상 메서드
     printFooter()  → 추상 메서드

2. 자식 클래스들
   PDFDocument:
     printHeader() → "PDF 헤더"
     printBody() → "PDF 본문"
     printFooter() → "PDF 푸터"
   
   HTMLDocument:
     printHeader() → "<html><head>"
     printBody() → "<body>내용</body>"
     printFooter() → "</html>"
```

### 템플릿 메서드의 장점

1. **중복 코드 제거**
   - 공통 로직을 부모에 한 번만 작성
   - 자식들은 다른 부분만 구현

2. **알고리즘 구조 통제**
   - 전체 흐름을 부모가 관리
   - 실수로 순서 바꿀 일 없음

3. **확장 용이**
   - 새로운 종류 추가 쉬움
   - 부모 상속받고 다른 부분만 구현

4. **코드 재사용**
   - 공통 로직 여러 자식이 공유
   - 변경 시 부모만 수정

### 템플릿 메서드의 단점

1. **상속 강제**
   - 무조건 상속 관계여야 함
   - 유연성이 떨어질 수 있음

2. **리스코프 치환 원칙 위반 위험**
   - 자식이 부모 역할 제대로 못 할 수 있음
   - 잘못 설계하면 문제

3. **부모 의존성**
   - 부모 클래스 변경이 모든 자식에 영향
   - 부모가 복잡하면 이해 어려움

4. **역제어**
   - 자식이 부모 메서드 호출하는 게 아니라 반대
   - 코드 흐름 따라가기 어려울 수 있음

### Hook 메서드

템플릿 메서드에서 선택적으로 오버라이드할 수 있는 메서드
- 기본 구현이 있지만 필요하면 자식이 바꿀 수 있음
- 전체 흐름에 끼워넣기 (선택사항)

```
예시: 음료 만들기에 Hook 추가

부모:
  makeBeverage():
    boilWater()
    brew()
    pourInCup()
    if (customerWantsCondiments()):  // Hook
      addCondiments()
  
  customerWantsCondiments():  // Hook 메서드
    return true  // 기본값

자식:
  필요하면 오버라이드해서 false 반환
  → 첨가물 추가 안 함
```

---

## 전략 패턴 vs 템플릿 메서드 패턴

### 공통점
- 둘 다 알고리즘/동작을 변경 가능하게 만듦
- 코드 재사용과 확장성 제공
- 객체지향 설계 원칙 활용

### 차이점

| 구분 | 전략 패턴 | 템플릿 메서드 패턴 |
|------|-----------|-------------------|
| 관계 | 객체 간 (구성) | 클래스 간 (상속) |
| 변경 범위 | 알고리즘 전체 교체 | 알고리즘 일부 단계만 변경 |
| 실행 시점 | 런타임에 전략 변경 가능 | 컴파일 타임에 고정 |
| 흐름 제어 | 클라이언트가 제어 | 부모 클래스가 제어 |
| 유연성 | 더 유연함 (교체 가능) | 덜 유연함 (상속 고정) |
| 복잡도 | 클래스 많아짐 | 상속 계층 복잡해짐 |

### 언제 뭘 쓸까?

**전략 패턴 사용**
- 여러 알고리즘 중 선택해야 할 때
- 실행 중에 동작 방식 바꿔야 할 때
- 알고리즘 전체를 교체할 때
- 상속보다 구성을 선호할 때

**템플릿 메서드 사용**
- 전체 흐름은 같고 일부만 다를 때
- 알고리즘의 구조를 강제하고 싶을 때
- 공통 로직이 많고 일부만 달라질 때
- 상속 관계가 자연스러울 때

## 주의할 점

### 전략 패턴
- 전략이 단순하면 오버 엔지니어링
- 전략 객체 생성 비용 고려
- 상태 없는 전략은 재사용 가능

### 템플릿 메서드
- 상속 깊이 주의 (너무 깊으면 복잡)
- 부모 클래스 변경 영향 큰 점 인지
- 자식이 부모에 강하게 의존
